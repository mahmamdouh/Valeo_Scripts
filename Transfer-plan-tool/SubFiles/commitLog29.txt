b'commit 7393afe678befe848a7f844b9ff94b0ed1d05815
Author: Adi GODAVARTHI (JV) <adi.godavarthi.jv@valeo.com>
Date:   Tue Mar 15 18:07:55 2022 +0100

    $100kW-55049$ - SENT driver. Control_Parking_Position
    
    Change-Id: Ibcc10cd74bd0a2658b2e467e58741aef72ccb8ab

diff --git a/src/fw_cu/Components/Cmn/Initialize/BswInit/src/LLSW.c b/src/fw_cu/Components/Cmn/Initialize/BswInit/src/LLSW.c
index 781507e31..bf86855e6 100644
--- a/src/fw_cu/Components/Cmn/Initialize/BswInit/src/LLSW.c
+++ b/src/fw_cu/Components/Cmn/Initialize/BswInit/src/LLSW.c
@@ -56,6 +56,9 @@ void LLSW_Init(void)
     /* *** Call service Init of module Dsadc *** */
      (void)Dsadc_Init();
 
+    /* Initialize the LLSW SENT driver */
+    (void)LlswSENT_Init();
+
     /* Fpga_Init(); */ /* Moved to core2 */
 }
 
diff --git a/src/fw_cu/Components/Cmn/Shared/MemMap/include/NextGen_MemMap.h b/src/fw_cu/Components/Cmn/Shared/MemMap/include/NextGen_MemMap.h
index 92882c6c6..7133f71c2 100644
--- a/src/fw_cu/Components/Cmn/Shared/MemMap/include/NextGen_MemMap.h
+++ b/src/fw_cu/Components/Cmn/Shared/MemMap/include/NextGen_MemMap.h
@@ -3609,6 +3609,35 @@
    #define BSW_STOP_SEC_CODE
    #include "BasicNextGen_MemMap.h"
 
+
+/***************************** SENT ******************************************/
+#elif (defined SENT_SHARED_BUFFER_START_SEC_VAR_CLEARED)
+   #undef SENT_SHARED_BUFFER_START_SEC_VAR_CLEARED
+   #define ISWIF_START_SEC_VAR_FAST_CLEARED
+   #include "BasicNextGen_MemMap.h"
+#elif (defined SENT_SHARED_BUFFER_STOP_SEC_VAR_CLEARED)
+   #undef SENT_SHARED_BUFFER_STOP_SEC_VAR_CLEARED
+   #define ISWIF_STOP_SEC_VAR_FAST_CLEARED
+   #include "BasicNextGen_MemMap.h"
+
+#elif (defined SENT_START_SEC_CODE_FAST)
+   #undef SENT_START_SEC_CODE_FAST
+   #define ISW_START_SEC_CODE_FAST
+   #include "BasicNextGen_MemMap.h"
+#elif (defined SENT_STOP_SEC_CODE_FAST)
+   #undef SENT_STOP_SEC_CODE_FAST
+   #define ISW_STOP_SEC_CODE_FAST
+   #include "BasicNextGen_MemMap.h"
+
+#elif (defined SENT_START_SEC_INIT_CODE_SLOW)
+   #undef SENT_START_SEC_INIT_CODE_SLOW
+   #define TC2_START_SEC_CODE
+   #include "BasicNextGen_MemMap.h"
+#elif (defined SENT_STOP_SEC_INIT_CODE_SLOW)
+   #undef SENT_STOP_SEC_INIT_CODE_SLOW
+   #define TC2_STOP_SEC_CODE
+   #include "BasicNextGen_MemMap.h"
+
 /* DSADC ******************************************************************* */
 #elif (defined DSADC_START_SEC_VAR_FAST_INIT)
    #undef DSADC_START_SEC_VAR_FAST_INIT
diff --git a/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/a2l/.gitkeep b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/a2l/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/doc/.gitkeep b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/doc/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/include/LlswSENT.h b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/include/LlswSENT.h
new file mode 100644
index 000000000..793b700d2
--- /dev/null
+++ b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/include/LlswSENT.h
@@ -0,0 +1,85 @@
+/* ********************************************************************** */
+/* Sourcefile:      LlswSENT.h                                            */
+/*                                                                        */
+/* Project:         eCar project                                          */
+/*                  TriCore Aurix                                         */
+/*                                                                        */
+/* Department:      Valeo Siemens eAutomotive Germany GmbH                */
+/*                  VSeA R&D SWENG OPS 1 OP APP LLSW                      */
+/*                                                                        */
+/* First author:    Adi Godavarthi                                        */
+/* Other authors:   -                                                     */
+/* ********************************************************************** */
+/* Copyright (C) Valeo Siemens eAutomotive Germany GmbH 2020              */
+/* All Rights Reserved. Confidential                                      */
+/* ********************************************************************** */
+
+#ifndef LLSWSENT_H
+#define LLSWSENT_H
+
+/*!
+ * \\addtogroup SENT
+ * @{
+ */
+
+/*================== [includes] =============================================*/
+//#include "IfxPort_reg.h"
+
+/*================== [macros] ===============================================*/
+#ifdef SENT_
+# define EXTERNAL_
+#else
+# define EXTERNAL_ extern
+#endif
+
+
+
+/*================== [type definitions] =====================================*/
+typedef enum
+{
+    IfxSent_ConfigBit_0 = 0,            /**< \\brief Specifies received configuration bit value 0  */
+    IfxSent_ConfigBit_1                 /**< \\brief Specifies received configuration bit value 1  */
+} IfxSent_ConfigBit;
+
+typedef struct
+{
+    uint8             crc;              /**< \\brief Contains the received CRC value */
+    uint8             messageId;        /**< \\brief Contains the received message ID value */
+    uint16            serialData;       /**< \\brief Contains the received serial data value */
+    IfxSent_ConfigBit configBit;        /**< \\brief Contains the received configuration bit value */
+} IfxSent_Sent_SerialMessageFrame;
+
+typedef struct
+{
+    uint32 data;               /**< \\brief Contains the data from last received frame */
+    uint32 timeStamp;          /**< \\brief Contains the timestamp of last received frame */
+    uint8  statusNibble;       /**< \\brief Contains the status and communication Nibble of last received frame */
+} IfxSent_Sent_Frame;
+
+
+/*================== [declaration of public data] ===========================*/
+
+
+
+/*================== [declaration of Inline functions] ======================*/
+
+
+/*================== [declaration of global functions] ======================*/
+#define SENT_START_SEC_INIT_CODE_SLOW
+#include "MemMap.h"
+
+EXTERNAL_ FUNC(void, LlswSENT_CODE) LlswSENT_Init(void);
+
+#define SENT_STOP_SEC_INIT_CODE_SLOW
+#include "MemMap.h"
+
+/*================== [closure] ==============================================*/
+/*! \\misra Warning No C2004:19.6 "Undefine EXTERNAL_ according to Coding Guideline." */
+#undef EXTERNAL_ /* PRQA S 0841 */
+/*! @} doxygen end of group definition */
+#endif
+/* ********************************************************************** */
+/* Copyright (C) Valeo Siemens eAutomotive Germany GmbH 2020              */
+/* All Rights Reserved. Confidential                                      */
+/* ********************************************************************** */
+/*==================[end of file]============================================*/
diff --git a/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/lib/.gitkeep b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/lib/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/make/makefile.mak b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/make/makefile.mak
new file mode 100644
index 000000000..dfeee8216
--- /dev/null
+++ b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/make/makefile.mak
@@ -0,0 +1,27 @@
+# \\\\file\
#
+# \\brief AUTOSAR <ComponentName>
+#
+# This file contains the implementation of AUTOSAR
+# module <ComponentName>.
+#
+# \\author <AuthorInformation> Siemens AG, 91056 Erlangen, Germany
+#
+# Copyright 2015 - 2015 Siemens AG
+# All rights exclusively reserved for Siemens AG,
+# unless expressly agreed to otherwise.#
+################################################################## DEFINITIONS#
+#################################################################
+
+LlswSENT_BASE := $(dir $(abspath $(lastword $(dir $(abspath $(lastword $(MAKEFILE_LIST)))))))
+LlswSENT_PATH_OUT := $(LlswSENT_BASE)generated
+LlswSENT_PATH_USE := $(LlswSENT_BASE)
+CC_FILES_TO_BUILD += $(wildcard $(LlswSENT_BASE)src/*.c)
+CPP_FILES_TO_BUILD += $(wildcard $(LlswSENT_BASE)src/*.cpp)
+ASM_FILES_TO_BUILD += $(wildcard $(LlswSENT_BASE)src/*.s)
+
+LlswSENT_ARCHIVED_LIB := $(wildcard $(LlswSENT_BASE)lib/*.a)
+LlswSENT_GENERATED_LIB := $(LlswSENT_BASE)generated/lib/LlswSENT.a
+LlswSENT_ARCHIVED_A2L := $(wildcard $(LlswSENT_BASE)a2l/*.a2l)
+LlswSENT_GENERATED_A2L := $(LlswSENT_BASE)generated/a2l/LlswSENT.a2l
+A2L_SLAVE_LlswSENT = $(LlswSENT_GENERATED_A2L)
+CC_INCLUDE_PATH += $(LlswSENT_BASE)include
\\ No newline at end of file
diff --git a/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/review/.gitkeep b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/review/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/src/LlswSENT.c b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/src/LlswSENT.c
new file mode 100644
index 000000000..8920146ac
--- /dev/null
+++ b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/src/LlswSENT.c
@@ -0,0 +1,259 @@
+/* ********************************************************************** */
+/* Sourcefile:      LlswSENT.c                                            */
+/*                                                                        */
+/* Project:         eCar project                                          */
+/*                  TriCore Aurix                                         */
+/*                                                                        */
+/* Department:      Valeo Siemens eAutomotive Germany GmbH                */
+/*                  VSeA R&D SWENG OPS 1 OP APP LLSW                      */
+/*                                                                        */
+/* First author:    Adi Godavarthi                                        */
+/* Other authors:   -                                                     */
+/* ********************************************************************** */
+/* Copyright (C) Valeo Siemens eAutomotive Germany GmbH 2020              */
+/* All Rights Reserved. Confidential                                      */
+/* ********************************************************************** */
+
+/*!
+ * \\defgroup LlswSENT - This is the complete title
+ * \\ingroup SENT
+ * @{
+ */
+
+#define SENT_
+
+/*================== [includes] =============================================*/
+#include "Std_Types.h"
+#include "Platform_Types.h"
+#include "IntPrioDef.h"
+#include "IfxPort_reg.h"
+#include "Ifx_reg.h"                                 /*PRQA S 0380*/
+#include "LlswSENT.h"
+#include "SftyDmaDrvr_cfg.h"
+#include "IfxSent_reg.h"
+#include "IfxSrc_reg.h"
+#include "IfxScuWdt.h"
+#include "LLSW_CompilerAbstraction.h"
+#include "Compiler.h"
+
+/*================== [defines] ==============================================*/
+#define WATCH_DOG_ENABLED                    FALSE
+#define ISR_PRIORITY_SENT                    0xF3
+#define SENT_FRAMECHECKMODE_PASTSYNCPULSE    0U
+#define LLSW_N_P5V_PLC_SENS_EN_OMCR_PCL      MODULE_P11.OMCR.B.PCL9
+
+/*================== [declaration of public data] =================================*/
+
+#define SENT_SHARED_BUFFER_START_SEC_VAR_CLEARED
+#include "MemMap.h"
+
+static uint32 Sent_ErrorStatus;
+
+#define SENT_SHARED_BUFFER_STOP_SEC_VAR_CLEARED
+#include "MemMap.h"
+
+/*================== [type definitions] =====================================*/
+
+/*================== [local data] ===========================================*/
+
+#define SENT_START_SEC_CODE_FAST
+#include "MemMap.h"
+
+IFX_INTERRUPT(isr_sent, VTABLE_CPU2, ISR_PRIORITY_SENT)   /*PRQA S 3432, 3408*/ /* ISR */
+{
+   Sent_ErrorStatus = SENT_CH9_INTSTAT.U;
+   SENT_CH9_INTCLR.U = (Sent_ErrorStatus & 0x17FCU);  /* 0x17FC: 01 0111 1111 1100      clearing of error flags
+                                                        Ensure that bit13(WDI), bit11(SDI), bit1(RDI), bit0(RSI) are not cleared */
+}
+
+#define SENT_STOP_SEC_CODE_FAST
+#include "MemMap.h"
+
+#define SENT_START_SEC_INIT_CODE_SLOW
+#include "MemMap.h"
+
+void LlswSENT_Init(void)                             /* PRQA S 4700*/ /* Metric out of threshold. No functional impact */
+{
+    Ifx_SENT_CLC          mySENT_CLC;                /*PRQA S 0759*/ /* Using of union type is allowed for registers */
+    Ifx_SENT_FDR          mySENT_FDR;                /*PRQA S 0759*/ /* Using of union type is allowed for registers */
+    Ifx_SENT_CH_RCR       mySENT_CH_RCR;             /*PRQA S 0759*/ /* Using of union type is allowed for registers */
+    Ifx_SENT_CH_VIEW      mytempVIEW;                /*PRQA S 0759*/ /* Using of union type is allowed for registers */
+    Ifx_SENT_CH_IOCR      mytempIOCR;                /*PRQA S 0759*/ /* Using of union type is allowed for registers */
+    Ifx_SENT_CH_INP       mytempINP;                 /*PRQA S 0759*/ /* Using of union type is allowed for registers */
+    Ifx_SENT_CH_INTEN     mySENT_INTEN;              /*PRQA S 0759*/ /* Using of union type is allowed for registers */
+    Ifx_SRC_SRCR          mySRC_SRCR;                /*PRQA S 0759*/ /* Using of union type is allowed for registers */
+    uint16                passwd;
+
+    mySENT_CLC.U = SENT_CLC.U;
+
+    if (mySENT_CLC.B.DISS == 1U)                     /* check if module is disabled */
+    {
+        passwd = IfxScuWdt_getCpuWatchdogPassword();
+        IfxScuWdt_clearCpuEndinit(passwd);
+        SENT_CLC.B.DISR = 0U;                        /* enable the module */
+        IfxScuWdt_setCpuEndinit(passwd);
+        if (SENT_CLC.U != 0U)
+        {}
+    }
+
+    passwd = IfxScuWdt_getCpuWatchdogPassword();
+    IfxScuWdt_clearCpuEndinit(passwd);
+
+    mySENT_FDR.U          = 0U;                      /* module clock initialisation */
+    mySENT_FDR.B.STEP     = 1023U;
+    mySENT_FDR.B.DM       = 1U;                      /* Fractional divider not required, pass 1:1 */
+    SENT_FDR.U            = mySENT_FDR.U;
+
+    SENT_TPD.B.TDIV       = 0U;                      /* time stamp pre-divider */
+
+    IfxScuWdt_setCpuEndinit(passwd);
+
+    SENT_CH9_RCR.B.CEN    = 0U;                      /* disable channel 9. RCR.CEN must be cleared before changing CPDR.PDIV or CFDR.DIV */
+
+    SENT_CH9_CPDR.B.PDIV  = 0U;                      /* Fsys = Fsent = 100MHz. Ffracdiv = 100MHz. Fpdiv = 100MHz */
+
+    SENT_CH9_CFDR.B.DIV   = 33600U;                  /* 100*56*6 = 33600.  DIV must be set in the range of [2200, 49100]
+                                                        This value is derived based on the TICK length of the KMZ sensor.
+                                                        Measure the calibration pulse length in CRO and identify the TICK length */
+    mySENT_CH_RCR.U       = 0U;
+    mySENT_CH_RCR.B.IEP   = 0U;                      /* 0: End pulse (pause) not ignored.  1: End pulse (pause) ignored */
+    mySENT_CH_RCR.B.ACE   = 0U;                      /* 0: Serial CRC calculation as specified in J2716 JAN2010    1: Alternative 4 bit in parallel CRC */
+    mySENT_CH_RCR.B.SNI   = 0U;                      /* 0: Status Nibble not included in CRC   1: Status Nibble included in CRC */
+    mySENT_CH_RCR.B.SDP   = 0U;                      /* 0: Automatic Serial Data Processing is disabled   1:Automatic Serial Data Processing is enabled */
+                                                     /* -----------TODO-------------------------*/
+    mySENT_CH_RCR.B.SCDIS = 1U;                      /* 0: CRC for serial data enabled   1: CRC for serial data disabled (CRC nibble can be read from SDSx.
+                                                           The CPU must perform the CRC on the current data by SW) */
+    mySENT_CH_RCR.B.CDIS  = 0U;                      /* 0: CRC is enabled  1: CRC is disabled (CRC nibble can be read from RSRx.
+                                                           The CPU must perform the CRC on the current data by SW) */
+ /* mySENT_CH_RCR.B.CFC   = SENT_FRAMECHECKMODE_PASTSYNCPULSE;     ---TODO----- */
+
+    mySENT_CH_RCR.B.FRL   = 6U;                      /* frame length */
+    mySENT_CH_RCR.B.CRZ   = 0U;                      /* 0: Augmentation is selected for both 4-bit message CRC and the 4-bit CRC of the serial messages (legacy, 16 frames) (default)
+                                                        1: Augmentation is switched off for both 4-bit message CRC and the 4-bit CRC of the serial messages (legacy, 16 frames) */
+                                                     /*  ---------------TODO -----------------*/
+
+    mySENT_CH_RCR.B.ESF   = 1U;                      /* serial frame
+                                                        0: 16 frames (4bit ID, 8bit DATA, 4bit CRC)
+                                                        1: 18 frames  (4/8bit ID, 12/16bit DATA, 6bit CRC) */
+
+    mySENT_CH_RCR.B.IDE   = 0U;                      /* 0: Drift Errors enabled    1: Drift Errors disabled
+                                                        This bit selects if drift errors lead to frame rejection and if an interrupt(INTSTAT.FDI) is generated.
+                                                        During a long pause period the accumulated drift could be more than 1.5625%  In this case drift error can be disabled */
+
+    mySENT_CH_RCR.B.SUSEN = 0U;                      /* This bit makes it possible to set the SENT channel into Suspend Mode via OCDS (on chip debug support).
+                                                        Bit SUSEN is reset via OCDS Reset.
+                                                        0: An OCDS suspend trigger is ignored by this SENT channel.
+                                                        1: An OCDS suspend trigger disables the SENT channel: As soon as the SPC sender logic of the SENT channel becomes idle,
+                                                           the module is stopped while all registers of the channel stay readable.
+                                                           The receiver is stopped unconditionally. A partly received frame is discarded */
+
+    mySENT_CH_RCR.B.FDFL  = 0U;                      /* Frequency Drift Check based on Frame Length.
+                                                        0: FDFL mode deactivated, RCR.CFC is valid (if IDE is cleared).
+                                                        1: FDFL mode is activated, IEP and IDE must be set too for proper function  */
+    SENT_CH9_RCR.U        = mySENT_CH_RCR.U;
+
+    mytempVIEW.U          = 0U;
+    mytempVIEW.B.RDNP0    = 0U;
+    mytempVIEW.B.RDNP1    = 1U;
+    mytempVIEW.B.RDNP2    = 2U;
+    mytempVIEW.B.RDNP3    = 3U;
+    mytempVIEW.B.RDNP4    = 4U;
+    mytempVIEW.B.RDNP5    = 5U;
+    mytempVIEW.B.RDNP6    = 6U;
+    mytempVIEW.B.RDNP7    = 7U;
+    SENT_CH9_VIEW.U       = mytempVIEW.U;
+
+    mytempIOCR.U          = 0U;
+    mytempIOCR.B.ALTI     = 1U;                      /* SENT channel is connected to P00.10  SENT_SENT9B  B-> 01 */
+    mytempIOCR.B.DEPTH    = 0U;
+    mytempIOCR.B.OIE      = 0U;
+    mytempIOCR.B.IIE      = 0U;
+    mytempIOCR.B.CEC      = 1U;
+    mytempIOCR.B.CREG     = 1U;
+    mytempIOCR.B.CFEG     = 1U;
+    mytempIOCR.B.ETS      = 0U;
+    mytempIOCR.B.CTR      = 0U;
+    SENT_CH9_IOCR.U       = mytempIOCR.U;
+
+    mytempINP.U           = 0U;
+    mytempINP.B.TDI       = 0U;                      /* Not needed. TDI not enabled */
+    mytempINP.B.TBI       = 0U;                      /* Not needed. TBI not enabled */
+    mytempINP.B.RSI       = 0U;                      /* Not needed. RSI not enabled */
+    mytempINP.B.RDI       = 0U;                      /* trigger0 (TRIG0) */
+    mytempINP.B.WDI       = 1U;                      /* trigger1 (TRIG1) */
+    mytempINP.B.SDI       = 2U;                      /* trigger2 (TRIG2) */
+    mytempINP.B.RBI       = 3U;                      /* trigger3 (TRIG3) */
+    mytempINP.B.ERRI      = 3U;                      /* trigger3 (TRIG3). ERRI is one single node pointer for FRI + FDI + NNI + NVI + CRCI + WSI + SCRI */
+    SENT_CH9_INP.U        = mytempINP.U;
+
+    mySENT_INTEN.U        = 0U;
+    mySENT_INTEN.B.RSI    = 0U;                      /* This bit is set at the successfully received end of a frame. Depending on bit RCRx.CDIS this indicates a successful check of the CRC.*/
+    mySENT_INTEN.B.RDI    = 1U;                      /* RDI is activated when a received frame is moved to a Receive Data Register RDR. Both RDI and RSI will be issued together in normal use cases */
+
+    mySENT_INTEN.B.RBI    = 1U;                      /* Receive Buffer Overflow Interrupt */
+    mySENT_INTEN.B.TDI    = 0U;                      /* Transfer Data Interrupt */
+    mySENT_INTEN.B.TBI    = 0U;                      /* Transmit Buffer Underflow Interrupt */
+
+    mySENT_INTEN.B.FRI    = 1U;                      /* Frequency Range Interrupt. Calibration pulse deviates more than +/- 25% from the nominal value. The referring data is ignored */
+    mySENT_INTEN.B.FDI    = 1U;                      /* Frequency Drift Interrupt. Subsequent Calibration pulse deviates more than 1.5625% (1/64) from its predecessor */
+    mySENT_INTEN.B.NNI    = 1U;                      /* Number of Nibbles Wrong. More nibbles or too few nibbles */
+    mySENT_INTEN.B.NVI    = 1U;                      /* Nibbles Value out of Range */
+    mySENT_INTEN.B.CRCI   = 0U;                      /* CRC error */
+    mySENT_INTEN.B.WSI    = 0U;                      /* ------------- TODO --------------------------*/
+                                                     /* Wrong Status and Communication Nibble Error Request Flag. In Short Serial Frame Mode (RCR.ESF is cleared),
+                                                        this bit is set if the Status and Communication nibble shows a start bit in a frame other than frame number n x 16.
+                                                        In Enhanced Serial Frame Mode this bit is without function.*/
+
+    mySENT_INTEN.B.SDI    = 0U;                      /* ------------- TODO --------------------------
+                                                        Serial Data Receive Interrupt Request Flag. This bit is set after all serial data bits have been received via the Status
+                                                        and Communication nibble. Depending on bit RCRx.SCDIS this indicates a successful check of the CRC */
+
+    mySENT_INTEN.B.SCRI   = 0U;                      /* Serial Data CRC Error */
+
+    mySENT_INTEN.B.WDI    = 0U;                      /* ------------- TODO -------------------------- */
+    SENT_CH9_INTEN.U      = mySENT_INTEN.U;
+
+    mySRC_SRCR.U          = 0U;
+    mySRC_SRCR.B.SRPN     = (uint32)SFTY_DMA_DRVR_CH_IDX_SENT_RAWDATA;
+    mySRC_SRCR.B.SRE      = 1U;
+    mySRC_SRCR.B.TOS      = TOS_DMA;
+    mySRC_SRCR.B.CLRR     = 1U;
+    SRC_SENT0.U           = mySRC_SRCR.U;            /* TRIG0 goes to SRC0 */
+
+    mySRC_SRCR.U          = 0U;
+    mySRC_SRCR.B.SRPN     = (uint32)SFTY_DMA_DRVR_CH_IDX_SENT_TIMEOUT_STATUS;
+    mySRC_SRCR.B.SRE      = 0U;                      /* ------------- TODO -------------------------- */
+    mySRC_SRCR.B.TOS      = TOS_DMA;
+    mySRC_SRCR.B.CLRR     = 1U;
+    SRC_SENT1.U           = mySRC_SRCR.U;            /* TRIG1 goes to SRC1 */
+
+    mySRC_SRCR.U          = 0U;
+    mySRC_SRCR.B.SRPN     = (uint32)SFTY_DMA_DRVR_CH_IDX_SENT_FAULTSTATUS;
+    mySRC_SRCR.B.SRE      = 0U;                      /* ------------- TODO -------------------------- */
+    mySRC_SRCR.B.TOS      = TOS_DMA;
+    mySRC_SRCR.B.CLRR     = 1U;
+    SRC_SENT2.U           = mySRC_SRCR.U;            /* TRIG2 goes to SRC2 */
+
+    mySRC_SRCR.U          = 0U;
+    mySRC_SRCR.B.SRPN     = (uint32)ISR_PRIORITY_SENT;
+    mySRC_SRCR.B.SRE      = 1U;                      /* ------------- TODO -------------------------- */
+    mySRC_SRCR.B.TOS      = TOS_CPU2;
+    mySRC_SRCR.B.CLRR     = 1U;
+    SRC_SENT3.U           = mySRC_SRCR.U;            /* TRIG3 goes to SRC3 */
+
+    SENT_CH9_RCR.B.CEN    = 1U;
+
+}
+
+#define SENT_STOP_SEC_INIT_CODE_SLOW
+#include "MemMap.h"
+
+/*================== [closure] ==============================================*/
+/*! \\misra Warning No C2004:19.6 "Using \'#undef\' for master c-file"          */
+#undef SENT_ /* PRQA S 0841 */
+/*! @} doxygen end of group definition */
+/* ********************************************************************** */
+/* Copyright (C) Valeo Siemens eAutomotive Germany GmbH 2020              */
+/* All Rights Reserved. Confidential                                      */
+/* ********************************************************************** */
+/*==================[end of file]============================================*/
diff --git a/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/test/.gitkeep b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/test/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/src/fw_cu/Components/Safety/Sfty_Cmn/SftyDmaDrvr/include/SftyDmaDrvr_cfg.h b/src/fw_cu/Components/Safety/Sfty_Cmn/SftyDmaDrvr/include/SftyDmaDrvr_cfg.h
index 1b1893d17..4c5b10854 100644
--- a/src/fw_cu/Components/Safety/Sfty_Cmn/SftyDmaDrvr/include/SftyDmaDrvr_cfg.h
+++ b/src/fw_cu/Components/Safety/Sfty_Cmn/SftyDmaDrvr/include/SftyDmaDrvr_cfg.h
@@ -104,17 +104,14 @@
 /**************QSPI RX ******************/
 #define SFTY_DMA_DRVR_CH_IDX_QSPI_RX_TRIG                         (DMA_CHANNEL44)
 
-/**************DC CURRENT CHANNELS ******************/
-#define SFTY_DMA_DRVR_CH_IDX_DC_U_1_M_MON_DATA_VADC               (DMA_CHANNEL45)
-#define SFTY_DMA_DRVR_CH_IDX_DC_U_1_P_MON_DATA_VADC               (DMA_CHANNEL46)
-
-#define SFTYDMADRVR_CH_IDX_SFTYSBC_TX_TRIG                        (DMA_CHANNEL47)
-#define SFTYDMADRVR_CH_IDX_SFTYSBC_RX_TRIG                        (DMA_CHANNEL48)
-
-/* === KL30 ============ */
-#define SFTY_DMA_DRVR_CH_IDX_PR_MEAS_B_KL30_VADC                  (DMA_CHANNEL49)
-
-#define SFTY_DMA_DRVR_CH_IDX_PR_MEAS_A_KL30_VADC                  (DMA_CHANNEL50)
+/**************SENT CHANNELS ******************/
+#define SFTY_DMA_DRVR_CH_IDX_SENT_FAULTSTATUS_DMATIMESTAMP        (DMA_CHANNEL45)
+#define SFTY_DMA_DRVR_CH_IDX_SENT_FAULTSTATUS                     (DMA_CHANNEL46)
+#define SFTY_DMA_DRVR_CH_IDX_SENT_TSTAMP                          (DMA_CHANNEL47)
+#define SFTY_DMA_DRVR_CH_IDX_SENT_CRC                             (DMA_CHANNEL48)
+#define SFTY_DMA_DRVR_CH_IDX_SENT_RAWDATA                         (DMA_CHANNEL49)
+#define SFTY_DMA_DRVR_CH_IDX_SENT_TIMEOUT_DMATIMESTAMP            (DMA_CHANNEL50)
+#define SFTY_DMA_DRVR_CH_IDX_SENT_TIMEOUT_STATUS                  (DMA_CHANNEL51)
 
 /*  ==== P15 ==== */
 #if SYSCON_FTR_PSM == 1  /* Feature use IPM motor */
diff --git a/src/fw_cu/Components/Safety/Sfty_Cmn/SftyDmaDrvr/src/SftyDmaDrvr_cfg.c b/src/fw_cu/Components/Safety/Sfty_Cmn/SftyDmaDrvr/src/SftyDmaDrvr_cfg.c
index 27e77240d..622f946d3 100644
--- a/src/fw_cu/Components/Safety/Sfty_Cmn/SftyDmaDrvr/src/SftyDmaDrvr_cfg.c
+++ b/src/fw_cu/Components/Safety/Sfty_Cmn/SftyDmaDrvr/src/SftyDmaDrvr_cfg.c
@@ -48,6 +48,8 @@
 #include "Os_user.h"
 #include "VsiSrv.h"
 #include "BswFpgaIf.h"
+#include "IfxSent_reg.h"
+
 /*================== [defines] ==============================================*/
 
 /*================== [type definitions] =====================================*/
@@ -60,6 +62,13 @@
 
 /*================== [definition of global data] ============================*/
 
+/* ------------- TODO: Remove these buffers after replacing with SSW buffers  --------------------------*/
+#pragma align 0x10
+SftyDma_ParkLockSENTDataType LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx;
+SftyDma_DataType LLSW_SftyDmaParkLockEvlnSENTStsInfoRx;
+#pragma align restore
+
+
 #define SFTY_DMA_DRVR_START_SEC_CONST_AREA_0
 #include "MemMap.h"
 
@@ -1110,8 +1119,208 @@ CONST(SftyDmaDrvrChannelCfg_Type, SFTY_DMA_DRVR_CALIB) SftyDmaDrvrChannelCfg[] =
       .HRR.B.HRP          = (uint32) SFTY_DMA_DRVR_HWRES_PARTITION_0,              /*Hardware Resource Register*/
    },
 
+   {/** SENT RAWDATA */
+      .ChIndex            = SFTY_DMA_DRVR_CH_IDX_SENT_RAWDATA,
+      .CH.SADR.U          = (uint32)(&SENT_RDR9.U),
+//    .CH.DADR.U          = (uint32)(&(SftyDmaParkLockPosnAcqnSENTSnrDataRx.SnsrData)),      /* TODO */
+      .CH.DADR.U          = (uint32)(&(LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx.SnsrData)), /* TODO */
+      .CH.CHCFGR.B.PRSEL  = (uint32)SFTY_DMA_DRVR_PRSEL_DAISY_CHAIN,
+      .CH.CHCFGR.B.RROAT  = (uint32)SFTY_DMA_DRVR_RROAT_TRANSFER,
+      .CH.CHCFGR.B.TREL   = 1U,
+      .CH.CHCFGR.B.CHMODE = (uint32)SFTY_DMA_DRVR_CHMODE_CONTINUOUS_MODE,
+      .CH.CHCFGR.B.CHDW   = (uint32)SFTY_DMA_DRVR_CHDW_4BYTE,
+      .CH.CHCFGR.B.BLKM   = (uint32)SFTY_DMA_DRVR_BLKM_MOVE_1,
+      .CH.ADICR.B.SCBE    = (uint32)SFTY_DMA_DRVR_SCBE_ENABLE,
+      .CH.ADICR.B.DCBE    = (uint32)SFTY_DMA_DRVR_DCBE_ENABLE,
+      .CH.ADICR.B.SMF     = (uint32)SFTY_DMA_DRVR_SMF_BY_1DW,
+      .CH.ADICR.B.DMF     = (uint32)SFTY_DMA_DRVR_DMF_BY_1DW,
+      .CH.ADICR.B.INCS    = (uint32)SFTY_DMA_DRVR_INCS_INCREMENT,
+      .CH.ADICR.B.INCD    = (uint32)SFTY_DMA_DRVR_INCD_INCREMENT,
+      .CH.ADICR.B.CBLS    = (uint32)SFTY_DMA_DRVR_CBLS_NO_CIRBUF,
+      .CH.ADICR.B.CBLD    = (uint32)SFTY_DMA_DRVR_CBLD_NO_CIRBUF,
+      .CH.ADICR.B.STAMP   = (uint32)SFTY_DMA_DRVR_STAMP_DISABLE,
+      .CH.ADICR.B.IRDV    = 0U,
+      .CH.ADICR.B.INTCT   = (uint32)SFTY_DMA_DRVR_INTCT_TRG_ON_IRDV_MATCH,
+      .CH.ADICR.B.SHCT    = (uint32)SFTY_DMA_DRVR_SHCT_NO_SHADOW,
+      .CH.SHADR.U         = (uint32)(SFTY_DMA_DRVR_SHADR_NOT_USED),
+      .TSR.B.ECH          = (uint32)SFTY_DMA_DRVR_ECH_ENABLE,
+      .SRC.U              = 0U,
+      .HRR.B.HRP          = (uint32)SFTY_DMA_DRVR_HWRES_PARTITION_0,
+   },
+
+   {/** SENT CRC */
+      .ChIndex            = SFTY_DMA_DRVR_CH_IDX_SENT_CRC,
+      .CH.SADR.U          = (uint32)(&SENT_CH9_RSR.U),  /* RSR: receive status register */
+   // .CH.DADR.U          = (uint32)(&(SftyDmaParkLockPosnAcqnSENTSnrDataRx.CrcData)),       /* TODO */
+      .CH.DADR.U          = (uint32)(&(LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx.CrcData)),  /* TODO */
+      .CH.CHCFGR.B.PRSEL  = (uint32)SFTY_DMA_DRVR_PRSEL_DAISY_CHAIN,
+      .CH.CHCFGR.B.RROAT  = (uint32)SFTY_DMA_DRVR_RROAT_TRANSFER,
+      .CH.CHCFGR.B.TREL   = 1U,
+      .CH.CHCFGR.B.CHMODE = (uint32)SFTY_DMA_DRVR_CHMODE_CONTINUOUS_MODE,
+      .CH.CHCFGR.B.CHDW   = (uint32)SFTY_DMA_DRVR_CHDW_4BYTE,
+      .CH.CHCFGR.B.BLKM   = (uint32)SFTY_DMA_DRVR_BLKM_MOVE_1,
+      .CH.ADICR.B.SCBE    = (uint32)SFTY_DMA_DRVR_SCBE_ENABLE,
+      .CH.ADICR.B.DCBE    = (uint32)SFTY_DMA_DRVR_DCBE_ENABLE,
+      .CH.ADICR.B.SMF     = (uint32)SFTY_DMA_DRVR_SMF_BY_1DW,
+      .CH.ADICR.B.DMF     = (uint32)SFTY_DMA_DRVR_DMF_BY_1DW,
+      .CH.ADICR.B.INCS    = (uint32)SFTY_DMA_DRVR_INCS_INCREMENT,
+      .CH.ADICR.B.INCD    = (uint32)SFTY_DMA_DRVR_INCD_INCREMENT,
+      .CH.ADICR.B.CBLS    = (uint32)SFTY_DMA_DRVR_CBLS_NO_CIRBUF,
+      .CH.ADICR.B.CBLD    = (uint32)SFTY_DMA_DRVR_CBLD_NO_CIRBUF,
+      .CH.ADICR.B.STAMP   = (uint32)SFTY_DMA_DRVR_STAMP_DISABLE,
+      .CH.ADICR.B.IRDV    = 0U,
+      .CH.ADICR.B.INTCT   = (uint32)SFTY_DMA_DRVR_INTCT_TRG_ON_IRDV_MATCH,
+      .CH.ADICR.B.SHCT    = (uint32)SFTY_DMA_DRVR_SHCT_NO_SHADOW,
+      .CH.SHADR.U         = (uint32)(SFTY_DMA_DRVR_SHADR_NOT_USED),
+      .TSR.B.ECH          = (uint32)SFTY_DMA_DRVR_ECH_ENABLE,
+      .SRC.U              = 0U,
+      .HRR.B.HRP          = (uint32)SFTY_DMA_DRVR_HWRES_PARTITION_0,
+   },
 
+   {/** SENT TSTAMP */
+      .ChIndex            = SFTY_DMA_DRVR_CH_IDX_SENT_TSTAMP,
+      .CH.SADR.U          = (uint32)(&SENT_RTS9.U),
+    //.CH.DADR.U          = (uint32)(&(SftyDmaParkLockPosnAcqnSENTSnrDataRx.TiStampRts)),       /* TODO */
+      .CH.DADR.U          = (uint32)(&(LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx.TiStampRts)),  /* TODO */
+      .CH.CHCFGR.B.PRSEL  = (uint32)SFTY_DMA_DRVR_PRSEL_HW_TRIGGER,
+      .CH.CHCFGR.B.RROAT  = (uint32)SFTY_DMA_DRVR_RROAT_TRANSFER,
+      .CH.CHCFGR.B.TREL   = 1U,
+      .CH.CHCFGR.B.CHMODE = (uint32)SFTY_DMA_DRVR_CHMODE_CONTINUOUS_MODE,
+      .CH.CHCFGR.B.CHDW   = (uint32)SFTY_DMA_DRVR_CHDW_4BYTE,
+      .CH.CHCFGR.B.BLKM   = (uint32)SFTY_DMA_DRVR_BLKM_MOVE_1,
+      .CH.ADICR.B.SCBE    = (uint32)SFTY_DMA_DRVR_SCBE_ENABLE,
+      .CH.ADICR.B.DCBE    = (uint32)SFTY_DMA_DRVR_DCBE_ENABLE,
+      .CH.ADICR.B.SMF     = (uint32)SFTY_DMA_DRVR_SMF_BY_1DW,
+      .CH.ADICR.B.DMF     = (uint32)SFTY_DMA_DRVR_DMF_BY_1DW,
+      .CH.ADICR.B.INCS    = (uint32)SFTY_DMA_DRVR_INCS_INCREMENT,
+      .CH.ADICR.B.INCD    = (uint32)SFTY_DMA_DRVR_INCD_INCREMENT,
+      .CH.ADICR.B.CBLS    = (uint32)SFTY_DMA_DRVR_CBLS_NO_CIRBUF,
+      .CH.ADICR.B.CBLD    = (uint32)SFTY_DMA_DRVR_CBLD_NO_CIRBUF,
+      .CH.ADICR.B.STAMP   = (uint32)SFTY_DMA_DRVR_STAMP_DISABLE,
+      .CH.ADICR.B.IRDV    = 0U,
+      .CH.ADICR.B.INTCT   = (uint32)SFTY_DMA_DRVR_INTCT_TRG_ON_IRDV_MATCH,
+      .CH.ADICR.B.SHCT    = (uint32)SFTY_DMA_DRVR_SHCT_NO_SHADOW,
+      .CH.SHADR.U         = (uint32)(SFTY_DMA_DRVR_SHADR_NOT_USED),
+      .TSR.B.ECH          = (uint32)SFTY_DMA_DRVR_ECH_ENABLE,
+      .SRC.U              = 0U,
+      .HRR.B.HRP          = (uint32)SFTY_DMA_DRVR_HWRES_PARTITION_0,
+   },
 
+   {/** SENT TIMEOUT STATUS */
+      .ChIndex            = SFTY_DMA_DRVR_CH_IDX_SENT_TIMEOUT_STATUS,
+      .CH.SADR.U          = (uint32)(&SENT_CH9_INTSTAT.U),
+//    .CH.DADR.U          = (uint32)(&(SftyDmaParkLockPosnAcqnSENTSnrDataRx.RxIntStat)),        /* TODO */
+      .CH.DADR.U          = (uint32)(&(LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx.RxIntStat)),   /* TODO */
+      .CH.CHCFGR.B.PRSEL  = (uint32)SFTY_DMA_DRVR_PRSEL_DAISY_CHAIN,
+      .CH.CHCFGR.B.RROAT  = (uint32)SFTY_DMA_DRVR_RROAT_TRANSFER,
+      .CH.CHCFGR.B.TREL   = 1U,
+      .CH.CHCFGR.B.CHMODE = (uint32)SFTY_DMA_DRVR_CHMODE_CONTINUOUS_MODE,
+      .CH.CHCFGR.B.CHDW   = (uint32)SFTY_DMA_DRVR_CHDW_4BYTE,
+      .CH.CHCFGR.B.BLKM   = (uint32)SFTY_DMA_DRVR_BLKM_MOVE_1,
+      .CH.ADICR.B.SCBE    = (uint32)SFTY_DMA_DRVR_SCBE_ENABLE,
+      .CH.ADICR.B.DCBE    = (uint32)SFTY_DMA_DRVR_DCBE_ENABLE,
+      .CH.ADICR.B.SMF     = (uint32)SFTY_DMA_DRVR_SMF_BY_1DW,
+      .CH.ADICR.B.DMF     = (uint32)SFTY_DMA_DRVR_DMF_BY_1DW,
+      .CH.ADICR.B.INCS    = (uint32)SFTY_DMA_DRVR_INCS_INCREMENT,
+      .CH.ADICR.B.INCD    = (uint32)SFTY_DMA_DRVR_INCD_INCREMENT,
+      .CH.ADICR.B.CBLS    = (uint32)SFTY_DMA_DRVR_CBLS_NO_CIRBUF,
+      .CH.ADICR.B.CBLD    = (uint32)SFTY_DMA_DRVR_CBLD_NO_CIRBUF,
+      .CH.ADICR.B.STAMP   = (uint32)SFTY_DMA_DRVR_STAMP_DISABLE,
+      .CH.ADICR.B.IRDV    = 0U,
+      .CH.ADICR.B.INTCT   = (uint32)SFTY_DMA_DRVR_INTCT_TRG_ON_IRDV_MATCH,
+      .CH.ADICR.B.SHCT    = (uint32)SFTY_DMA_DRVR_SHCT_NO_SHADOW,
+      .CH.SHADR.U         = (uint32)(SFTY_DMA_DRVR_SHADR_NOT_USED),
+      .TSR.B.ECH          = (uint32)SFTY_DMA_DRVR_ECH_ENABLE,
+      .SRC.U              = 0U,
+      .HRR.B.HRP          = (uint32)SFTY_DMA_DRVR_HWRES_PARTITION_0,
+   },
+
+   {/** SENT TIMEOUT - DMA TIMESTAMP */
+      .ChIndex            = SFTY_DMA_DRVR_CH_IDX_SENT_TIMEOUT_DMATIMESTAMP,
+      .CH.SADR.U          = (uint32)(&DMA_TIME.U),
+//    .CH.DADR.U          = (uint32)(&(SftyDmaParkLockPosnAcqnSENTSnrDataRx.TiStampDma)),       /* TODO */
+      .CH.DADR.U          = (uint32)(&(LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx.TiStampDma)),  /* TODO */
+      .CH.CHCFGR.B.PRSEL  = (uint32)SFTY_DMA_DRVR_PRSEL_HW_TRIGGER,
+      .CH.CHCFGR.B.RROAT  = (uint32)SFTY_DMA_DRVR_RROAT_TRANSFER,
+      .CH.CHCFGR.B.TREL   = 1U,
+      .CH.CHCFGR.B.CHMODE = (uint32)SFTY_DMA_DRVR_CHMODE_CONTINUOUS_MODE,
+      .CH.CHCFGR.B.CHDW   = (uint32)SFTY_DMA_DRVR_CHDW_4BYTE,
+      .CH.CHCFGR.B.BLKM   = (uint32)SFTY_DMA_DRVR_BLKM_MOVE_1,
+      .CH.ADICR.B.SCBE    = (uint32)SFTY_DMA_DRVR_SCBE_ENABLE,
+      .CH.ADICR.B.DCBE    = (uint32)SFTY_DMA_DRVR_DCBE_ENABLE,
+      .CH.ADICR.B.SMF     = (uint32)SFTY_DMA_DRVR_SMF_BY_1DW,
+      .CH.ADICR.B.DMF     = (uint32)SFTY_DMA_DRVR_DMF_BY_1DW,
+      .CH.ADICR.B.INCS    = (uint32)SFTY_DMA_DRVR_INCS_INCREMENT,
+      .CH.ADICR.B.INCD    = (uint32)SFTY_DMA_DRVR_INCD_INCREMENT,
+      .CH.ADICR.B.CBLS    = (uint32)SFTY_DMA_DRVR_CBLS_NO_CIRBUF,
+      .CH.ADICR.B.CBLD    = (uint32)SFTY_DMA_DRVR_CBLD_NO_CIRBUF,
+      .CH.ADICR.B.STAMP   = (uint32)SFTY_DMA_DRVR_STAMP_DISABLE,
+      .CH.ADICR.B.IRDV    = 0U,
+      .CH.ADICR.B.INTCT   = (uint32)SFTY_DMA_DRVR_INTCT_TRG_ON_IRDV_MATCH,
+      .CH.ADICR.B.SHCT    = (uint32)SFTY_DMA_DRVR_SHCT_NO_SHADOW,
+      .CH.SHADR.U         = (uint32)(SFTY_DMA_DRVR_SHADR_NOT_USED),
+      .TSR.B.ECH          = (uint32)SFTY_DMA_DRVR_ECH_ENABLE,
+      .SRC.U              = 0U,
+      .HRR.B.HRP          = (uint32)SFTY_DMA_DRVR_HWRES_PARTITION_0,
+   },
+
+   {/** SENT TIMEOUT STATUS */
+      .ChIndex            = SFTY_DMA_DRVR_CH_IDX_SENT_FAULTSTATUS,
+      .CH.SADR.U          = (uint32)(&SENT_CH9_SDS.U),
+//    .CH.DADR.U          = (uint32)(&(SftyDmaParkLockEvlnSENTStsInfoRx.data)),                /* TODO */
+      .CH.DADR.U          = (uint32)(&(LLSW_SftyDmaParkLockEvlnSENTStsInfoRx.data)),           /* TODO */
+      .CH.CHCFGR.B.PRSEL  = (uint32)SFTY_DMA_DRVR_PRSEL_DAISY_CHAIN,
+      .CH.CHCFGR.B.RROAT  = (uint32)SFTY_DMA_DRVR_RROAT_TRANSFER,
+      .CH.CHCFGR.B.TREL   = 1U,
+      .CH.CHCFGR.B.CHMODE = (uint32)SFTY_DMA_DRVR_CHMODE_CONTINUOUS_MODE,
+      .CH.CHCFGR.B.CHDW   = (uint32)SFTY_DMA_DRVR_CHDW_4BYTE,
+      .CH.CHCFGR.B.BLKM   = (uint32)SFTY_DMA_DRVR_BLKM_MOVE_1,
+      .CH.ADICR.B.SCBE    = (uint32)SFTY_DMA_DRVR_SCBE_ENABLE,
+      .CH.ADICR.B.DCBE    = (uint32)SFTY_DMA_DRVR_DCBE_ENABLE,
+      .CH.ADICR.B.SMF     = (uint32)SFTY_DMA_DRVR_SMF_BY_1DW,
+      .CH.ADICR.B.DMF     = (uint32)SFTY_DMA_DRVR_DMF_BY_1DW,
+      .CH.ADICR.B.INCS    = (uint32)SFTY_DMA_DRVR_INCS_INCREMENT,
+      .CH.ADICR.B.INCD    = (uint32)SFTY_DMA_DRVR_INCD_INCREMENT,
+      .CH.ADICR.B.CBLS    = (uint32)SFTY_DMA_DRVR_CBLS_NO_CIRBUF,
+      .CH.ADICR.B.CBLD    = (uint32)SFTY_DMA_DRVR_CBLD_NO_CIRBUF,
+      .CH.ADICR.B.STAMP   = (uint32)SFTY_DMA_DRVR_STAMP_DISABLE,
+      .CH.ADICR.B.IRDV    = 0U,
+      .CH.ADICR.B.INTCT   = (uint32)SFTY_DMA_DRVR_INTCT_TRG_ON_IRDV_MATCH,
+      .CH.ADICR.B.SHCT    = (uint32)SFTY_DMA_DRVR_SHCT_NO_SHADOW,
+      .CH.SHADR.U         = (uint32)(SFTY_DMA_DRVR_SHADR_NOT_USED),
+      .TSR.B.ECH          = (uint32)SFTY_DMA_DRVR_ECH_ENABLE,
+      .SRC.U              = 0U,
+      .HRR.B.HRP          = (uint32)SFTY_DMA_DRVR_HWRES_PARTITION_0,
+   },
+
+   {/** SENT TIMEOUT - DMA TIMESTAMP */
+      .ChIndex            = SFTY_DMA_DRVR_CH_IDX_SENT_FAULTSTATUS_DMATIMESTAMP,
+      .CH.SADR.U          = (uint32)(&DMA_TIME.U),
+//    .CH.DADR.U          = (uint32)(&(SftyDmaParkLockEvlnSENTStsInfoRx.tiStamp)),           /* TODO */
+      .CH.DADR.U          = (uint32)(&(LLSW_SftyDmaParkLockEvlnSENTStsInfoRx.tiStamp)),      /* TODO */
+      .CH.CHCFGR.B.PRSEL  = (uint32)SFTY_DMA_DRVR_PRSEL_HW_TRIGGER,
+      .CH.CHCFGR.B.RROAT  = (uint32)SFTY_DMA_DRVR_RROAT_TRANSFER,
+      .CH.CHCFGR.B.TREL   = 1U,
+      .CH.CHCFGR.B.CHMODE = (uint32)SFTY_DMA_DRVR_CHMODE_CONTINUOUS_MODE,
+      .CH.CHCFGR.B.CHDW   = (uint32)SFTY_DMA_DRVR_CHDW_4BYTE,
+      .CH.CHCFGR.B.BLKM   = (uint32)SFTY_DMA_DRVR_BLKM_MOVE_1,
+      .CH.ADICR.B.SCBE    = (uint32)SFTY_DMA_DRVR_SCBE_ENABLE,
+      .CH.ADICR.B.DCBE    = (uint32)SFTY_DMA_DRVR_DCBE_ENABLE,
+      .CH.ADICR.B.SMF     = (uint32)SFTY_DMA_DRVR_SMF_BY_1DW,
+      .CH.ADICR.B.DMF     = (uint32)SFTY_DMA_DRVR_DMF_BY_1DW,
+      .CH.ADICR.B.INCS    = (uint32)SFTY_DMA_DRVR_INCS_INCREMENT,
+      .CH.ADICR.B.INCD    = (uint32)SFTY_DMA_DRVR_INCD_INCREMENT,
+      .CH.ADICR.B.CBLS    = (uint32)SFTY_DMA_DRVR_CBLS_NO_CIRBUF,
+      .CH.ADICR.B.CBLD    = (uint32)SFTY_DMA_DRVR_CBLD_NO_CIRBUF,
+      .CH.ADICR.B.STAMP   = (uint32)SFTY_DMA_DRVR_STAMP_DISABLE,
+      .CH.ADICR.B.IRDV    = 0U,
+      .CH.ADICR.B.INTCT   = (uint32)SFTY_DMA_DRVR_INTCT_TRG_ON_IRDV_MATCH,
+      .CH.ADICR.B.SHCT    = (uint32)SFTY_DMA_DRVR_SHCT_NO_SHADOW,
+      .CH.SHADR.U         = (uint32)(SFTY_DMA_DRVR_SHADR_NOT_USED),
+      .TSR.B.ECH          = (uint32)SFTY_DMA_DRVR_ECH_ENABLE,
+      .SRC.U              = 0U,
+      .HRR.B.HRP          = (uint32)SFTY_DMA_DRVR_HWRES_PARTITION_0,
+   }
 
 };
 #define SFTY_DMA_DRVR_STOP_SEC_CONST_AREA_0
'
