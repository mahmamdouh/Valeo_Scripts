b'commit fe983712e994f5928157951f9f1b076ba87c9b29
Author: Michael HIERL (JV) <michael.hierl.jv@valeo.com>
Date:   Fri Nov 19 16:06:46 2021 +0100

    $100kW-45348$ - [SWT] B01: The A2.1 HIL cannot wake up after remove the XETK
    
    Change-Id: Ib4fe916e8fb03ea9fd09571e8f19a983e87b2626

diff --git a/src/fw_cu/Components/Cmn/MeasAndCal/Xetk/src/ETK_SER_Handshake_Common.c b/src/fw_cu/Components/Cmn/MeasAndCal/Xetk/src/ETK_SER_Handshake_Common.c
index e5e6254b8..285545115 100644
--- a/src/fw_cu/Components/Cmn/MeasAndCal/Xetk/src/ETK_SER_Handshake_Common.c
+++ b/src/fw_cu/Components/Cmn/MeasAndCal/Xetk/src/ETK_SER_Handshake_Common.c
@@ -151,7 +151,7 @@ uint8 SER_ETK_Detect(void)
   else // ETK Detection Pattern Protocol read failed (no ETK detected)
   {
 
-    Configure_EMEM_Tiles_For_ECU_RAM(); //  Sets the EMEM tiles that are used internally by the ECU as RAM to calibration/RAM mode.
+   //Configure_EMEM_Tiles_For_ECU_RAM(); //  Sets the EMEM tiles that are used internally by the ECU as RAM to calibration/RAM mode.
 
     /** Disable Distab 13/17 since Distab RAM areas should not be initialized by controller, and the areas might not be consistent. */
     SER_ETK_Disable_Distabs();
@@ -161,7 +161,7 @@ uint8 SER_ETK_Detect(void)
 
       /* Initialize the program memory and the EMEM memory with 0 initial values  for ECC.
       The EMEM memory has to be written entirely once before being accessible after a start. */
-      EMEM_RAM_ECC_Initialize();
+   //   EMEM_RAM_ECC_Initialize();
 
 
     #ifdef RS232_DEBUG_LOGGING
diff --git a/src/fw_cu/Components/Cmn/MeasAndCal/Xetk/src/ETK_SER_Handshake_IFX.c b/src/fw_cu/Components/Cmn/MeasAndCal/Xetk/src/ETK_SER_Handshake_IFX.c
index 5234bc172..1269678fa 100644
--- a/src/fw_cu/Components/Cmn/MeasAndCal/Xetk/src/ETK_SER_Handshake_IFX.c
+++ b/src/fw_cu/Components/Cmn/MeasAndCal/Xetk/src/ETK_SER_Handshake_IFX.c
@@ -106,7 +106,7 @@ const volatile uint32 Protocol_Detection_Wait_Time = 500000ul; // 5 ms wait time
 @@ GROUP = XETK
 @@ END
 */
-const volatile uint32 CRSYNC_Detection_Wait_Time = 1000000ul; // 10 ms waiting time for the CRSYNC bit detection until the ETK starts the handshake
+const volatile uint32 CRSYNC_Detection_Wait_Time = 50000ul; // 10 ms waiting time for the CRSYNC bit detection until the ETK starts the handshake
 
 #define STOP_SEC_CALIB_SLOW
 #include "Memmap.h"
@@ -587,16 +587,20 @@ void EMEM_RAM_ECC_Initialize(void)
     #error "Undefined cpu type in the EMEM_RAM_ECC_Initialize function !"
   #endif
 
+     /* If XETK powerfail detection is set to SBRAM, then coldstart-flag can be used to check reset-type */
+     /* Check the following line in the A2L: "CONFIG "PowerFailDetection" "SBRAM" " */
+     if (0 == ECU_ETK_Status.ETK_MC_Wait) /* zero if true PORST has happened */
+     {
   // EMEM_RAM non cached completely cleared for ECC
-  while (no_of_val_4 > 0)
-  {
-    *dst_ptr4++ = 0x0;
-    no_of_val_4--;
-  }
+        while (no_of_val_4 > 0)
+        {
+           *dst_ptr4++ = 0x0;
+            no_of_val_4--;
+         }
 
         isEMEMInitialized = TRUE;
         __isync();
-
+\t }
 \t #ifdef CPUCLASS_TC3XX
 
       /** !!! The test mode is disabled after the ECC initialization !!!*/
diff --git a/src/fw_cu/build/Parfiles/P2_100kW/Testbench/VW310E_76_49_A274_0028_VEH_200901.par b/src/fw_cu/build/Parfiles/P2_100kW/Testbench/VW310E_76_49_A274_0028_VEH_200901.par
index d2e0c60a5..42797a3e7 100644
--- a/src/fw_cu/build/Parfiles/P2_100kW/Testbench/VW310E_76_49_A274_0028_VEH_200901.par
+++ b/src/fw_cu/build/Parfiles/P2_100kW/Testbench/VW310E_76_49_A274_0028_VEH_200901.par
@@ -104,7 +104,7 @@ CAN_TI_OUT_Systeminfo_01_monitor_cycle_time [UINT(16)]  1100 ;  1100
 CAN_TI_OUT_VIN_01_monitor_cycle_time [UINT(16)]  220 ;  220
 CAN_TI_OUT_ZeitMaster_01_monitor_cycle_time [UINT(16)]  1100 ;  1100
 CAN_TI_OUT_eTM_01_monitor_cycle_time [UINT(16)]  550 ;  550
-CRSYNC_Detection_Wait_Time [UINT(32)]  1000000 ;  1000000
+CRSYNC_Detection_Wait_Time [UINT(32)]  50000 ;  50000
 Clm_CpuLoadCalibration_Core_0.Clm_CpuLoadThreshold [UINT(8)]  90 ;  90
 Clm_CpuLoadCalibration_Core_0.MeasurementEnabled [UINT(8)]  1 ;  1
 Clm_CpuLoadCalibration_Core_1.Clm_CpuLoadThreshold [UINT(8)]  90 ;  90
'
