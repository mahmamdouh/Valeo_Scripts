b'commit d3f31d4bb2388fe610ce6f8a860d7b4d1e13975d
Author: Fan SHI (JV) <fan.shi.jv@valeo.com>
Date:   Tue Nov 16 10:33:44 2021 +0800

    $100kW-45289$Update with A-SPICE LV2
    
    Change-Id: I6cf3936952f96e20c16f57fbfd204db59448bb51

diff --git a/src/fw_cu/Components/Cmn/Diagc/src/DcmExt.c b/src/fw_cu/Components/Cmn/Diagc/src/DcmExt.c
index dfc1397f7..ef3c28df1 100644
--- a/src/fw_cu/Components/Cmn/Diagc/src/DcmExt.c
+++ b/src/fw_cu/Components/Cmn/Diagc/src/DcmExt.c
@@ -129,12 +129,22 @@ uint8 DID_0410_BootloaderTPBlocksize;
 #include <DcmExt_MemMap.h>
 
 /* dcm_stub */
+
+/******************************************************************************
+ * \\brief Name:        Dcm_GetProgConditions
+ * \\work item ID:      100kW-38458
+ *****************************************************************************/
+
 FUNC(Dcm_EcuStartModeType, DCM_CODE) Dcm_GetProgConditions(P2VAR(Dcm_ProgConditionsType, AUTOMATIC, DCM_APPL_DATA)
                                                            ProgConditions)
 {
    return 0U;
 }
 
+/******************************************************************************
+ * \\brief Name:        Dcm_SetProgConditions
+ * \\work item ID:      100kW-38459
+ *****************************************************************************/
 FUNC(Std_ReturnType, DCM_CODE) Dcm_SetProgConditions(P2VAR
                                    (Dcm_ProgConditionsType, AUTOMATIC, DCM_APPL_DATA) ProgConditions) /* PRQA S 3673 */
                                    /* The generated code uses the same declaration. */
@@ -167,6 +177,10 @@ FUNC(Std_ReturnType, DCM_CODE) Dcm_SetProgConditions(P2VAR
   return E_OK;
 }
 
+/******************************************************************************
+ * \\brief Name:        DcmExt_SendPosRespWithoutRequest
+ * \\work item ID:      100kW-38460
+ *****************************************************************************/
 FUNC(void, DCM_CODE) DcmExt_SendPosRespWithoutRequest(uint8 sid)
 {
    PduIdType TxID = DEMEXT_CANIF_PDU_ISOx_EMotor_0x_Resp_FC;
@@ -243,6 +257,7 @@ FUNC(void, DCM_CODE) DcmExt_SendPosRespWithoutRequest(uint8 sid)
  *                     some kind of non-volatile memory.
  * \\param [in] SecurityLevel: Requested security level
  * \\return The number of failed attempts
+ * \\work item ID:      100kW-38461
  *****************************************************************************/
 FUNC(uint8, DCM_APPL_CODE) Rte_DcmSecGetNumAtt(Dcm_SecLevelType SecurityLevel)
 {
@@ -263,6 +278,7 @@ FUNC(uint8, DCM_APPL_CODE) Rte_DcmSecGetNumAtt(Dcm_SecLevelType SecurityLevel)
  *                     some kind of non-volatile memory.
  * \\param [in] SecurityLevel: Requested security level
  * \\param [in] NumAtt: Number of failed attempts
+ * \\work item ID:      100kW-38463
  *****************************************************************************/
 FUNC(void, DCM_APPL_CODE) Rte_DcmSecSetNumAtt(Dcm_SecLevelType SecurityLevel, uint8 NumAtt)
 {
@@ -278,6 +294,7 @@ FUNC(void, DCM_APPL_CODE) Rte_DcmSecSetNumAtt(Dcm_SecLevelType SecurityLevel, ui
  *                     set a no-init flag for running reset
  * \\param [in] SecurityLevel: Requested security level
  * \\param [in] NumAtt: Number of failed attempts
+ * \\work item ID:      100kW-38462
  *****************************************************************************/
 FUNC(void, DCM_APPL_CODE) DcmExt_PerformReset(void)
 {
@@ -302,6 +319,7 @@ FUNC(void, DCM_APPL_CODE) DcmExt_PerformReset(void)
  * \\brief Name:        DcmExt_F1F1_EcuReset
  * \
     Description: This function is called by F1F1 routine and
  *                     performs hard reset via SBC.
+ * \\work item ID:      100kW-38646
  *****************************************************************************/
 FUNC(void, DCM_APPL_CODE) DcmExt_F1F1_EcuReset(void)
 {
@@ -334,6 +352,7 @@ FUNC(void, DCM_APPL_CODE) DcmExt_F1F1_EcuReset(void)
  * \\return        boolean    Return the status rom address validity
  * \\retval        TRUE    rom address is valid
  * \\retval        FALSE   rom address is not valid
+ * \\work item ID  100kW-45096
  */
 /*****************************************************************************/
 boolean chkprg_is_valid_rom_addr(const uint8* ptr)
@@ -371,6 +390,7 @@ boolean chkprg_is_valid_rom_addr(const uint8* ptr)
  * \\return        boolean   Return the status
  * \\retval        TRUE      returns marker is set
  * \\retval        FALSE     returns marker is not set
+ * \\work item ID  100kW-45101
  */
 /*****************************************************************************/
 boolean chkprg_is_marker_set(const uint8* ptr, uint16 len, uint8 pattern)
@@ -406,6 +426,7 @@ boolean chkprg_is_marker_set(const uint8* ptr, uint16 len, uint8 pattern)
  * \\param  [in]  pAdminTable - Pointer to a valid admin-table
  * \\param  [out] pBlkId      - Block ID that identifies the logical Block
  * \\return TRUE - admin table is valid
+ * \\work item ID  100kW-45104 
  */
 /******************************************************************************/
 boolean chkprg_is_valid_admin_table(t_AdminTable* pAdminTable, uint8* pBlkId)
@@ -442,6 +463,7 @@ boolean chkprg_is_valid_admin_table(t_AdminTable* pAdminTable, uint8* pBlkId)
  * \
     Description: Reads SiemensBoot version from a fixed address
  * \\param [in]
  * \\param [out]
+ * \\work item ID:      100kW-45115
  *****************************************************************************/
 FUNC(Std_ReturnType, DCM_APPL_CODE) fw_ReadSiemensBootloaderVersion(void)
 {
@@ -497,6 +519,7 @@ FUNC(Std_ReturnType, DCM_APPL_CODE) fw_ReadSiemensBootloaderVersion(void)
  * \
     Description: Reads BootManager Version from its AdminTable
  * \\param [in]
  * \\param [out]
+ * \\work item ID:      100kW-45172
  *****************************************************************************/
 FUNC(Std_ReturnType, DCM_APPL_CODE) fw_ReadBootManagerVersion(void)
 {
@@ -534,6 +557,7 @@ FUNC(Std_ReturnType, DCM_APPL_CODE) fw_ReadBootManagerVersion(void)
  * \
     Description: Reads SecuSrv-Version from the AdminTable
  * \\param [in]
  * \\param [out]
+ * \\work item ID:      100kW-45173
  *****************************************************************************/
 FUNC(Std_ReturnType, DCM_APPL_CODE) fw_ReadHsmVersion(void)
 {
@@ -577,6 +601,7 @@ FUNC(Std_ReturnType, DCM_APPL_CODE) fw_ReadHsmVersion(void)
  * \\brief  Read Firmware versions of modules that cannot be flashed by CBL
  *         Call this function only once during start up!
  * \\return -
+ * \\work item ID 100kW-45175
  */
 /*****************************************************************************/
 FUNC(void, BL_CODE) Fw_ReadFirmwareVersions(void)
@@ -593,6 +618,7 @@ FUNC(void, BL_CODE) Fw_ReadFirmwareVersions(void)
  * \\param  [out] version - byte array with version information
  * \\return TRUE  - Version from module available
  *         FALSE - Module not available, get default
+ * \\work item ID   100kW-45176
  */
 /******************************************************************************/
 FUNC(boolean, BL_CODE) Fw_GetBootManagerVersion(uint8 *version)
@@ -615,6 +641,7 @@ FUNC(boolean, BL_CODE) Fw_GetBootManagerVersion(uint8 *version)
  * \\param  [out] version - byte array with version information
  * \\return TRUE  - Version from module available
  *         FALSE - Module not available, get default
+ * \\work item ID   100kW-45179
  */
 /******************************************************************************/
 FUNC(boolean, BL_CODE) Fw_GetSiemensBootloaderVersion(uint8 *version)
@@ -637,6 +664,7 @@ FUNC(boolean, BL_CODE) Fw_GetSiemensBootloaderVersion(uint8 *version)
  * \\param  [out] version - byte array with version information
  * \\return TRUE  - Version from module available
  *         FALSE - Module not available, get default
+ * \\work item ID   100kW-45180
  */
 /******************************************************************************/
 FUNC(boolean, BL_CODE) Fw_GetHsmVersion(uint8 *version)
diff --git a/src/fw_cu/Components/Cmn/Diagc/src/DidUtil.c b/src/fw_cu/Components/Cmn/Diagc/src/DidUtil.c
index 84e597546..66dcac50f 100644
--- a/src/fw_cu/Components/Cmn/Diagc/src/DidUtil.c
+++ b/src/fw_cu/Components/Cmn/Diagc/src/DidUtil.c
@@ -17,9 +17,9 @@
 #include "Mathlib.h"
 
 /*================== [macros] ===============================================*/
-#define PtrOffset_1l (1L)
-#define ShiftNumber (7U)
-#define DataBitLen_8u (8U)
+#define PTROFFSET_1L (1L)
+#define SHIFTNUMBER (7U)
+#define DATABITLEN_8U (8U)
 
 /*================== [type definitions] =====================================*/
 
@@ -38,6 +38,7 @@
  * \\param   [in]: uint8 ByteCount -> Number of bytes the element consist of
  * \\param   [out] none
  * \\return        none
+ * \\work item ID: 100kW-38691
  *****************************************************************************/
 #define DIDUTIL_START_SEC_CODE
 #include "MemMap.h"
@@ -45,15 +46,17 @@ void Util_SwapBytes(void* Bytes, uint8 ByteCount)
 {
    /* Temporary buffer for storing the bytes to be swapped */
    uint8 SwapBuffer_a[UTIL_SWAP_MAX_SIZE];
-   uint8 i = 0U;
+   uint8 ByteCountTemp = ByteCount;
+   void* BytesTemp = Bytes; 
+   uint8 i;
 
    /* Limiting the byte count to prevent over-indexing the buffer */
-   if (UTIL_SWAP_MAX_SIZE < ByteCount)
+   if (UTIL_SWAP_MAX_SIZE < ByteCountTemp)
    {
-      ByteCount = UTIL_SWAP_MAX_SIZE;
+      ByteCountTemp = UTIL_SWAP_MAX_SIZE;
    }
    /* Reading the input buffer forward */
-   for (i = 0U; i < ByteCount; i++)
+   for (i = 0U; i < ByteCountTemp; i++)
    {
       /* Msg(4:0316) [I] Cast from a pointer to void to a pointer to object type.
        * MISRA-C:2004 Rule 11.4; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics
@@ -64,18 +67,18 @@ void Util_SwapBytes(void* Bytes, uint8 ByteCount)
        * to prevent alignment exception errors as the passed pointer may not start on a suitable
        * alignment. By calling these functions, the user can evade pointer casts and pointer
        * arithmetic.*/
-      SwapBuffer_a[i] = *((uint8*)Bytes); /* PRQA S 0316 */
-      Util_move_void_ptr(&Bytes,1L);
+      SwapBuffer_a[i] = *((uint8*)BytesTemp); /* PRQA S 0316 */
+      Util_move_void_ptr(&BytesTemp,1L);
    }
-   Util_move_void_ptr(&Bytes,-1L);
+   Util_move_void_ptr(&BytesTemp,-1L);
    /* Writing the output buffer backward */
-   for (i = 0U; i < ByteCount; i++)
+   for (i = 0U; i < ByteCountTemp; i++)
    {
-      *((uint8*)Bytes) = SwapBuffer_a[i]; /* PRQA S 0316 */
-      Util_move_void_ptr(&Bytes,-1L);
+      *((uint8*)BytesTemp) = SwapBuffer_a[i]; /* PRQA S 0316 */
+      Util_move_void_ptr(&BytesTemp,-1L);
    }
    /* stepping the pointer to the end of the buffer to reset the original position */
-   Util_move_void_ptr(&Bytes,1L);
+   Util_move_void_ptr(&BytesTemp,1L);
 
    return;
 }
@@ -90,12 +93,13 @@ void Util_SwapBytes(void* Bytes, uint8 ByteCount)
  * \\param   [in] uint8 ElementSize_u8 -> Number of bytes in a single element
  * \\param   [out] none
  * \\return        none
+ * \\work item ID:  100kW-38692
  *****************************************************************************/
 #define DIDUTIL_START_SEC_CODE
 #include "MemMap.h"
 void Util_SwapArrElements(void* Array_a, uint32 ElementCount_u32, uint8 ElementSize_u8)
 {
-   uint32 i = 0U;
+   uint32 i;
    /* Pointer to the array (elements) */
 
    /* Msg(4:0316) [I] Cast from a pointer to void to a pointer to object type.
@@ -108,7 +112,7 @@ void Util_SwapArrElements(void* Array_a, uint32 ElementCount_u32, uint8 ElementS
    for(i = 0U; i < ElementCount_u32; i++)
    {
       /* Swap the bytes at the current element location */
-      Util_SwapBytes(Ptr, ElementSize_u8);
+      Util_SwapBytes(Ptr, ElementSize_u8); /* PRQA S 0315*/
       /* Moving the destination pointer to the next array element*/
       /* Pointer arithmetic is used here for moving the pointer on the elements of an array */
       /* Msg(4:0488) Performing pointer arithmetic.
@@ -131,6 +135,7 @@ void Util_SwapArrElements(void* Array_a, uint32 ElementCount_u32, uint8 ElementS
  * \\param   [in] sint32 Offset_s32 -> Offset to move the pointer with
  * \\param   [out] none
  * \\return        none
+ * \\work item ID:  100kW-38693
  *****************************************************************************/
 #define DIDUTIL_START_SEC_CODE
 #include "MemMap.h"
@@ -149,6 +154,7 @@ void Util_MovePtr( void* *Ptr_p, sint32 Offset_s32)
  * \\param   [in] const uint8* const Data_p -> Data which is to be inserted as new
  * \\param   [out] none
  * \\return        none
+ * \\work item ID:  100kW-38694
  *****************************************************************************/
 #define DIDUTIL_START_SEC_CODE
 #include "MemMap.h"
@@ -161,24 +167,24 @@ void Util_MovePtr( void* *Ptr_p, sint32 Offset_s32)
   uint8* SrcPtr_p = (uint8*)Data_p; /* PRQA S 0311 */
   uint8 SrcShiftCtr_u8 = 0U;
 
-  uint16 i_u16 = 0U;
-  uint16 j_u16 = 0U;
+  uint16 i_u16;
+  uint16 j_u16;
 
 
   /* Bit value saved from shifting out */
-  uint8 TempBitOut_u8 = 0U;
+  uint8 TempBitOut_u8;
   /* Bit to be put after shifting */
-  uint8 TempBitIn_u8 = 0U;
+  uint8 TempBitIn_u8;
 
   /* In case of multi-byte elements, place the source pointer to last byte,
    * to read the bytes in reverse order */
-  if (Buff_st->DataBitLen_u8 > DataBitLen_8u )
+  if (Buff_st->DataBitLen_u8 > DATABITLEN_8U )
   {
      /* Msg(4:0317) [I] Implicit conversion from a pointer to void to a pointer to object type.
       * MISRA-C:2004 Rule 11.4; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics
       * DEVIATION COMMENT: This function expects*/
      /* MISRA 4394: In this case the cast from uint to sint is intended. */
-     Util_MovePtr( (void*)(&SrcPtr_p), (sint32)((Buff_st->DataBitLen_u8 / DataBitLen_8u) - 1U) ); /* PRQA S 0317, 4394 */
+     Util_MovePtr( (void*)(&SrcPtr_p), (sint32)((Buff_st->DataBitLen_u8 / DATABITLEN_8U) - 1U) ); /* PRQA S 0317, 4394, 0314 */
   }
   else
   {
@@ -193,11 +199,11 @@ void Util_MovePtr( void* *Ptr_p, sint32 Offset_s32)
      TempBitIn_u8 = (uint8)(TempBitIn_u8 & (uint8)(1U << SrcShiftCtr_u8));
      /* Simplier to shift back and forth than calculate the necessary number of shifts */
      TempBitIn_u8 = (uint8)(TempBitIn_u8 >> SrcShiftCtr_u8);
-     TempBitIn_u8 = (uint8)(TempBitIn_u8 << ShiftNumber );
+     TempBitIn_u8 = (uint8)(TempBitIn_u8 << SHIFTNUMBER );
      /* One more shifts done */
      SrcShiftCtr_u8 = SrcShiftCtr_u8 + 1U;
      /* Have all bit in the current source byte shifted? */
-     if (0U == (SrcShiftCtr_u8 % DataBitLen_8u))
+     if (0U == (SrcShiftCtr_u8 % DATABITLEN_8U))
      {
         /* yes, reset the shift counter */
         SrcShiftCtr_u8 = 0U;
@@ -205,7 +211,7 @@ void Util_MovePtr( void* *Ptr_p, sint32 Offset_s32)
         /* Msg(4:0317) [I] Implicit conversion from a pointer to void to a pointer to object type.
          * MISRA-C:2004 Rule 11.4; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics
          * DEVIATION COMMENT: This function expects*/
-        Util_MovePtr( (void*)(&SrcPtr_p), -1L ); /* PRQA S 0317 */
+        Util_MovePtr( (void*)(&SrcPtr_p), -1L ); /* PRQA S 0317 , 0314 */
      }
 
      /* Perform single left shifts shifts byte-wise for all the bytes in the FIFO structure.
@@ -213,7 +219,7 @@ void Util_MovePtr( void* *Ptr_p, sint32 Offset_s32)
      for (i_u16 = 0U; i_u16 < Buff_st->FifoLen_u16; i_u16++ )
      {
         /* Get least significant bit of the current byte and shift the bit the top of the byte*/
-        TempBitOut_u8 = (uint8)(*DataPtr_p & 0x01U) << ShiftNumber;
+        TempBitOut_u8 = (uint8)(*DataPtr_p & 0x01U) << SHIFTNUMBER;
         /* Shift the current byte to the right */
         *DataPtr_p = (uint8)(*DataPtr_p >> 1U);
         /* Put the previously saved most significant bit into the byte */
@@ -224,7 +230,7 @@ void Util_MovePtr( void* *Ptr_p, sint32 Offset_s32)
         /* Msg(4:0317) [I] Implicit conversion from a pointer to void to a pointer to object type.
          * MISRA-C:2004 Rule 11.4; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics
          * DEVIATION COMMENT: This function expects */
-        Util_MovePtr( (void*)(&DataPtr_p), PtrOffset_1l ); /* PRQA S 0317 */
+        Util_MovePtr( (void*)(&DataPtr_p), PTROFFSET_1L ); /* PRQA S 0317 , 0314*/
      }
      /* Set the data pointer back to the start of the buffer */
      DataPtr_p = (uint8*)Buff_st->Buffer_p;
@@ -246,12 +252,13 @@ void Util_MovePtr( void* *Ptr_p, sint32 Offset_s32)
  * \\param   [in] (float32) factor    : factor.
  *
  * \\return  The float32 physical value
+ * \\work item ID:            100kW-38695
  *****************************************************************************/
 #define DIDUTIL_START_SEC_CODE
 #include "MemMap.h"
 FUNC(float32, DIDUTIL_CODE) Util_RawToPhysicalValue(uint32 uintval, float32 offset, float32 factor)
 {
-   float32 retval = (0.0F);
+   float32 retval;
    /* apply factor */
    retval         = MLIB_F32U32(uintval) * factor;
    /* apply offset */
@@ -272,12 +279,13 @@ FUNC(float32, DIDUTIL_CODE) Util_RawToPhysicalValue(uint32 uintval, float32 offs
  * \\param   [in] (float32) factor   : factor.
  *
  * \\return  The uint32 raw value
+ * \\work item ID:            100kW-38696  
  *****************************************************************************/
 #define DIDUTIL_START_SEC_CODE
 #include "MemMap.h"
 FUNC(uint32, DIDUTIL_CODE) Util_PhysicalToRawValue(float32 origVal, float32 offset, float32 factor)
 {
-   float32 retval = (0.0F);
+   float32 retval;
 
    /* apply offset */
    retval         = origVal - offset;
@@ -306,6 +314,7 @@ FUNC(uint32, DIDUTIL_CODE) Util_PhysicalToRawValue(float32 origVal, float32 offs
  *
  * \\return                 The function returns the limited value of the first parameter
  *
+ * \\work item ID:          100kW-38697
  *****************************************************************************/
 #define DIDUTIL_START_SEC_CODE
 #include "MemMap.h"
'
