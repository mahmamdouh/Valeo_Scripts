b'commit 974f3db3b1a78dc500f80fd61939e2e463a913af
Author: Murali-Krishna VEERAGANDHAM (JV) <murali-krishna.veeragandham.jv@valeo.com>
Date:   Tue Feb 8 19:10:03 2022 +0100

    $100kW-50950$ - B-Sample - MISC - VX1000 driver integration
    
    Change-Id: Iefa11aedf8b970b705fc38b873bddbc69947de7f

diff --git a/src/fw_cu/Components/Cmn/Initialize/CrtInit/src/init_task.c b/src/fw_cu/Components/Cmn/Initialize/CrtInit/src/init_task.c
index 85f44e944..882e22867 100644
--- a/src/fw_cu/Components/Cmn/Initialize/CrtInit/src/init_task.c
+++ b/src/fw_cu/Components/Cmn/Initialize/CrtInit/src/init_task.c
@@ -34,7 +34,8 @@
 #endif
 #include "Distab13.h"
 #include "LlswGtm_swtst.h"
-
+/* for VX1000 initilization */
+#include "VX1000If.h"
 /*==================[variables]==============================================*/
 #define BSW_START_SEC_VAR_SLOW_NOINIT
 #include "MemMap.h"
@@ -81,6 +82,10 @@ boolean isEMEMInitialized;
 
 TASK(Init_Task)
 {
+  VX1000If_Init();
+  VX1000If_InitAsyncStart();
+  VX1000If_InitAsyncEnd();
+  
   EcuM_StartupTwo();  /* Task "Init_Task" has to invoke function "EcuM_StartupTwo". */
 
   BswM_RequestMode(BSWM_BSWM_SM, BSWM_STARTUP_TWO_A);  /* Parameter 1 refers to BswM parameter
diff --git a/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/include/VX1000.h b/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/include/VX1000.h
new file mode 100644
index 000000000..ae812fc12
--- /dev/null
+++ b/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/include/VX1000.h
@@ -0,0 +1,3197 @@
+/*------------------------------------------------------------------------------- */
+/* VX1000.h                                                                       */
+/* Vector VX1000 Application Driver for Infineon Tricore with DAP1/2 or DigRf I/F */
+/* Release: 03_06                    Build: 596          Modification: 21.10.2017 */
+/* Vector Informatik GmbH                                                         */
+/*                                                                                */
+/* Don\'t modify this file, settings are defined in VX1000_cfg.h                   */
+/*------------------------------------------------------------------------------- */
+
+
+/* ----------------------------------------------------------------------------------------------------------------------- /
+/ Status of MISRA conformance:                                                                                             /
+/ ---------------------------                                                                                              /
+/  * advisory rule 12.11 "wraparound in const unsigned int computation"                                                    /
+/     - violated only in a preprocessor assertion (user-configuration-dependent)                                           /
+/                                                                                                                          /
+/  * required rule 16.1 "usage of variadic functions"                                                                      /
+/     - violated only if the user explicitly enables the debug print feature during development phase.                     /
+/     - see individual justifications of the particular violations in the code                                             /
+/                                                                                                                          /
+/  * required rule 19.4 "complete statement inside a macro"                                                                /
+/     - violated to allow the application to generically call the API without having to care whether a feature             /
+/       is currently disabled or enabled.                                                                                  /
+/     - see individual justifications of the particular violations in the code                                             /
+/                                                                                                                          /
+/  * advisory rule 19.7 "functions vs. macros"                                                                             /
+/     - violated because a MISRA-conform workaround would induce configuration-dependent MISRA violations in user\'s code   /
+/     - see individual justifications of the particular violations in the code                                             /
+/                                                                                                                          /
+/  * required rule 19.10 "macro parameter used without parentheses"                                                        /
+/     - todo ( hint: a dummy-"##" might serve as a workaround... )                                                         /
+/                                                                                                                          /
+/                                                                            (checked in PowerPC build 529)                /
+/                                                                                                                          /
+/------------------------------------------------------------------------------------------------------------------------ */
+
+
+#if !defined(VX1000_H)
+#define VX1000_H
+
+
+/*------------------------------------------------------------------------------ */
+/* Driver\'s version and status                                                   */
+
+#define VX1000_APPDRIVER_BUILDNUMBER   596UL
+#define VX1000_RELEASENAMEARRAY        \'0\',\'3\',\'_\',\'0\',\'6\',\' \',\' \',\' \',\' \',\' \',\' \',\' \'
+/* semantic versioning no longer used starting with release 3.0:
+/ #define VX1000_FILE_VERSION_STATUS     (VX1000_ALPHA)  /-* VX1000_RELEASED / VX1000_TESTED / VX1000_BETA / VX1000_ALPHA; a change does NOT force version increase *-/
+/ #define VX1000_FILE_VERSION_MAJOR      3U   /-* major version number (1..16); a change initially forces ALPHA status *-/
+/ #define VX1000_FILE_VERSION_MINOR      0U   /-* minor version number (0..99); a change initially forces BETA status  *-/
+/ #define VX1000_FILE_VERSION_PATCH      3U   /-* patch level (0..7); a change does NOT change VERSION_STATUS *-/
+/
+/ #define VX1000_FILE_VERSION ( ((((VX1000_FILE_VERSION_MAJOR) & 0xfU) << 12U) | (((VX1000_FILE_VERSION_MINOR) & 0x7fU) << 5U)) | (((VX1000_FILE_VERSION_STATUS) << 3U) | ((VX1000_FILE_VERSION_PATCH) & 0x7U)) )
+*/
+
+/*------------------------------------------------------------------------------ */
+/* data types                                                                    */
+
+#if defined(_C166)
+#define VX1000_TASKING_WRAPDEF_C166    _C166 /* map to the reserved name for MISRA checkers that do not like to see leading single underscores in user code */
+#elif defined(__C166__) && defined(__VERSION__)
+#define VX1000_TASKING_WRAPDEF_C166    __VERSION__ /* map to the reserved name for MISRA checkers that do not like to see surrounding underscores in user code */
+#else  /* !_C166 && !__C166__ */
+#define VX1000_TASKING_WRAPDEF_C166    0 /* create an impossible version as workaround for some MISRA check tools not allowing negative defined-check and optional value-comparision on same line */
+#endif /* !_C166 && !__C166__ */
+
+#if (defined(__GNUC__) || defined(__GNUG__)) && (!defined(__GNUC_PATCHLEVEL__)) /* is the GNU C or the GNU C++ toolchain compiling this source for XC2000? */
+/* GCC provides these memory models:
+   Small
+   Compact
+   Medium (special)
+   Large
+
+It allows to assign specific attributes like structure packing per object by appending e.g. "__attribute__ ((aligned (16), packed))".
+*/
+typedef unsigned long  VX1000_UINT32;  /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef unsigned short VX1000_UINT16;  /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef unsigned char  VX1000_UINT8;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed long    VX1000_INT32;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed short   VX1000_INT16;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed char    VX1000_INT8;    /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+
+
+#define VX1000_INNERSTRUCT_VOLATILE    volatile
+#define VX1000_STRUCTSTRUCT_VOLATILE   /* empty */
+#define VX1000_OUTERSTRUCT_VOLATILE    /* empty */
+
+#if defined(__MODEL_LARGE__)
+#define VX1000_DECL_PTR_DEFAULT             huge /* ? */
+#define VX1000_ADDRESS_TO_POINTER_DFLT(A, T)   ((T huge *)(T far *)(T huge *)(A)) /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parenthesis would cause compilation to fail */
+#define VX1000_POINTER_TO_ADDRESS_DFLT(P, T)   ((VX1000_UINT32)((T huge *)(P)))  /* this may complain about lost qualifiers - this cannot be avoided (an intermediate cast to non-pointer type would destroy the page bits) */
+#elif defined(__MODEL_SPECMED__)
+#define VX1000_DECL_PTR_DEFAULT             huge /* ? */
+#define VX1000_ADDRESS_TO_POINTER_DFLT(A, T)   ((T huge *)                                                                        \\
+({                                                                                                                             \\
+  __typeof__(A) TMP = (A);                                                                                                     \\
+  VX1000_UINT16 PAGE = TMP >> 14;                                                                                              \\
+  VX1000_UINT16 OFS  = TMP & 0x3FFFU;                                                                                          \\
+  if      (PAGE == ({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E00\
":"=&r"(DPP)); DPP;})) /* already OK */; \\
+  else if (PAGE == ({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E02\
":"=&r"(DPP)); DPP;})) OFS |= 1<<14;     \\
+  else if (PAGE == ({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E04\
":"=&r"(DPP)); DPP;})) OFS |= 2<<14;     \\
+  else if (PAGE == ({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E06\
":"=&r"(DPP)); DPP;})) OFS |= 3<<14;     \\
+  else { OFS = 0; /* not representable --> create a null pointer */ VX1000_ERRLOGGER(VX1000_ERRLOG_PTR_NONREPSTBL) }           \\
+  ((T *)OFS;                                                                                                                   \\
+})) /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parenthesis would cause compilation to fail */
+#define VX1000_POINTER_TO_ADDRESS_DFLT(P, T)   ((VX1000_UINT32)((T huge*)(P)))  /* this may complain about lost qualifiers - this cannot be avoided (an intermediate cast to non-pointer type would destroy the page bits) */
+#elif defined(__MODEL_COMPACT__)
+#define VX1000_DECL_PTR_DEFAULT        /* empty (?) */
+#define VX1000_ADDRESS_TO_POINTER_DFLT(A, T)   ((T *)                                                                               \\
+({                                                                                                                             \\
+  __typeof__(A) TMP = (A);                                                                                                     \\
+  VX1000_UINT16 PAGE = TMP >> 14;                                                                                              \\
+  VX1000_UINT16 OFS  = TMP & 0x3FFFU;                                                                                          \\
+  if      (PAGE == ({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E00\
":"=&r"(DPP)); DPP;})) /* already OK */; \\
+  else if (PAGE == ({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E02\
":"=&r"(DPP)); DPP;})) OFS |= 1<<14;     \\
+  else if (PAGE == ({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E04\
":"=&r"(DPP)); DPP;})) OFS |= 2<<14;     \\
+  else if (PAGE == ({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E06\
":"=&r"(DPP)); DPP;})) OFS |= 3<<14;     \\
+  else { OFS = 0; /* not representable --> create a null pointer */  VX1000_ERRLOGGER(VX1000_ERRLOG_PTR_NONREPSTBL) }          \\
+  (VX1000_UINT16 *)OFS;                                                                                                        \\
+})) /* Willingly violating MISRA rule 19.10 because extra parenthesis would cause compilation to fail */
+#define VX1000_POINTER_TO_ADDRESS_DFLT(P, T)                                                                                                                                             \\
+({                                                                                                                                                                               \\
+  VX1000_UINT32 TMP = (VX1000_UINT32)(P);                                                                                                                                        \\
+  switch (((VX1000_UINT16)(TMP)) >> 14U)                                                                                                                                         \\
+  {                                                                                                                                                                              \\
+    case 0U: TMP = (((VX1000_UINT32)({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E00\
":"=&r"(DPP)); DPP;})) << 14U) | (VX1000_UINT32)((TMP) & 0x3FFFU); break; \\
+    case 1U: TMP = (((VX1000_UINT32)({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E02\
":"=&r"(DPP)); DPP;})) << 14U) | (VX1000_UINT32)((TMP) & 0x3FFFU); break; \\
+    case 2U: TMP = (((VX1000_UINT32)({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E04\
":"=&r"(DPP)); DPP;})) << 14U) | (VX1000_UINT32)((TMP) & 0x3FFFU); break; \\
+    case 3U: TMP = (((VX1000_UINT32)({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E06\
":"=&r"(DPP)); DPP;})) << 14U) | (VX1000_UINT32)((TMP) & 0x3FFFU); break; \\
+  }                                                                                                                                                                              \\
+  TMP;                                                                                                                                                                           \\
+})
+#else /* small */
+#define VX1000_DECL_PTR_DEFAULT        /* empty */
+#define VX1000_ADDRESS_TO_POINTER_DFLT(A, T)   ((T *)                                                                               \\
+({                                                                                                                             \\
+  __typeof__(A) TMP = (A);                                                                                                     \\
+  VX1000_UINT16 PAGE = TMP >> 14;                                                                                              \\
+  VX1000_UINT16 OFS  = TMP & 0x3FFFU;                                                                                          \\
+  if      (PAGE == ({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E00\
":"=&r"(DPP)); DPP;})) /* already OK */; \\
+  else if (PAGE == ({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E02\
":"=&r"(DPP)); DPP;})) OFS |= 1<<14;     \\
+  else if (PAGE == ({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E04\
":"=&r"(DPP)); DPP;})) OFS |= 2<<14;     \\
+  else if (PAGE == ({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E06\
":"=&r"(DPP)); DPP;})) OFS |= 3<<14;     \\
+  else { OFS = 0; /* not representable --> create a null pointer */ VX1000_ERRLOGGER(VX1000_ERRLOG_PTR_NONREPSTBL) }           \\
+  (T *) OFS;                                                                                                                   \\
+})) /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parenthesis would cause compilation to fail */
+#define VX1000_POINTER_TO_ADDRESS_DFLT(P, T)                                                                                                                                             \\
+({                                                                                                                                                                               \\
+  VX1000_UINT32 TMP = (VX1000_UINT32)(P);                                                                                                                                        \\
+  switch (((VX1000_UINT16)(TMP)) >> 14U)                                                                                                                                         \\
+  {                                                                                                                                                                              \\
+    case 0U: TMP = (((VX1000_UINT32)({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E00\
":"=&r"(DPP)); DPP;})) << 14U) | (VX1000_UINT32)((TMP) & 0x3FFFU); break; \\
+    case 1U: TMP = (((VX1000_UINT32)({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E02\
":"=&r"(DPP)); DPP;})) << 14U) | (VX1000_UINT32)((TMP) & 0x3FFFU); break; \\
+    case 2U: TMP = (((VX1000_UINT32)({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E04\
":"=&r"(DPP)); DPP;})) << 14U) | (VX1000_UINT32)((TMP) & 0x3FFFU); break; \\
+    case 3U: TMP = (((VX1000_UINT32)({VX1000_UINT16 DPP; __asm__ volatile ("extp #3,#1\
mov %0,0x3E06\
":"=&r"(DPP)); DPP;})) << 14U) | (VX1000_UINT32)((TMP) & 0x3FFFU); break; \\
+  }                                                                                                                                                                              \\
+  TMP;                                                                                                                                                                           \\
+})
+#endif /* small or compact */
+#define VX1000_OBJAT /* __attribute__((aligned(ADDR))) -- empty: GCC does not support this tasking-proprietary language extension. Macro\'s semantic must be changed --> pass address as parameter! */
+
+
+#elif (defined(_C166) && (((VX1000_TASKING_WRAPDEF_C166) >= 60) && ((VX1000_TASKING_WRAPDEF_C166) <= 100))) /* is it a valid tasking_classic compiler version for XC2000? */
+/*
+Tasking classic offers these pointer classes to c programmers:
+   _xnear       --> 14-bit-arithmetic inside DPP1 page (DPP1 must point to the page that contains the stack)
+   _near        --> 14-bit-arithmetic inside DPP2/DPP0 page (DPP2/DPP0 defined freely at link stage for data/const)
+   _system      --> 14-bit-arithmetic inside DPP3 page with DPP3 being fixed to the CPU-SFR page
+   _far         --> 14-bit-arithmetic inside a page addressed by bits 16..25. (note: far function pointers handled differently!)
+   _shuge       --> 16-bit-arithmetic inside any segment (the compiler generates code to push-modify-use-pop a DPP of its choice)
+   _huge        --> 24-bit-arithmetic also across page/segment boundaries (the compiler generates EXTS-prefixes for each access)
+   _iram        --> same as _system, just that object size is further limited
+   _bita        --> same as _iram, just that object types are further limited
+
+Whether a class is actually available depends on the "-m XXX" command line switch that selects one of these memory models:
+   tiny         --> forbids usage of _xnear, _far, _shuge, _huge; implies _near for everything; DPPx fixed for "linear-like" addresses
+   small        --> implies _near for const and data and _huge for text
+   medium       --> implies _near for text
+   large        --> implies _far for const and data and _huge for text
+   huge         --> implies _huge for everything
+
+The compiler provides an intrinsic define called "_MODEL" so an application can choose the right pointer class e.g. for "\'t\'".
+*/
+typedef unsigned long  VX1000_UINT32;  /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef unsigned short VX1000_UINT16;  /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef unsigned char  VX1000_UINT8;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed long    VX1000_INT32;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed short   VX1000_INT16;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed char    VX1000_INT8;    /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+
+#if (_MODEL == \'t\')                    /* 16bit linear addressing, pointers are _always_ 2 bytes */
+#define VX1000_DECL_PTR_DEFAULT        _near
+#define VX1000_ADDRESS_TO_POINTER_DFLT(A, T)   ((T _near *)(A)) /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parenthesis would cause compilation to fail */
+#define VX1000_POINTER_TO_ADDRESS_DFLT(P, T)   ((VX1000_UINT32)(P))
+#else /* _MODEL != \'t\' */              /* potentially weird addressing, force pointers to use 24bit linear addressing, stored in 4 bytes */
+#define VX1000_DECL_PTR_DEFAULT _huge
+#define VX1000_ADDRESS_TO_POINTER_DFLT(A, T)   ((T _huge *)(A)) /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parenthesis would cause compilation to fail */
+#define VX1000_POINTER_TO_ADDRESS_DFLT(P, T)   ((VX1000_UINT32)(P))
+#endif /* _MODEL != \'t\' */
+#define VX1000_OBJAT                   _at
+
+
+#elif defined (__C166__)               /* is it any other XC2000 tool chain? */
+
+#if (defined(__VERSION__) && (((VX1000_TASKING_WRAPDEF_C166) >= 1000) && ((VX1000_TASKING_WRAPDEF_C166) <= 5000))) /* is it a valid tasking_VX compiler version? */
+
+/*
+Tasking VX offers these pointer classes to c programmers:
+   __near       --> 16-bit-arithmetic using virtual 64K address space (fix DPPx then freely map the result to physical 16M address space)
+   __far        --> 14-bit-arithmetic inside a page addressed by bits 16..25 (the compiler generates EXTP-prefixes for each access)
+   __shuge      --> 16-bit-arithmetic inside any segment (the compiler generates EXTS-prefixes for each access)
+   __huge       --> 24-bit-arithmetic also across page/segment boundaries
+   __iram       --> same as __near, just that address range is further limited
+   __bita       --> same as __iram, just that object types are further limited
+   __bit        --> same as __iram, just that object types are further limited and using only 12-bit pointer-arithmetic
+
+The default pointer class for const and data depends on the "--model=XXX" command line switch that selects one of these memory models:
+   near         --> implies __near (attention with the __CONTIGUOUS_NEAR trick: depending on the DPPx initialisation, results of near versus non-near pointer arithmetic may differ!)
+   far          --> implies __far
+   shuge        --> implies __shuge
+   huge         --> implies __huge
+
+Note that the "--near-threshold=xxx" command line switch may overrule the default for specific (small) objects.
+The default pointer class for functions is always __huge unless overridden to __near via the "--near-functions" command line switch.
+
+The compiler provides an intrinsic define called "__MODEL__" so an application can choose the right pointer class e.g. for "\'h\'".
+*/
+typedef unsigned long  VX1000_UINT32;  /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef unsigned short VX1000_UINT16;  /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef unsigned char  VX1000_UINT8;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed long    VX1000_INT32;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed short   VX1000_INT16;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed char    VX1000_INT8;    /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+
+#define VX1000_DECL_PTR_DEFAULT             __huge
+#define VX1000_ADDRESS_TO_POINTER_DFLT(A, T) ((T __huge *)(A)) /* Willingly violating MISRA rule 19.10 because extra parenthesis would cause compilation to fail */
+#define VX1000_POINTER_TO_ADDRESS_DFLT(P, T) ((VX1000_UINT32)(P))
+#define VX1000_OBJAT                        __at
+#define VX1000_INNERSTRUCT_VOLATILE         volatile
+#define VX1000_STRUCTSTRUCT_VOLATILE        /* empty */
+#define VX1000_OUTERSTRUCT_VOLATILE         /* empty */
+
+#elif (__C166__ != 1)                  /* _seems_ to be a Keil compiler (?) -- completely untested! */
+
+/* KEIL provides these memory models:
+   Tiny
+   Small
+   Compact
+   Hcompact
+   Medium
+   Large
+   Hlarge
+
+It supports the "#pragma pack" and the "#pragma bytealign" switches to change structure member padding, but probably default packing is OK for our uint16s.
+*/
+typedef unsigned long  VX1000_UINT32;  /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef unsigned short VX1000_UINT16;  /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef unsigned char  VX1000_UINT8;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed long    VX1000_INT32;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed short   VX1000_INT16;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed char    VX1000_INT8;    /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+
+#define VX1000_DECL_PTR_DEFAULT             xhuge /* might need a 2nd define that is used everywhere IN FRONT of the type (?) */
+#define VX1000_ADDRESS_TO_POINTER_DFLT(A, T) ((T xhuge *)(A))  /* might be ((xhuge VX1000_UINT8 *)(p)) instead? */ /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parenthesis would cause compilation to fail */
+#define VX1000_POINTER_TO_ADDRESS_DFLT(P, T) ((VX1000_UINT32)(P))
+#define VX1000_OBJAT                        /* empty: keil does not support this tasking-proprietary language extension. Standard section method must be used! */
+#define VX1000_INNERSTRUCT_VOLATILE         volatile
+#define VX1000_STRUCTSTRUCT_VOLATILE        /* empty */
+#define VX1000_OUTERSTRUCT_VOLATILE         /* empty */
+
+#else  /* !TaskingVX & !Keil */
+typedef unsigned long  VX1000_UINT32;  /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef unsigned short VX1000_UINT16;  /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef unsigned char  VX1000_UINT8;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed long    VX1000_INT32;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed short   VX1000_INT16;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed char    VX1000_INT8;    /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+#define VX1000_OBJAT                   /* empty: user shall use the pragmas offered by his unsupported compiler! */
+
+#endif /* !TaskingVX & !Keil */
+
+#else /* !<C166/C167/XC164/XC2000/XE166 compiler> */
+
+/* The user header must be able to provide callback prototypes with VX data types, therefore the types must be located before the header include */
+typedef unsigned long  VX1000_UINT32;  /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef unsigned short VX1000_UINT16;  /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef unsigned char  VX1000_UINT8;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed long    VX1000_INT32;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed short   VX1000_INT16;   /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef signed char    VX1000_INT8;    /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+
+#if !defined(VX1000_DECL_PTR_DEFAULT)
+#define VX1000_DECL_PTR_DEFAULT             /* empty */
+#endif /* !VX1000_DECL_PTR_DEFAULT */
+#if !defined(VX1000_ADDRESS_TO_POINTER_DFLT)
+#define VX1000_ADDRESS_TO_POINTER_DFLT(A, T) ((/*NO parentheses here!*/T *)(A)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */ /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parenthesis would cause compilation to fail */
+#endif /* !VX1000_ADDRESS_TO_POINTER_DFLT */
+#if !defined(VX1000_POINTER_TO_ADDRESS_DFLT)
+#define VX1000_POINTER_TO_ADDRESS_DFLT(P, T) ((VX1000_UINT32)(P)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_POINTER_TO_ADDRESS_DFLT */
+#define VX1000_INNERSTRUCT_VOLATILE         /* empty */
+#define VX1000_STRUCTSTRUCT_VOLATILE        /* empty */
+#define VX1000_OUTERSTRUCT_VOLATILE         volatile
+
+#endif /* !<C166/C167/XC164/XC2000/XE166 compiler> */
+
+typedef int            VX1000_INT;     /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef long           VX1000_LONG;    /* needed for "sizeof" expression */ /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef char           VX1000_CHAR;    /* used by strings, __date etc.; compile options may specify whether signed or not */ /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef float          VX1000_FLOAT;   /* needed for "sizeof" expression */ /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef double         VX1000_DOUBLE;  /* needed for "sizeof" expression */ /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef long double    VX1000_LDOUBL;  /* needed for "sizeof" expression */ /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef void (*VX1000_VVFUNCP_T)(void);                                     /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef VX1000_UINT32  /* codeSize in DWords */ (VX1000_VUFUNC_T)(VX1000_UINT32 Addr/*DAQ: dstAddr / STIM: srcAddr*/ , VX1000_UINT32 t0, VX1000_UINT32 evSync); /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef VX1000_VUFUNC_T * VX1000_VUFUNCP_T;
+
+
+/*------------------------------------------------------------------------------ */
+/* constants                                                                     */
+#define VX1000_RELEASED                0x0U
+#define VX1000_TESTED                  0x1U
+#define VX1000_BETA                    0x2U
+#define VX1000_ALPHA                   0x3U
+
+
+/*------------------------------------------------------------------------------ */
+/* Configuration                                                                 */
+
+/* Include user specified defines and fetch prototypes of user callbacks (has to be done before switching sections) */
+#include "VX1000_cfg.h"  /* PRQA S 0883 */ /* Willingly violating MISRA rule 19.15: this file is included multiple times because it contains multiple disjunct parts that each are filtered exactly once by preprocessor conditions */ /* PRQA S 5087*/ /* Willingly violating MISRA rule 19.1: this file is included multiple at exactly those lines where it is needed to expand to the desired lines. Inclusion/expansion of those lines at the top of this file would not make sense and lead to compile errors */
+
+#if defined(VX1000_TARGET_X850)
+#elif defined(VX1000_TARGET_POWERPC)
+#elif defined(VX1000_TARGET_SH2)
+#elif defined(VX1000_TARGET_TMS570)
+#elif defined(VX1000_TARGET_TRICORE)
+#elif defined(VX1000_TARGET_XC2000)
+#else /* !VX1000_TARGET_<target> */
+#define VX1000IF_CFG_NO_TARGET
+#endif /* !VX1000_TARGET_<target> */
+#if defined(VX1000IF_CFG_NO_TARGET)
+#error You must define the appropriate VX1000_TARGET_<target> in VX1000_cfg.h!
+#endif /* !VX1000IF_CFG_NO_TARGET */
+
+#if !defined(VX1000_DISABLE_INSTRUMENTATION)
+#if defined(VX1000_TARGET_XC2000) || (defined(VX1000_TARGET_X850) /* || defined(VX1000_TARGET_TRICORE) */)
+/* no 64bit integer data type known on XC2000/V850 ... must live without it (and indeed we can) */
+#else  /* !VX1000_TARGET_XC2000 & !VX1000_TARGET_X850 & !VX1000_TARGET_TRICORE */
+
+/* As 64bit is no standard data type, it normally comes from the user. Therefore the default definition must be placed after the include of the user header: */
+#if !defined(VX1000_UINT64)
+#define VX1000_UINT64 VX1000_UINT64_T
+typedef long unsigned long  VX1000_UINT64_T; /* note: \'long long\' is a language extension that is not allowed by MISRA */ /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+#endif /* !VX1000_UINT64 */
+#endif /* !VX1000_DISABLE_INSTRUMENTATION */
+
+#endif /* !VX1000_TARGET_XC2000 & !VX1000_TARGET_X850 & !VX1000_TARGET_TRICORE */
+
+#if ((!defined(VX1000_DECL_PTR_DEFAULT)) && (!defined(VX1000_DECL_PTR))) || (((!defined(VX1000_ADDRESS_TO_POINTER_DFLT)) && (!defined(VX1000_ADDRESS_TO_POINTER))) || ((!defined(VX1000_POINTER_TO_ADDRESS_DFLT)) && (!defined(VX1000_POINTER_TO_ADDRESS))))
+#error Unsupported compiler; please provide the macros VX1000_DECL_PTR, VX1000_ADDRESS_TO_POINTER and VX1000_POINTER_TO_ADDRESS!
+#endif /* !VX1000_DECL_PTR_DEFAULT | !VX1000_ADDRESS_TO_POINTER | !VX1000_POINTER_TO_ADDRESS */
+
+#if (!defined(VX1000_INNERSTRUCT_VOLATILE)) || ((!defined(VX1000_STRUCTSTRUCT_VOLATILE)) || (!defined(VX1000_OUTERSTRUCT_VOLATILE)))
+#error Unsupported compiler; please provide the macros VX1000_INNERSTRUCT_VOLATILE, VX1000_STRUCTSTRUCT_VOLATILE and VX1000_OUTERSTRUCT_VOLATILE!
+#endif /* !VX1000_INNERSTRUCT_VOLATILE | !VX1000_STRUCTSTRUCT_VOLATILE | !VX1000_OUTERSTRUCT_VOLATILE */
+
+
+#if !defined(VX1000_DECL_PTR)
+#define VX1000_DECL_PTR                VX1000_DECL_PTR_DEFAULT
+#endif /* !VX1000_DECL_PTR */
+#if !defined(VX1000_ADDRESS_TO_POINTER)
+#define VX1000_ADDRESS_TO_POINTER(A, T)    (VX1000_ADDRESS_TO_POINTER_DFLT((A), /*NO parentheses here!*/T)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */ /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parenthesis would cause compilation to fail */
+#endif /* !VX1000_ADDRESS_TO_POINTER */
+#if !defined(VX1000_POINTER_TO_ADDRESS)
+#define VX1000_POINTER_TO_ADDRESS(P, T)    (VX1000_POINTER_TO_ADDRESS_DFLT((P), /*NO parentheses here!*/T)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */ /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parenthesis would cause compilation to fail */
+#endif /* !VX1000_POINTER_TO_ADDRESS */
+
+
+
+#if !defined(VX1000_ADDR_TO_PTR2U16)
+#define VX1000_ADDR_TO_PTR2U16(A)      VX1000_ADDRESS_TO_POINTER((A), VX1000_UINT16)                  /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2U16 */
+#if !defined(VX1000_ADDR_TO_PTR2VMC)
+#define VX1000_ADDR_TO_PTR2VMC(A)      VX1000_ADDRESS_TO_POINTER((A), volatile VX1000_MEMSYNC_CPY_T)  /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VMC */
+#if !defined(VX1000_ADDR_TO_PTR2VU32)
+#define VX1000_ADDR_TO_PTR2VU32(A)     VX1000_ADDRESS_TO_POINTER((A), volatile VX1000_UINT32)         /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VU32 */
+#if !defined(VX1000_ADDR_TO_PTR2VU16)
+#define VX1000_ADDR_TO_PTR2VU16(A)     VX1000_ADDRESS_TO_POINTER((A), volatile VX1000_UINT16)         /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VU16 */
+#if !defined(VX1000_ADDR_TO_PTR2VF)
+#define VX1000_ADDR_TO_PTR2VF(A)       VX1000_ADDRESS_TO_POINTER((A), volatile VX1000_FLOAT)          /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VF */
+#if !defined(VX1000_ADDR_TO_PTR2VD)
+#define VX1000_ADDR_TO_PTR2VD(A)       VX1000_ADDRESS_TO_POINTER((A), volatile VX1000_DOUBLE)         /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VD */
+#if !defined(VX1000_ADDR_TO_PTR2VMT)
+#define VX1000_ADDR_TO_PTR2VMT(A)      VX1000_ADDRESS_TO_POINTER((A), volatile VX1000_MEMSYNC_TRIG_T) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VMT */
+#if !defined(VX1000_ADDR_TO_PTR2VU8)
+#define VX1000_ADDR_TO_PTR2VU8(A)      VX1000_ADDRESS_TO_POINTER((A), volatile VX1000_UINT8)          /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VU8 */
+#if !defined(VX1000_ADDR_TO_PTR2U8)
+#define VX1000_ADDR_TO_PTR2U8(A)       VX1000_ADDRESS_TO_POINTER((A), VX1000_UINT8)                   /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2U8 */
+#if !defined(VX1000_ADDR_TO_PTR2EH)
+#define VX1000_ADDR_TO_PTR2EH(A)       VX1000_ADDRESS_TO_POINTER((A), VX1000_EMEM_HDR_T)              /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2EH */
+#if !defined(VX1000_ADDR_TO_PTR2FW)
+#define VX1000_ADDR_TO_PTR2FW(A)       VX1000_ADDRESS_TO_POINTER((A), VX1000_FKL_WORKSPACE_T)         /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2FW */
+#if !defined(VX1000_ADDR_TO_PTR2VU64)
+#define VX1000_ADDR_TO_PTR2VU64(A)     VX1000_ADDRESS_TO_POINTER((A), volatile VX1000_UINT64)         /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VU64 */
+#if !defined(VX1000_ADDR_TO_PTR2U32)
+#define VX1000_ADDR_TO_PTR2U32(A)      VX1000_ADDRESS_TO_POINTER((A), VX1000_UINT32)                  /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2U32 */
+#if !defined(VX1000_ADDR_TO_PTR2OE)
+#define VX1000_ADDR_TO_PTR2OE(A)       VX1000_ADDRESS_TO_POINTER((A), VX1000_OLDA_EVENT_T)            /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2OE */
+#if !defined(VX1000_ADDR_TO_PTR2V)
+#define VX1000_ADDR_TO_PTR2V(A)        VX1000_ADDRESS_TO_POINTER((A), void)                           /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2V */
+#if !defined(VX1000_ADDR_TO_PTR2VV)
+#define VX1000_ADDR_TO_PTR2VV(A)       VX1000_ADDRESS_TO_POINTER((A), volatile void)                  /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VV */
+#if !defined(VX1000_ADDR_TO_PTR2VCC)
+#define VX1000_ADDR_TO_PTR2VCC(A)      VX1000_ADDRESS_TO_POINTER((A), volatile const VX1000_CHAR)     /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VCC */
+#if !defined(VX1000_ADDR_TO_PTR2VC)
+#define VX1000_ADDR_TO_PTR2VC(A)       VX1000_ADDRESS_TO_POINTER((A), volatile VX1000_CHAR)           /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VC */
+#if !defined(VX1000_ADDR_TO_PTR2VCU32)
+#define VX1000_ADDR_TO_PTR2VCU32(A)    VX1000_ADDRESS_TO_POINTER((A), volatile const VX1000_UINT32)   /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VCU32 */
+#if !defined(VX1000_ADDR_TO_PTR2OCR)
+#define VX1000_ADDR_TO_PTR2OCR(A)      VX1000_ADDRESS_TO_POINTER((A), VX1000_OVL_CONFIG_REGS_T)       /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2OCR */
+#if !defined(VX1000_ADDR_TO_PTR2VTE)
+#define VX1000_ADDR_TO_PTR2VTE(A)      VX1000_ADDRESS_TO_POINTER((A), VX1000_HBB_VX_TABLE_ENTRY_T)    /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2VTE */
+#if !defined(VX1000_ADDR_TO_PTR2OCB)
+#define VX1000_ADDR_TO_PTR2OCB(A)      VX1000_ADDRESS_TO_POINTER((A), VX1000_VUFUNC_T)                /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2OCB */
+#if !defined(VX1000_PTR2VU16_TO_ADDRESS)
+#define VX1000_PTR2VU16_TO_ADDRESS(P)  VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_UINT16)         /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VU16_TO_ADDRESS */
+#if !defined(VX1000_PTR2VU32_TO_ADDRESS)
+#define VX1000_PTR2VU32_TO_ADDRESS(P)  VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_UINT32)         /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VU32_TO_ADDRESS */
+#if !defined(VX1000_PTR2VU64_TO_ADDRESS)
+#define VX1000_PTR2VU64_TO_ADDRESS(P)  VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_UINT64)         /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VU64_TO_ADDRESS */
+#if !defined(VX1000_PTR2VF_TO_ADDRESS)
+#define VX1000_PTR2VF_TO_ADDRESS(P)    VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_FLOAT)          /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VF_TO_ADDRESS */
+#if !defined(VX1000_PTR2VD_TO_ADDRESS)
+#define VX1000_PTR2VD_TO_ADDRESS(P)    VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_DOUBLE)         /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VD_TO_ADDRESS */
+#if !defined(VX1000_PTR2VUWS_TO_ADDRESS)
+#define VX1000_PTR2VUWS_TO_ADDRESS(P)  VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_UINTWS)         /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VUWS_TO_ADDRESS */
+#if !defined(VX1000_PTR2VVX_TO_ADDRESS)
+#define VX1000_PTR2VVX_TO_ADDRESS(P)   VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_STRUCT_T)       /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VVX_TO_ADDRESS */
+#if !defined(VX1000_PTR2VU8_TO_ADDRESS)
+#define VX1000_PTR2VU8_TO_ADDRESS(P)   VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_UINT8)          /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VU8_TO_ADDRESS */
+#if !defined(VX1000_PTR2SPS_TO_ADDRESS)
+#define VX1000_PTR2SPS_TO_ADDRESS(P)   VX1000_POINTER_TO_ADDRESS((P), VX1000_SYNCAL_PAGE_SWITCH_T)    /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2SPS_TO_ADDRESS */
+#if !defined(VX1000_PTR2OCR_TO_ADDRESS)
+#define VX1000_PTR2OCR_TO_ADDRESS(P)   VX1000_POINTER_TO_ADDRESS((P), VX1000_OVL_CONFIG_REGS_T)       /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2OCR_TO_ADDRESS */
+#if !defined(VX1000_PTR2VFF_TO_ADDRESS)
+#define VX1000_PTR2VFF_TO_ADDRESS(P)   VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_FKL_FCT)        /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VFF_TO_ADDRESS */
+#if !defined(VX1000_PTR2SL_TO_ADDRESS)
+#define VX1000_PTR2SL_TO_ADDRESS(P)    VX1000_POINTER_TO_ADDRESS((P), vx1000_staticLut_T)             /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2SL_TO_ADDRESS */
+#if !defined(VX1000_PTR2U32_TO_ADDRESS)
+#define VX1000_PTR2U32_TO_ADDRESS(P)   VX1000_POINTER_TO_ADDRESS((P), VX1000_UINT32)                  /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2U32_TO_ADDRESS */
+#if !defined(VX1000_PTR2U8_TO_ADDRESS)
+#define VX1000_PTR2U8_TO_ADDRESS(P)    VX1000_POINTER_TO_ADDRESS((P), VX1000_UINT8)                   /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2U8_TO_ADDRESS */
+#if !defined(VX1000_PTR2VM_TO_ADDRESS)
+#define VX1000_PTR2VM_TO_ADDRESS(P)    VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_MAILBOX_T)      /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VM_TO_ADDRESS */
+#if !defined(VX1000_PTR2CU8_TO_ADDRESS)
+#define VX1000_PTR2CU8_TO_ADDRESS(P)   VX1000_POINTER_TO_ADDRESS((P), const VX1000_UINT8)             /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2CU8_TO_ADDRESS */
+#if !defined(VX1000_PTR2CU32_TO_ADDRESS)
+#define VX1000_PTR2CU32_TO_ADDRESS(P)  VX1000_POINTER_TO_ADDRESS((P), const VX1000_UINT32)            /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2CU32_TO_ADDRESS */
+#if !defined(VX1000_PTR2VO_TO_ADDRESS)
+#define VX1000_PTR2VO_TO_ADDRESS(P)    VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_OLDA_T)         /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VO_TO_ADDRESS */
+#if !defined(VX1000_PTR2U16_TO_ADDRESS)
+#define VX1000_PTR2U16_TO_ADDRESS(P)   VX1000_POINTER_TO_ADDRESS((P), VX1000_UINT16)                  /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2U16_TO_ADDRESS */
+#if !defined(VX1000_PTR2VS_TO_ADDRESS)
+#define VX1000_PTR2VS_TO_ADDRESS(P)    VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_STIM_T)         /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VS_TO_ADDRESS */
+#if !defined(VX1000_PTR2MC_TO_ADDRESS)
+#define VX1000_PTR2MC_TO_ADDRESS(P)    VX1000_POINTER_TO_ADDRESS((P), VX1000_MEMSYNC_CPY_T)           /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2MC_TO_ADDRESS */
+#if !defined(VX1000_PTR2MT_TO_ADDRESS)
+#define VX1000_PTR2MT_TO_ADDRESS(P)    VX1000_POINTER_TO_ADDRESS((P), VX1000_MEMSYNC_TRIG_T)          /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2MT_TO_ADDRESS */
+#if !defined(VX1000_PTR2VRM_TO_ADDRESS)
+#define VX1000_PTR2VRM_TO_ADDRESS(P)   VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_RES_MGMT_T)     /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VRM_TO_ADDRESS */
+#if !defined(VX1000_PTR2VEHM_TO_ADDRESS)
+#define VX1000_PTR2VEHM_TO_ADDRESS(P)  VX1000_POINTER_TO_ADDRESS((P), volatile VX1000_EMEM_HDR_T)     /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VEHM_TO_ADDRESS */
+#if !defined(VX1000_PTR2V_TO_ADDRESS)
+#define VX1000_PTR2V_TO_ADDRESS(P)     VX1000_POINTER_TO_ADDRESS((P), void)                           /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2V_TO_ADDRESS */
+#if !defined(VX1000_PTR2VOVL_TO_ADDRESS)
+#define VX1000_PTR2VOVL_TO_ADDRESS(P)  VX1000_POINTER_TO_ADDRESS((P), VX1000_OVL_T)                   /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2VOVL_TO_ADDRESS */
+#if !defined(VX1000_PTR2SE_TO_ADDRESS)
+#define VX1000_PTR2SE_TO_ADDRESS(P)    VX1000_POINTER_TO_ADDRESS((P), VX1000_STIM_EVENT_T)            /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2SE_TO_ADDRESS */
+#if !defined(VX1000_PTR2CC_TO_ADDRESS)
+#define VX1000_PTR2CC_TO_ADDRESS(P)    VX1000_POINTER_TO_ADDRESS((P), const VX1000_CHAR)              /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2CC_TO_ADDRESS */
+#if !defined(VX1000_PTR2C_TO_ADDRESS)
+#define VX1000_PTR2C_TO_ADDRESS(P)     VX1000_POINTER_TO_ADDRESS((P), VX1000_CHAR)                    /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_PTR2C_TO_ADDRESS */
+
+#if !defined(VX1000_OLDA_NOPS)
+#define VX1000_OLDA_NOPS()             /* empty */
+#endif /* !VX1000_OLDA_NOPS */
+
+#if defined(VX1000_TARGET_XC2000)
+#define VX1000_WORDSIZE                2
+#define VX1000_WORDSIZESHIFT           1
+#define VX1000_UINTWS VX1000_UINT16
+#if !defined(VX1000_PTR2VWS_TO_ADDRESS)
+#define VX1000_PTR2VWS_TO_ADDRESS(A)   VX1000_PTR2VU16_TO_ADDRESS(A) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* VX1000_PTR2VWS_TO_ADDRESS */
+#if !defined(VX1000_ADDR_TO_PTR2UWS)
+#define VX1000_ADDR_TO_PTR2UWS(A)      VX1000_ADDR_TO_PTR2U16(A)                                      /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#define VX1000_ADDR_TO_PTR2VUWS(A)     VX1000_ADDR_TO_PTR2VU16(A)                                     /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2UWS */
+#else /* !VX1000_TARGET_XC2000 */
+#define VX1000_WORDSIZE                4
+#define VX1000_WORDSIZESHIFT           2
+#define VX1000_UINTWS VX1000_UINT32
+#if !defined(VX1000_PTR2VWS_TO_ADDRESS)
+#define VX1000_PTR2VWS_TO_ADDRESS(A)   VX1000_PTR2VU32_TO_ADDRESS(A) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* VX1000_PTR2VWS_TO_ADDRESS */
+#if !defined(VX1000_ADDR_TO_PTR2UWS)
+#define VX1000_ADDR_TO_PTR2UWS(A)      VX1000_ADDR_TO_PTR2U32(A)                                      /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#define VX1000_ADDR_TO_PTR2VUWS(A)     VX1000_ADDR_TO_PTR2VU32(A)                                     /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to allow the user to provide type-casting code that compiles without warnings on his toolchain */
+#endif /* !VX1000_ADDR_TO_PTR2UWS */
+#endif /* !VX1000_TARGET_XC2000 */
+
+#define VX1000_TRSFRLISTSPC_INIT(IDX)  VX1000_O8DESC_TIMESTAMP_EV    VX1000_O8DESC_TRIGSPCEV   VX1000_O8DESC_DONE /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_EVENTDESCR_SPCSIZ       VX1000_O8DLEN_TIMESTAMP_EV + (VX1000_O8DLEN_TRIGSPCEV + VX1000_O8DLEN_DONE)
+#define VX1000_TRSFRLISTDAQ_INIT(IDX)  VX1000_O8DESC_TIMESTAMP_EV    VX1000_O8DESC_TRIGDAQEV(IDX)  VX1000_O8DESC_DONE /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_EVENTDESCR_DAQSIZ       VX1000_O8DLEN_TIMESTAMP_EV + (VX1000_O8DLEN_TRIGDAQEV     + VX1000_O8DLEN_DONE)
+#define VX1000_EVENTLIST_INIT(IDX)     0 ,0 ,0 ,0  /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_EVENTLIST_INIT001(IDX)  , 0, 0, 0, (((VX1000_EVENTDESCR_SPCSIZ) + ((IDX) * (VX1000_EVENTDESCR_DAQSIZ))) * 0x10001UL) /* TransferIndex duplicated into unused TransferCount field to support both endianess types */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compiletime and thus cannot be turned into a function */
+#define VX1000_EVENTLIST_INIT002(IDX)  VX1000_EVENTLIST_INIT001((IDX)) VX1000_EVENTLIST_INIT001((IDX) + 0x001) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_EVENTLIST_INIT004(IDX)  VX1000_EVENTLIST_INIT002((IDX)) VX1000_EVENTLIST_INIT002((IDX) + 0x002) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_EVENTLIST_INIT008(IDX)  VX1000_EVENTLIST_INIT004((IDX)) VX1000_EVENTLIST_INIT004((IDX) + 0x004) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_EVENTLIST_INIT010(IDX)  VX1000_EVENTLIST_INIT008((IDX)) VX1000_EVENTLIST_INIT008((IDX) + 0x008) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_EVENTLIST_INIT020(IDX)  VX1000_EVENTLIST_INIT010((IDX)) VX1000_EVENTLIST_INIT010((IDX) + 0x010) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_EVENTLIST_INIT040(IDX)  VX1000_EVENTLIST_INIT020((IDX)) VX1000_EVENTLIST_INIT020((IDX) + 0x020) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_EVENTLIST_INIT080(IDX)  VX1000_EVENTLIST_INIT040((IDX)) VX1000_EVENTLIST_INIT040((IDX) + 0x040) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_EVENTLIST_INIT100(IDX)  VX1000_EVENTLIST_INIT080((IDX)) VX1000_EVENTLIST_INIT080((IDX) + 0x080) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_EVENTLIST_INIT200(IDX)  VX1000_EVENTLIST_INIT100((IDX)) VX1000_EVENTLIST_INIT100((IDX) + 0x100) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_TRSFRLIST_INIT001(IDX)  , VX1000_TRSFRLISTDAQ_INIT((IDX)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compiletime and thus cannot be turned into a function */
+#define VX1000_TRSFRLIST_INIT002(IDX)  VX1000_TRSFRLIST_INIT001((IDX)) VX1000_TRSFRLIST_INIT001((IDX) + 0x001) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_TRSFRLIST_INIT004(IDX)  VX1000_TRSFRLIST_INIT002((IDX)) VX1000_TRSFRLIST_INIT002((IDX) + 0x002) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_TRSFRLIST_INIT008(IDX)  VX1000_TRSFRLIST_INIT004((IDX)) VX1000_TRSFRLIST_INIT004((IDX) + 0x004) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_TRSFRLIST_INIT010(IDX)  VX1000_TRSFRLIST_INIT008((IDX)) VX1000_TRSFRLIST_INIT008((IDX) + 0x008) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_TRSFRLIST_INIT020(IDX)  VX1000_TRSFRLIST_INIT010((IDX)) VX1000_TRSFRLIST_INIT010((IDX) + 0x010) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_TRSFRLIST_INIT040(IDX)  VX1000_TRSFRLIST_INIT020((IDX)) VX1000_TRSFRLIST_INIT020((IDX) + 0x020) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_TRSFRLIST_INIT080(IDX)  VX1000_TRSFRLIST_INIT040((IDX)) VX1000_TRSFRLIST_INIT040((IDX) + 0x040) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_TRSFRLIST_INIT100(IDX)  VX1000_TRSFRLIST_INIT080((IDX)) VX1000_TRSFRLIST_INIT080((IDX) + 0x080) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+#define VX1000_TRSFRLIST_INIT200(IDX)  VX1000_TRSFRLIST_INIT100((IDX)) VX1000_TRSFRLIST_INIT100((IDX) + 0x100) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compile-time and thus cannot be turned into a function */
+
+
+#if !defined(VX1000_DUMMYREAD)
+#define VX1000_DUMMYREAD(X)            /* empty */
+#endif /* !VX1000_DUMMYREAD */
+
+#if !defined(VX1000_DISCARD4DUMMYARGS)
+#define VX1000_DISCARD4DUMMYARGS(T, R, A1, A2, A3, A4)  (R)
+#endif /* !VX1000_DISCARD4DUMMYARGS */
+
+
+#if !defined(VX1000_DISABLE_INSTRUMENTATION)
+/*------------------------------------------------------------------------------ */
+/* optional forced special linkage                                               */
+
+/* include user-defined lines with optional section pragmas to force individual linkage of VX1000 code and/or data: */
+#define VX1000_BEGSECT_VXMODULE_H
+#include "VX1000_cfg.h"  /* PRQA S 0883 */ /* Willingly violating MISRA rule 19.15: this file is included multiple times because it contains multiple disjunct parts that each are filtered exactly once by preprocessor conditions */ /* PRQA S 5087*/ /* Willingly violating MISRA rule 19.1: this file is included multiple at exactly those lines where it is needed to expand to the desired lines. Inclusion/expansion of those lines at the top of this file would not make sense and lead to compile errors */
+#define VX1000_BEGSECT_VXMODULE_H_UNDO
+#endif /* !VX1000_DISABLE_INSTRUMENTATION */
+
+
+#if defined(VX1000_COMPILED_FOR_SLAVECORES)
+/* On multi-core systems with different instruction sets, the same function must exist multiple times, so add suffixes: */
+#define VX1000_SUFFU3(F,S) F ## _ ## S /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parentheses would change the meaning of the code (result is a label) */
+#define VX1000_SUFFU2(F,S) VX1000_SUFFU3(F,S) /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parentheses would change the meaning of the code (result is a label) */
+#define VX1000_SUFFUN(F) VX1000_SUFFU2(F,VX1000_COMPILED_FOR_SLAVECORES)  /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parentheses would change the meaning of the code (result is a label) */
+#else /* !VX1000_COMPILED_FOR_SLAVECORES */
+#define VX1000_SUFFUN(F) F /* direct mapping */ /* PRQA S 3410 */ /* Willingly violating MISRA rule 19.10 because extra parentheses would change the meaning of the code (result is a label) */
+#endif /* !VX1000_COMPILED_FOR_SLAVECORES */
+
+#if defined(VX1000_ADADDONS_BUILDNUMBER_H)
+#if !defined(VX1000_MEMSYNC_TRIGGER_COUNT)
+#define VX1000_MEMSYNC_TRIGGER_COUNT   0   /* this misplaced default setting is just a workaround for AddOns file split dependencies in some configurations. The REAL place for default settings is way down */
+#endif /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+#include "VX1000_addons.h"                 /* basically included too early. should be included after ALL default settings and consistency checks have been done! */
+#endif /* VX1000_ADADDONS_BUILDNUMBER_H */
+
+#if defined(VX1000_TARGET_POWERPC)
+
+/*------------------------------------------------------------------------------ */
+/* PowerPC related defines                                                       */
+
+#define VX1000_ADD_MPC_TRIGS(B)        do { (VX1000_ADDR_TO_PTR2VU32(VX1000_OLDA_DTS_BASE_ADDR))[2] = 1UL << (B);/* mirror register only available on few derivatives: *(volatile VX1000_UINT32*)((VX1000_OLDA_DTS_BASE_ADDR) + 12UL) = 1UL << (B); */ /* the HW ORs the bit to existing bits in DTS_SEMAPHORE_A,B */ } while (0)
+
+#endif /* VX1000_TARGET_POWERPC */
+
+#if defined(VX1000_TARGET_TRICORE)
+
+/*------------------------------------------------------------------------------ */
+/* TriCore related defines                                                       */
+
+#define VX1000_JTAGID_PN_TC1767            0x00159000UL
+#define VX1000_JTAGID_PN_TC1797            0x0015A000UL
+#define VX1000_JTAGID_PN_TC178x            0x0018E000UL
+#define VX1000_JTAGID_PN_TC1387            0x0018F000UL
+#define VX1000_JTAGID_PN_TC1798            0x001BE000UL
+#define VX1000_JTAGID_PN_TC172x            0x001D0000UL
+#define VX1000_JTAGID_PN_TC27xTC2Dx        0x001DA000UL /* TC27x and TC2Dx have the same base ID, bits 28..31==1/2/3/4 define Dx/7A/7B/7C */
+#define VX1000_JTAGID_PN_TC26x             0x001E8000UL
+#define VX1000_JTAGID_PN_TC29x             0x001E9000UL
+#define VX1000_JTAGID_PN_TC24x             0x001EA000UL
+#define VX1000_JTAGID_PN_TC23x             0x00200000UL
+#define VX1000_JTAGID_PN_TC22x             0x00201000UL
+#define VX1000_JTAGID_PN_TC21x             0x00202000UL
+#define VX1000_JTAGID_PN_TC39x             0x00205000UL /* identical PN field for both Astep and Bstep of TC39x */
+#define VX1000_JTAGID_PN_TC38x             0x00206000UL /* Astep NG */
+#define VX1000_JTAGID_PN_TC37x             0x00207000UL /* Astep NG */
+#define VX1000_JTAGID_PN_TC37xED           0x00208000UL /* Astep NG */
+#define VX1000_JTAGID_PN_TC36x             0x00209000UL /* Astep NG */
+#define VX1000_JTAGID_PN_TC35x             0x0020A000UL /* Astep NG */
+#define VX1000_JTAGID_PN_TC33x             0x0020B000UL /* Astep NG */
+#define VX1000_JTAGID_PN_TC33xED           0x0020C000UL /* Astep NG */
+#define VX1000_JTAGID_PN_TC32x             0x0020D000UL /* Astep NG */
+#define VX1000_JTAGID_PN_MASK              0x0FFFF000UL
+
+#if !defined(VX1000_ECU_IS_AURIX) /* if not defined by user to 0 or 1, provide automatic check: */
+#define VX1000_ECU_IS_AURIX() (((VX1000_MCREG_CBS_JTAGID) & (VX1000_JTAGID_PN_MASK)) >= (VX1000_JTAGID_PN_TC27xTC2Dx))
+#endif /* !VX1000_ECU_IS_AURIX */
+#if !defined(VX1000_ECU_IS_AURIXPLUS) /* if not defined by user to 0 or 1, provide automatic check: */
+#define VX1000_ECU_IS_AURIXPLUS() (((VX1000_MCREG_CBS_JTAGID) & (VX1000_JTAGID_PN_MASK)) >= (VX1000_JTAGID_PN_TC39x))
+#endif /* !VX1000_ECU_IS_AURIXPLUS */
+
+/* JTAG Device Identification Register */
+#define VX1000_MCREG_CBS_JTAGID            ((VX1000_ADDR_TO_PTR2VU32(0xF0000464UL))[0])
+/* OSCU Control Register (ENDINIT protection ctl?) */
+#define VX1000_MCREG_CBS_OCNTRL            ((VX1000_ADDR_TO_PTR2VU32(0xF000047CUL))[0])
+/* OCDS Interface Mode Control (ENDINIT protection ctl?) */
+#define VX1000_MCREG_OCDS_OCNTRL           ((VX1000_ADDR_TO_PTR2VU32(0xF000047CUL))[0])
+/* Aurix OCDS Interface Mode Control */
+#define VX1000_MCREG_OCDS_OIFM             ((VX1000_ADDR_TO_PTR2VU32(0xF000040CUL))[0])
+/* Tricore Overlay Control Registers */
+#define VX1000_MCREG_OVC_OCON              ((VX1000_ADDR_TO_PTR2VU32(0xF87FFBE0UL))[0])
+#define VX1000_MCREG_OVC_OENABLE           ((VX1000_ADDR_TO_PTR2VU32(0xF87FFBE8UL))[0])
+/* Aurix Overlay Control Register */
+#define VX1000_MCREG_SCU_OVCENBL_AURIX     ((VX1000_ADDR_TO_PTR2VU32(0xF00361E0UL))[0])
+#define VX1000_MCREG_SCU_OVCCON            ((VX1000_ADDR_TO_PTR2VU32(0xF00361E4UL))[0])
+/* Aurix Overlay Range Select Register for each Core */
+#define VX1000_MCREG_OVC0_OSEL             ((VX1000_ADDR_TO_PTR2VU32(0xF880FB00UL))[0])
+#define VX1000_MCREG_OVC1_OSEL             ((VX1000_ADDR_TO_PTR2VU32(0xF882FB00UL))[0])
+#define VX1000_MCREG_OVC2_OSEL             ((VX1000_ADDR_TO_PTR2VU32(0xF884FB00UL))[0])
+#define VX1000_MCREG_OVC3_OSEL             ((VX1000_ADDR_TO_PTR2VU32(0xF886FB00UL))[0])
+#define VX1000_MCREG_OVC4_OSEL             ((VX1000_ADDR_TO_PTR2VU32(0xF888FB00UL))[0])
+#define VX1000_MCREG_OVC5_OSEL             ((VX1000_ADDR_TO_PTR2VU32(0xF88CFB00UL))[0])
+#define VX1000_MCREG_OVC_OSEL(C)           ((VX1000_ADDR_TO_PTR2VU32(0xF880FB00UL) + ((C) << 17U))[0]) /* attention: there is one gap behind C==4 */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because the expanded expression depending on the context must serve either as lvalue or as rvalue, so implementing it as a function is not possible */
+/* Arrays of various Overlay Registers */
+#define VX1000_MCREGADDR_RABR(I)           ((0xF87FFB20UL + (12UL * (I)))) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because the expanded expression depending on the context must serve either as lvalue or as rvalue, so implementing it as a function is not possible */
+#define VX1000_MCREGADDR_RABR_AURIX(I,C)   ((0xF880FB10UL + (12UL * (I))) + ((C) << 17U)) /* attention: there is one gap behind C==4 */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because the expanded expression depending on the context must serve either as lvalue or as rvalue, so implementing it as a function is not possible */
+#define VX1000_MCREGADDR_OMASK(I)          ((0xF87FFB28UL + (12UL * (I)))) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because the expanded expression depending on the context must serve either as lvalue or as rvalue, so implementing it as a function is not possible */
+#define VX1000_MCREGADDR_OMASK_AURIX(I,C)  ((0xF880FB18UL + (12UL * (I))) + ((C) << 17U)) /* attention: there is one gap behind C==4 */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because the expanded expression depending on the context must serve either as lvalue or as rvalue, so implementing it as a function is not possible */
+#define VX1000_MCREGADDR_OTAR(I)           ((0xF87FFB24UL + (12UL * (I)))) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because the expanded expression depending on the context must serve either as lvalue or as rvalue, so implementing it as a function is not possible */
+#define VX1000_MCREGADDR_OTAR_AURIX(I,C)   ((0xF880FB14UL + (12UL * (I))) + ((C) << 17U)) /* attention: there is one gap behind C==4 */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because the expanded expression depending on the context must serve either as lvalue or as rvalue, so implementing it as a function is not possible */
+/* TRIGS Register */
+#define VX1000_MCREG_OCDS_TRIGS            ((VX1000_ADDR_TO_PTR2VU32(0xF00004A0UL))[0])
+/* TRIGC Register */
+#define VX1000_MCREG_OCDS_TRIGC            ((VX1000_ADDR_TO_PTR2VU32(0xF00004A4UL))[0])
+/* Tricore TRIG v1 Register */
+#define VX1000_MCREG_OCDS_TRIG             ((VX1000_ADDR_TO_PTR2VU32(0xF00004A8UL))[0])
+/* Aurix TRIG20 v2 Register */
+#define VX1000_MCREG_OCDS_TRIG20           ((VX1000_ADDR_TO_PTR2VU32(0xF0000550UL))[0]) /* yes! */
+/* Aurix TRIG5 v3 Register */
+#define VX1000_MCREG_OCDS_TRIG5            ((VX1000_ADDR_TO_PTR2VU32(0xF0000514UL))[0]) /* TRIG20 does not exist for TC23x (only 0-5) */
+/* Tricore Application Reset Disable Register */
+#define VX1000_MCREG_SCU_ARSTDIS           ((VX1000_ADDR_TO_PTR2VU32(0xF000055CUL))[0])
+
+#define VX1000_AURIX_TRIG_REG_OFS          480UL /* Bit 0 in OCDS_TRIG20; */
+#define VX1000_AURIX_TRIG_REG_OFS_V3       80UL  /* Bit 0 in OCDS_TRIG5;  */
+
+#endif /* VX1000_TARGET_TRICORE */
+
+
+/*------------------------------------------------------------------------------ */
+/* VX1000 default parameters                                                     */
+
+#if defined(VX1000_TARGET_TRICORE)
+
+/*
+ Enable 3 or 2 wire DAP mode and disable BYPASS (JTAG) to increase immunity against disturbances
+ Default is 2 wire DAP
+ VX1000_OCDS_OCNTRL =  0x0000000F;  DJMODE = 11 Three PIN DAP with disabled BYPASS
+ VX1000_OCDS_OCNTRL =  0x00000007;  DJMODE = 01 Two-pin DAP with disabled BYPASS
+*/
+#if !defined(VX1000_OCDS_OCNTRL)
+#define VX1000_OCDS_OCNTRL         0x00000007UL
+#endif /* !VX1000_OCDS_OCNTRL */
+#if !defined(VX1000_OCDS_OIFM)
+/* 2pin DAP (legacy) */
+#define VX1000_OCDS_OIFM           0x00000000UL
+#endif /* !VX1000_OCDS_OIFM */
+
+#endif /* VX1000_TARGET_TRICORE */
+
+#if !defined(VX1000_ARM_DSB)
+#define VX1000_ARM_DSB()               /* empty */
+#endif /* !VX1000_ARM_DSB */
+
+#if !defined(VX1000_ENTER_SPINLOCK)
+#define VX1000_ENTER_SPINLOCK()
+#endif /* !VX1000_ENTER_SPINLOCK */
+#if !defined(VX1000_LEAVE_SPINLOCK)
+#define VX1000_LEAVE_SPINLOCK()
+#endif /* !VX1000_LEAVE_SPINLOCK */
+#if !defined(VX1000_ATOMIC_XOR32)
+#define VX1000_ATOMIC_XOR32(A, D) do                          \\
+  {                                                           \\
+    VX1000_ENTER_SPINLOCK()                                   \\
+    (VX1000_ADDR_TO_PTR2VU32(A))[0] ^= (D);                   \\
+    VX1000_LEAVE_SPINLOCK()                                   \\
+  } while (0) /* this never-looping while is here only for MISRA */
+#endif /* !VX1000_ATOMIC_XOR32 */
+#if !defined(VX1000_ATOMIC_XOR32X2)
+#define VX1000_ATOMIC_XOR32X2(A, D) do                        \\
+  {                                                           \\
+    VX1000_ENTER_SPINLOCK()                                   \\
+    (VX1000_ADDR_TO_PTR2VU32(A))[0] ^= (D);                   \\
+    (VX1000_ADDR_TO_PTR2VU32(A))[1] ^= (D);                   \\
+    VX1000_LEAVE_SPINLOCK()                                   \\
+  } while (0) /* this never-looping while is here only for MISRA */
+#endif /* !VX1000_ATOMIC_XOR32X2 */
+
+#if !defined(VX1000_ATOMIC_AND32)
+#define VX1000_ATOMIC_AND32(A, D) do                          \\
+  {                                                           \\
+    VX1000_ENTER_SPINLOCK()                                   \\
+    (VX1000_ADDR_TO_PTR2VU32(A))[0] &= (D);                   \\
+    VX1000_LEAVE_SPINLOCK()                                   \\
+  } while (0) /* this never-looping while is here only for MISRA */
+#endif /* !VX1000_ATOMIC_AND32 */
+
+#if !defined(VX1000_ATOMIC_OR32)
+#define VX1000_ATOMIC_OR32(A, D) do                           \\
+  {                                                           \\
+    VX1000_ENTER_SPINLOCK()                                   \\
+    (VX1000_ADDR_TO_PTR2VU32(A))[0] |= (D);                   \\
+    VX1000_LEAVE_SPINLOCK()                                   \\
+  } while (0) /* this never-looping while is here only for MISRA */
+#endif /* !VX1000_ATOMIC_OR32 */
+
+#if !defined(VX1000_MAILBOX_SLOT_DWORDS)
+#define VX1000_MAILBOX_SLOT_DWORDS     (1UL + 2UL) /* must be at least 3 (=4 bytes size info + 8 bytes payload (=XCP command)) */
+#endif /* !VX1000_MAILBOX_SLOT_DWORDS */
+#if !defined(VX1000_MAILBOX_SLOTS)
+#define VX1000_MAILBOX_SLOTS           8U
+#endif /* !VX1000_MAILBOX_SLOTS */
+
+#if !defined(VX1000_OLDA_HIPRIOMASK)
+#define VX1000_OLDA_HIPRIOMASK         0UL
+#endif /* !VX1000_OLDA_HIPRIOMASK */
+
+#if !defined(VX1000_IS_BYPASS_RESUME_ALLOWED)
+#define VX1000_IS_BYPASS_RESUME_ALLOWED() 0
+#endif /* VX1000_IS_BYPASS_RESUME_ALLOWED */
+
+#if ((!defined(VX1000_OLDA_FORCE_V6)) && (!defined(VX1000_OLDA_FORCE_V7))) && (!defined(VX1000_OLDA_FORCE_V8))
+#define VX1000_OLDA_FORCE_V7
+#endif /* !VX1000_OLDA_FORCE_V6 && !VX1000_OLDA_FORCE_V7 && !VX1000_OLDA_FORCE_V8 */
+
+#if !defined(VX1000_OVERLAY_PHYSADDR)
+#define VX1000_OVERLAY_PHYSADDR        VX1000_OVERLAY_ADDR
+#endif /* !VX1000_OVERLAY_PHYSADDR */
+
+#if !defined(VX1000_CALRAM_PHYSADDR)
+#define VX1000_CALRAM_PHYSADDR         VX1000_CALRAM_ADDR
+#endif /* !VX1000_CALRAM_PHYSADDR */
+
+#if !defined(VX1000_ERRLOG_SIZE)
+#define VX1000_ERRLOG_SIZE             0
+#endif /* !VX1000_ERRLOG_SIZE */
+
+#if !defined(VX1000_MEMSYNC_TRIGGER_COUNT)
+#define VX1000_MEMSYNC_TRIGGER_COUNT   0  /* this is the correct place for default settings. As a workaround for AddOns file split dependencies this had to pre-done at the beginning of the file in some configurations */
+#endif /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+
+#if !defined(VX1000_MEMSYNC_COPY_COUNT)
+#define VX1000_MEMSYNC_COPY_COUNT      0
+#endif /* !VX1000_MEMSYNC_COPY_COUNT */
+
+#if !defined(VX1000_CURRENT_CORE_IDX)
+#define VX1000_CURRENT_CORE_IDX()      0
+#endif /* !VX1000_CURRENT_CORE_IDX */
+
+#if (!defined(VX1000_STORE64)) && defined(VX1000_UINT64)
+#define VX1000_STORE64(S, A, D ) do { ((VX1000_ADDR_TO_PTR2VU64((S))))[0] = (((VX1000_UINT64)(A) << 3) << 29) | (VX1000_UINT64)(D); } while (0)  /* this never-looping while is here only for MISRA */ /* PRQA S 0303 */ /* Violation of MISRA rule 12.8 because 64-bit data types are known to be not MISRA-conformant. This is just an example to be overruled by a user-defined implementation of an atomic 64-bit-store operation. */
+#endif /* !VX1000_STORE64 & VX1000_UINT64 */
+
+#if defined(VX1000_TARGET_POWERPC)
+
+#if !defined(VX1000_LFAST_PLLMULOFS)
+#define VX1000_LFAST_PLLMULOFS         1 /* There are rumours that few derivatives use 0 instead of 1. The user can overload the default in those cases */
+#endif /* !VX1000_LFAST_PLLMULOFS */
+
+#endif /* VX1000_TARGET_POWERPC */
+
+#if defined(VX1000_TARGET_TRICORE)
+
+/*------------------------------------------------------------------------------ */
+/* Tricore default clock: The resolution of this clock must still be specified   */
+/* in VX1000_cfg.h and also in vxconfigplugin.xml!                               */
+/* Otherwise a randomly chosen value of 180 MHz is assumed for SystemTimer0.     */
+
+#if (!defined(VX1000_CLOCK)) && (!defined(VX1000_DISABLE_INSTRUMENTATION))
+/* This code is only here for backwards compatible handling of badly configured  */
+/* applications! It is inactive in normal configurations:                        */
+#if defined(VX1000_MCREG_STM0_TIM0)
+#define VX1000_CLOCK() (VX1000_MCREG_STM0_TIM0)
+#else /* !VX1000_MCREG_STM0_TIM0 */
+#if !defined(VX1000_CLOCK_TIMER_ADDR)
+#define VX1000_CLOCK_TIMER_ADDR        (VX1000_ECU_IS_AURIX() ? ((VX1000_ECU_IS_AURIXPLUS())?0xF0001010UL:0xF0000010UL):0xF0000210UL)  /* for Tricore built-in clock we know the timer address */
+#endif /* !VX1000_CLOCK_TIMER_ADDR */
+#define VX1000_CLOCK()                 ((VX1000_ADDR_TO_PTR2VU32(VX1000_CLOCK_TIMER_ADDR))[0])
+#endif /* !VX1000_MCREG_STM0_TIM0 */
+#endif /* !VX1000_CLOCK, !VX1000_DISABLE_INSTRUMENTATION */
+#if (((!defined(VX1000_CLOCK_TICKS_PER_BASE)) && (!defined(VX1000_CLOCK_TICKS_PER_S))) && ((!defined(VX1000_CLOCK_TICKS_PER_MS)) && (!defined(VX1000_CLOCK_TICKS_PER_US)))) && (!defined(VX1000_DISABLE_INSTRUMENTATION))
+#define VX1000_CLOCK_TICKS_PER_US 45UL /* 180 MHz */
+#endif /* !VX1000_CLOCK_TICKS_PER_MS, !VX1000_DISABLE_INSTRUMENTATION */
+
+#endif /* VX1000_TARGET_TRICORE */
+
+#if defined(VX1000_CLOCK_TICKS_PER_BASE)
+
+#if (!defined(VX1000_CLOCK_TICKS_BASE_NS)) && (!defined(VX1000_DISABLE_INSTRUMENTATION))
+#error Please define VX1000_CLOCK_TICKS_BASE_NS as the time bas in ns during which VX1000_CLOCK_TICKS_PER_BASE ticks occur
+#endif /* !VX1000_CLOCK_TICKS_BASE_NS && !VX1000_DISABLE_INSTRUMENTATION */
+
+#else /* !VX1000_CLOCK_TICKS_PER_BASE */
+
+#if defined(VX1000_CLOCK_TICKS_PER_S)
+#define VX1000_CLOCK_TICKS_PER_BASE    (VX1000_CLOCK_TICKS_PER_S)
+#define VX1000_CLOCK_TICKS_BASE_NS     1000000000UL
+#elif defined(VX1000_CLOCK_TICKS_PER_MS)
+#define VX1000_CLOCK_TICKS_PER_BASE    (VX1000_CLOCK_TICKS_PER_MS)
+#define VX1000_CLOCK_TICKS_BASE_NS     1000000UL
+#elif defined(VX1000_CLOCK_TICKS_PER_US)
+#define VX1000_CLOCK_TICKS_PER_BASE    (VX1000_CLOCK_TICKS_PER_US)
+#define VX1000_CLOCK_TICKS_BASE_NS     1000UL
+#elif !defined(VX1000_DISABLE_INSTRUMENTATION)
+#error Please define VX1000_CLOCK_TICKS_PER_US or VX1000_CLOCK_TICKS_PER_MS or VX1000_CLOCK_TICKS_PER_S
+#endif /* !VX1000_DISABLE_INSTRUMENTATION */
+
+#endif /* !VX1000_CLOCK_TICKS_PER_BASE */
+
+#if !defined(VX1000_CLOCK_TICKS_PER_S)
+#define VX1000_CLOCK_TICKS_PER_S       ((1000000000UL * (VX1000_CLOCK_TICKS_PER_BASE)) / (VX1000_CLOCK_TICKS_BASE_NS))
+#endif /* !VX1000_CLOCK_TICKS_PER_S */
+
+#if !defined(VX1000_CLOCK_TICKS_PER_MS)
+#define VX1000_CLOCK_TICKS_PER_MS      ((1000000UL * (VX1000_CLOCK_TICKS_PER_BASE)) / (VX1000_CLOCK_TICKS_BASE_NS))
+#endif /* !VX1000_CLOCK_TICKS_PER_MS */
+
+#if !defined(VX1000_CLOCK_TICKS_PER_US)
+#define VX1000_CLOCK_TICKS_PER_US      ((1000UL * (VX1000_CLOCK_TICKS_PER_BASE)) / (VX1000_CLOCK_TICKS_BASE_NS))
+#endif /* !VX1000_CLOCK_TICKS_PER_US */
+
+#if !defined(VX1000_CLOCK_TIMER_SIZE)
+#define VX1000_CLOCK_TIMER_SIZE        32 /* legacy mode of VX1000_CLOCK() */
+#endif /* !VX1000_CLOCK_TIMER_SIZE */
+
+#if !defined(VX1000_CLOCK_TIMER_ADDRREGION)
+#define VX1000_CLOCK_TIMER_ADDRREGION  0 /* timer is a memory-mapped peripheral (no SPR) */
+#endif /* !VX1000_CLOCK_TIMER_ADDRREGION */
+
+#if !defined(VX1000_CLOCK_TIMER_REVERSE)
+#define VX1000_CLOCK_TIMER_REVERSE     0 /* timer periphery uses same endianess as the CPU */
+#endif /* !VX1000_CLOCK_TIMER_REVERSE */
+
+#if !defined(VX1000_CLOCK_TIMER_ADDR)
+#define VX1000_CLOCK_TIMER_ADDR        0UL /* turns the synchronisation feature off */
+#endif /* !VX1000_CLOCK_TIMER_ADDR */
+
+/* Default timeouts for VX detection in us and cold start initialization in ms */
+#if !defined(VX1000_DETECTION_TIMEOUT_US)
+#define VX1000_DETECTION_TIMEOUT_US    50UL
+#endif /* !VX1000_DETECTION_TIMEOUT_US */
+#if !defined(VX1000_COLDSTART_TIMEOUT_MS)
+#if defined(VX1000_TARGET_XC2000)
+#define VX1000_COLDSTART_TIMEOUT_MS    100UL
+#else  /* !VX1000_TARGET_XC2000 */
+#define VX1000_COLDSTART_TIMEOUT_MS    20UL
+#endif /* !VX1000_TARGET_XC2000 */
+#endif /* !VX1000_COLDSTART_TIMEOUT_MS */
+
+#if !defined(VX1000_OLDA_BENCHMARK_CNT)
+#if defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_OLDA_BENCHMARK_CNT 32U
+#else /* !VX1000_OLDA_FORCE_V8 */
+#define VX1000_OLDA_BENCHMARK_CNT 31U
+#endif /* !VX1000_OLDA_FORCE_V8 */
+#endif /* !VX1000_OLDA_BENCHMARK_CNT */
+
+
+/*------------------------------------------------------------------------------ */
+/* Defines                                                                       */
+
+#if defined(VX1000_DISABLE_INSTRUMENTATION)
+
+#define VX1000_STORE_TIMESTAMP(t)    /*VX1000_DUMMYREAD((t))*/
+#define VX1000_STORE_EVENT(e)        /*VX1000_DUMMYREAD((e))*/
+
+#else /* !VX1000_DISABLE_INSTRUMENTATION */
+
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+
+
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 1)
+
+#if defined(VX1000_TARGET_TRICORE)
+/* On Tricore, the timestamp must be present in both trace paths - try to accomplish this by writing twice; the dummy loop is only there for MISRA: */
+#define VX1000_STORE_TIMESTAMP(t) do                                                                                                      \\
+{                                                                                                                                         \\
+  VX1000_UINT8 evprop = VX1000_CURRENT_CORE_IDX();                                                                                        \\
+  if (evprop >= (VX1000_MEMSYNC_TRIGGER_COUNT))                                                                                           \\
+  {                                                                                                                                       \\
+    evprop = 0;                                                                                                                           \\
+    VX1000_ERRLOGGER(VX1000_ERRLOG_TOO_MANY_CORES)                                                                                        \\
+  }                                                                                                                                       \\
+  VX1000_STORE64(((VX1000_ADDR_TO_PTR2VU32(gVX1000.MemSyncTrigPtr)[evprop] + 0x0C) & ~7UL), (VX1000_UINT32)&gVX1000.EventTimestamp, (t)); \\
+  VX1000_ARM_DSB()                                                                                                                        \\
+  VX1000_STORE64(((VX1000_ADDR_TO_PTR2VU32(gVX1000.MemSyncTrigPtr)[evprop] + 0x0C) & ~7UL), (VX1000_UINT32)&gVX1000.EventTimestamp, (t)); \\
+  VX1000_ARM_DSB()                                                                                                                        \\
+} while (0); /* PRQA S 3356 */ /* PRQA S 3359 */ /* cannot avoid violating MISRA rule 13.7 because this logical operation/control expression is actually an assertion that by design must always evaluate to FALSE  */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#else  /* !VX1000_TARGET_TRICORE */
+#define VX1000_STORE_TIMESTAMP(t) do                                                                                                      \\
+{                                                                                                                                         \\
+  VX1000_UINT8 evprop = VX1000_CURRENT_CORE_IDX();                                                                                        \\
+  if (evprop >= (VX1000_MEMSYNC_TRIGGER_COUNT))                                                                                           \\
+  {                                                                                                                                       \\
+    evprop = 0;                                                                                                                           \\
+    VX1000_ERRLOGGER(VX1000_ERRLOG_TOO_MANY_CORES)                                                                                        \\
+  }                                                                                                                                       \\
+  VX1000_STORE64(((VX1000_ADDR_TO_PTR2VU32(gVX1000.MemSyncTrigPtr)[evprop] + 0x0C) & ~7UL), (VX1000_UINT32)&gVX1000.EventTimestamp, (t)); \\
+  VX1000_ARM_DSB()                                                                                                                        \\
+} while (0); /* PRQA S 3356 */ /* PRQA S 3359 */ /* cannot avoid violating MISRA rule 13.7 because this logical operation/control expression is actually an assertion that by design must always evaluate to FALSE  */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#endif /* !VX1000_TARGET_TRICORE */
+
+#define VX1000_STORE_EVENT(e) do                                                                                                       \\
+{                                                                                                                                      \\
+  VX1000_UINT8 evprop = VX1000_CURRENT_CORE_IDX();                                                                                     \\
+  if (evprop >= (VX1000_MEMSYNC_TRIGGER_COUNT))                                                                                        \\
+  {                                                                                                                                    \\
+    evprop = 0;                                                                                                                        \\
+    VX1000_ERRLOGGER(VX1000_ERRLOG_TOO_MANY_CORES)                                                                                     \\
+  }                                                                                                                                    \\
+  VX1000_STORE64(((VX1000_ADDR_TO_PTR2VU32(gVX1000.MemSyncTrigPtr)[evprop] + 0x0C) & ~7UL), (VX1000_UINT32)&gVX1000.EventNumber, (e)); \\
+  VX1000_ARM_DSB()                                                                                                                     \\
+} while (0); /* PRQA S 3356 */ /* PRQA S 3359 */ /* cannot avoid violating MISRA rule 13.7 because this logical operation/control expression is actually an assertion that by design must always evaluate to FALSE  */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+
+#else  /* VX1000_MEMSYNC_TRIGGER_COUNT == 1*/
+
+#if defined(VX1000_TARGET_TRICORE)
+/* On Tricore, the timestamp must be present in both trace paths - try to accomplish this by writing twice; the dummy loop is only there for MISRA: */
+#define VX1000_STORE_TIMESTAMP(t) do                                                                   \\
+{                                                                                                      \\
+  VX1000_STORE64((gVX1000.MemSyncTrigPtr + 0x0C) & ~7UL, (VX1000_UINT32)&gVX1000.EventTimestamp, (t)); \\
+  VX1000_ARM_DSB()                                                                                     \\
+  VX1000_STORE64((gVX1000.MemSyncTrigPtr + 0x0C) & ~7UL, (VX1000_UINT32)&gVX1000.EventTimestamp, (t)); \\
+  VX1000_ARM_DSB()                                                                                     \\
+} while (0); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#else  /* !VX1000_TARGET_TRICORE */
+#define VX1000_STORE_TIMESTAMP(t) do                                                                   \\
+{                                                                                                      \\
+  VX1000_STORE64((gVX1000.MemSyncTrigPtr + 0x0C) & ~7UL, (VX1000_UINT32)&gVX1000.EventTimestamp, (t)); \\
+  VX1000_ARM_DSB()                                                                                     \\
+} while (0); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#endif /* !VX1000_TARGET_TRICORE */
+
+#define VX1000_STORE_EVENT(e) do                                                                    \\
+{                                                                                                   \\
+  VX1000_STORE64((gVX1000.MemSyncTrigPtr + 0x0C) & ~7UL, (VX1000_UINT32)&gVX1000.EventNumber, (e)); \\
+  VX1000_ARM_DSB()                                                                                  \\
+} while (0); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT == 1*/
+
+#else /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+
+/* Store the time t into gVX1000.EventTimestamp (use all 32bit -- is only avoided in VX1000_FAST_TRACE_EVENT.  */
+#if defined(VX1000_TARGET_TRICORE)
+/* On Tricore, the timestamp must be present in both trace paths - try to accomplish this by writing twice; the dummy loop is only there for MISRA: */
+#define VX1000_STORE_TIMESTAMP(t) do { gVX1000.EventTimestamp = (t); gVX1000.EventTimestamp = gVX1000.EventTimestamp; } while(0); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#else  /* !VX1000_TARGET_TRICORE */
+#define VX1000_STORE_TIMESTAMP(t) gVX1000.EventTimestamp = (t); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#endif /* !VX1000_TARGET_TRICORE */
+
+/* Store the event ID e into gVX1000.EventNumber (use all 32bit -- is only avoided in VX1000_FAST_TRACE_EVENT. */
+#define VX1000_STORE_EVENT(e) gVX1000.EventNumber = (e); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+
+#endif /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+
+#endif /* !VX1000_DISABLE_INSTRUMENTATION */
+
+/* Special Events */
+#define VX1000_EVENT_RAMZERO_START     0x00010000UL
+#define VX1000_EVENT_RAMZERO_DONE      0x00010001UL
+#define VX1000_EVENT_RAMSYNC_START     0x00010002UL
+#define VX1000_EVENT_MAILBOX_INIT      0x00020000UL
+#define VX1000_EVENT_MAILBOX_UPDATE    0x00020001UL
+#define VX1000_EVENT_MAILBOX_RESETREQ  0x00020002UL
+#define VX1000_EVENT_STIM_INIT         0x00030100UL
+#define VX1000_EVENT_STIM_ACK          0x00030101UL
+#define VX1000_EVENT_STIM_TIMEOUT(e)  (0x00030200UL | (e)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because a function call would inhibit constant propagation of the compiler */
+#define VX1000_EVENT_STIM_ERR(e)      (0x00030300UL | (e)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because a function call would inhibit constant propagation of the compiler */
+#define VX1000_EVENT_STRUCT_INIT       0x00040000UL
+#define VX1000_EVENT_GP(e)            (0x00050000UL | (e)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because a function call would inhibit constant propagation of the compiler */
+#define VX1000_ECU_EVT_SW_RESET        VX1000_EVENT_GP(0x00000001UL)
+#define VX1000_ECU_EVT_OLDA_OVERLOAD   VX1000_EVENT_GP(0x00000002UL)
+#define VX1000_ECU_EVT_SW_RESET_FAIL   VX1000_EVENT_GP(0x00000003UL)
+#define VX1000_ECU_EVT_SW_RESET_PREP   VX1000_EVENT_GP(0x00000004UL)
+#define VX1000_ECU_EVT_STIM_SKIP(e)   (VX1000_EVENT_GP(0x00008000UL) | (e)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because a function call would inhibit constant propagation of the compiler */
+
+/*------------------------------------------------------------------------------ */
+/* Check the configuration for plausibility                                      */
+#if !defined(VX1000_DISABLE_INSTRUMENTATION)
+
+#if !defined(VX1000_CLOCK)
+#error Please define VX1000_CLOCK() as a free running 32 bit timer of desired resolution
+#endif /* !VX1000_CLOCK */
+
+#if ((VX1000_CLOCK_TIMER_SIZE != 0) && (VX1000_CLOCK_TIMER_SIZE != 16)) && ((VX1000_CLOCK_TIMER_SIZE != 24) && (VX1000_CLOCK_TIMER_SIZE != 32))
+#error VX1000_CLOCK_TIMER_SIZE supports only these values: 0, 16, 24, 32! (you may round down to gain a valid configuration)
+#endif /* VX1000_CLOCK_TIMER_SIZE */
+
+#if defined(VX1000_OLDA) && defined(VX1000_OLDA_MEMORY_SIZE)
+#if VX1000_OLDA_MEMORY_SIZE > 0xFFFCU
+#error Maximum value allowed for VX1000_OLDA_MEMORY_SIZE configuration is 0xFFFC
+#endif /* VX1000_OLDA_MEMORY_SIZE > 0xFFFC */
+#endif /* VX1000_OLDA & VX1000_OLDA_MEMORY_SIZE */
+
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE) && defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE)
+#error VX1000_SUPPORT_OLDA7_ASMGNUVLE and VX1000_SUPPORT_OLDA7_ASMGNUBOOKE optimisations cannot be enabled at the same time!
+#endif /* VX1000_SUPPORT_OLDA7_ASMGNUVLE && VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+
+#if defined(VX1000_OLDA_FORCE_V6) && defined(VX1000_OLDA_FORCE_V7)
+#error VX1000_OLDA_FORCE_V6 and VX1000_OLDA_FORCE_V7 cannot be enabled at the same time. Please make up your mind!
+#endif /* VX1000_OLDA_FORCE_V6 && VX1000_OLDA_FORCE_V7 */
+
+#if defined(VX1000_OLDA_FORCE_V6) && defined(VX1000_OLDA_FORCE_V8)
+#error VX1000_OLDA_FORCE_V6 and VX1000_OLDA_FORCE_V8 cannot be enabled at the same time. Please make up your mind!
+#endif /* VX1000_OLDA_FORCE_V6 && VX1000_OLDA_FORCE_V8 */
+
+#if defined(VX1000_OLDA_FORCE_V7) && defined(VX1000_OLDA_FORCE_V8)
+#error VX1000_OLDA_FORCE_V7 and VX1000_OLDA_FORCE_V8 cannot be enabled at the same time. Please make up your mind!
+#endif /* VX1000_OLDA_FORCE_V7 && VX1000_OLDA_FORCE_V8 */
+
+#if defined(VX1000_STIM_BY_OLDA) && (!defined(VX1000_OLDA))
+#error VX1000_STIM_BY_OLDA cannot be enabled while VX1000_OLDA is disabled!
+#endif /* VX1000_STIM_BY_OLDA && !VX1000_OLDA */
+
+#if defined(VX1000_STIM_BY_OLDA) && (!defined(VX1000_STIM))
+#error VX1000_STIM_BY_OLDA cannot be enabled while VX1000_STIM is disabled!
+#endif /* VX1000_STIM_BY_OLDA && !VX1000_STIM */
+
+#if defined(VX1000_TARGET_TRICORE)
+
+#if defined(VX1000_STIM) && (!defined(VX1000_STIM_BY_OLDA))
+#if (0==(VX1000_MEMSYNC_TRIGGER_COUNT))
+#error On Tricore, VX1000_STIM cannot be enabled while VX1000_STIM_BY_OLDA is disabled!
+#endif /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+#endif /* VX1000_STIM && !VX1000_STIM_BY_OLDA */
+
+#if (!defined(VX1000_OLDA)) && (!defined(VX1000_DISABLE_INSTRUMENTATION))
+#error On Tricore, VX1000_OLDA must be always enabled!
+#endif /* !VX1000_OLDA && !VX1000_DISABLE_INSTRUMENTATION */
+
+#endif /* VX1000_TARGET_TRICORE */
+
+#if defined(VX1000_TARGET_SH2)
+
+#if defined(VX1000_STIM) && (!defined(VX1000_STIM_BY_OLDA))
+#if (0==(VX1000_MEMSYNC_TRIGGER_COUNT))
+#error On SH2, VX1000_STIM cannot be enabled while VX1000_STIM_BY_OLDA is disabled!
+#endif /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+#endif /* VX1000_STIM && !VX1000_STIM_BY_OLDA */
+
+#if (!defined(VX1000_OLDA)) && (!defined(VX1000_DISABLE_INSTRUMENTATION))
+#error On SH2, VX1000_OLDA must be always enabled!
+#endif /* !VX1000_OLDA && !VX1000_DISABLE_INSTRUMENTATION */
+
+#endif /* VX1000_TARGET_SH2 */
+
+#if defined(VX1000_TARGET_TMS570)
+
+#if defined(VX1000_STIM_BY_OLDA)
+#error On TMS570, VX1000_STIM_BY_OLDA must be always disabled!
+#endif /* VX1000_STIM_BY_OLDA */
+
+#if defined(VX1000_OLDA)
+#error On TMS570, VX1000_OLDA must be always disabled!
+#endif /* VX1000_OLDA */
+
+#endif /* VX1000_TARGET_TMS570 */
+
+#if defined(VX1000_TARGET_XC2000)
+
+#if defined(VX1000_STIM) && (!defined(VX1000_STIM_BY_OLDA))
+#if (0==(VX1000_MEMSYNC_TRIGGER_COUNT))
+#error On XC2000, VX1000_STIM cannot be enabled while VX1000_STIM_BY_OLDA is disabled!
+#endif /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+#endif /* VX1000_STIM && !VX1000_STIM_BY_OLDA */
+
+#if defined(VX1000_SUPPORT_OLDA7_BYTEDAQ) && defined(VX1000_OLDA_FORCE_V7)
+/*#error On XC2000, VX1000_SUPPORT_OLDA7_BYTEDAQ must be disabled!*/
+#endif /* VX1000_SUPPORT_OLDA7_BYTEDAQ & VX1000_OLDA_FORCE_V7*/
+
+#if defined(VX1000_OLDA_FORCE_V8)
+/*#error On XC2000, VX1000_OLDA_FORCE_V8 must be disabled!*/
+#endif /* VX1000_OLDA_FORCE_V8 */
+
+#endif /* VX1000_TARGET_XC2000 */
+
+/* To save memory, the number range for stim events may be reduced, maximum is 31  */
+#if !defined(VX1000_STIM_EVENT_COUNT)
+#define VX1000_STIM_EVENT_COUNT 31   /* Count of STIM events used starting from VX1000_STIM_EVENT_OFFSET */
+#elif VX1000_STIM_EVENT_COUNT > 31
+#error "VX1000_STIM_EVENT_COUNT must be <= 31"
+#endif /* VX1000_STIM_EVENT_COUNT && VX1000_STIM_EVENT_COUNT > 31*/
+
+#if !defined(VX1000_STIM_EVENT_OFFSET)
+#define VX1000_STIM_EVENT_OFFSET 0U   /* Number of the first STIM event */
+#elif (VX1000_STIM_EVENT_OFFSET > 30)
+#error "Event numbers must be <= 30!"
+#endif /* VX1000_STIM_EVENT_OFFSET && VX1000_STIM_EVENT_OFFSET > 30 */
+
+#if defined(VX1000_OLDA_FORCE_V8) || (!defined(VX1000_SUPPRESS_TRACE_SUPPORT))
+#if !defined(VX1000_OLDA_EVENT_COUNT)
+#define VX1000_OLDA_EVENT_COUNT 31U
+#elif VX1000_OLDA_EVENT_COUNT > 512U
+#error "VX1000_OLDA_EVENT_COUNT must be <= 512U!"
+#endif /* VX1000_OLDA_EVENT_COUNT && VX1000_OLDA_EVENT_COUNT > 512 */
+#else /* VX1000_SUPPRESS_TRACE_SUPPORT || !VX1000_OLDA_FORCE_V8 */
+#if !defined(VX1000_OLDA_AUDMBR_REG_ADDR)
+#if !defined(VX1000_OLDA_EVENT_COUNT)
+#define VX1000_OLDA_EVENT_COUNT 31U
+#elif VX1000_OLDA_EVENT_COUNT > 31U
+#error "VX1000_OLDA_EVENT_COUNT must be <= 31U!"
+#endif /* VX1000_OLDA_EVENT_COUNT && VX1000_OLDA_EVENT_COUNT > 31 */
+#else /* VX1000_OLDA_AUDMBR_REG_ADDR) */
+#if !defined(VX1000_OLDA_EVENT_COUNT)
+#define VX1000_OLDA_EVENT_COUNT 15U
+#elif VX1000_OLDA_EVENT_COUNT > 15U
+#error "VX1000_OLDA_EVENT_COUNT must be <= 15U because the AUDMBR register is selected for event signalling!"
+#endif /* VX1000_OLDA_EVENT_COUNT && VX1000_OLDA_EVENT_COUNT > 15 */
+#endif /* VX1000_OLDA_AUDMBR_REG_ADDR) */
+#endif /* VX1000_SUPPRESS_TRACE_SUPPORT || !VX1000_OLDA_FORCE_V8 */
+
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 1) && defined(VX1000_MEMSYNC_TRIGGER_PTR)
+#error "VX1000_MEMSYNC_TRIGGER_PTR must NOT be defined by the user when VX1000_MEMSYNC_TRIGGER_COUNT > 1"
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT vs. VX1000_MEMSYNC_TRIGGER_PTR */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 1) && (!defined(VX1000_MEMSYNC_TRIGGER_PTR0))
+#error "VX1000_MEMSYNC_TRIGGER_PTR0 must be provided and point to 64 bytes unused RAM!"
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT vs. VX1000_MEMSYNC_TRIGGER_PTRx */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 1) && (!defined(VX1000_MEMSYNC_TRIGGER_PTR1))
+#error "VX1000_MEMSYNC_TRIGGER_PTR1 must be provided and point to 64 bytes unused RAM!"
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT vs. VX1000_MEMSYNC_TRIGGER_PTRx */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 2) && (!defined(VX1000_MEMSYNC_TRIGGER_PTR2))
+#error "VX1000_MEMSYNC_TRIGGER_PTR2 must be provided and point to 64 bytes unused RAM!"
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT vs. VX1000_MEMSYNC_TRIGGER_PTRx */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 3) && (!defined(VX1000_MEMSYNC_TRIGGER_PTR3))
+#error "VX1000_MEMSYNC_TRIGGER_PTR3 must be provided and point to 64 bytes unused RAM!"
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT vs. VX1000_MEMSYNC_TRIGGER_PTRx */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 4) && (!defined(VX1000_MEMSYNC_TRIGGER_PTR4))
+#error "VX1000_MEMSYNC_TRIGGER_PTR4 must be provided and point to 64 bytes unused RAM!"
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT vs. VX1000_MEMSYNC_TRIGGER_PTRx */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 5) && (!defined(VX1000_MEMSYNC_TRIGGER_PTR5))
+#error "VX1000_MEMSYNC_TRIGGER_PTR5 must be provided and point to 64 bytes unused RAM!"
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT vs. VX1000_MEMSYNC_TRIGGER_PTRx */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 6) && (!defined(VX1000_MEMSYNC_TRIGGER_PTR6))
+#error "VX1000_MEMSYNC_TRIGGER_PTR6 must be provided and point to 64 bytes unused RAM!"
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT vs. VX1000_MEMSYNC_TRIGGER_PTRx */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 7) && (!defined(VX1000_MEMSYNC_TRIGGER_PTR7))
+#error "VX1000_MEMSYNC_TRIGGER_PTR7 must be provided and point to 64 bytes unused RAM!"
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT vs. VX1000_MEMSYNC_TRIGGER_PTRx */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 8)
+#error "VX1000_MEMSYNC_TRIGGER_COUNT configured too big (max. 8 is allowed)!"
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 7 */
+
+#if (defined(VX1000_SUPPORT_OLDA8CMD_CP64N) && defined(VX1000_OLDA_FORCE_V8)) && (!defined(VX1000_UINT64))
+#error VX1000_SUPPORT_OLDA8CMD_CP64N cannot be enabled while VX1000_UINT64 is not provided!
+#endif /* VX1000_SUPPORT_OLDA8CMD_CP64N && VX1000_OLDA_FORCE_V8 && !VX1000_UINT64 */
+
+#if defined(VX1000_HOOK_BASED_BYPASSING) && (!defined(VX1000_STIM_BY_OLDA))
+#error VX1000_HOOK_BASED_BYPASSING cannot be enabled while VX1000_STIM_BY_OLDA is disabled!
+#endif /* VX1000_HOOK_BASED_BYPASSING && !VX1000_STIM_BY_OLDA */
+
+#if defined(VX1000_HOOK_BASED_BYPASSING) && (!defined(VX1000_BYPASS_HBB_LUT_ENTRIES))
+#error VX1000_BYPASS_HBB_LUT_ENTRIES must be defined to a value >0 if VX1000_HOOK_BASED_BYPASSING shall be used!
+#endif /* VX1000_HOOK_BASED_BYPASSING && !VX1000_BYPASS_HBB_LUT_ENTRIES */
+
+#if defined(VX1000_HOOK_BASED_BYPASSING) && (!defined(VX1000_BYPASS_HBB_LUT_ADDR))
+#error VX1000_BYPASS_HBB_LUT_ADDR must be defined if VX1000_HOOK_BASED_BYPASSING shall be used!
+#endif /* VX1000_HOOK_BASED_BYPASSING && !VX1000_BYPASS_HBB_LUT_ADDR */
+
+#if defined(VX1000_HOOK_BASED_BYPASSING) && (!defined(VX1000_STIM_FORCE_V1))
+#error VX1000_HOOK_BASED_BYPASSING cannot be enabled while VX1000_STIM_FORCE_V1 is disabled!
+#endif /* VX1000_HOOK_BASED_BYPASSING && !VX1000_STIM_FORCE_V1 */
+
+#if defined(VX1000_BYPASS_ALL_CHANS_STIMD) && (!defined(VX1000_STIM_FORCE_V1))
+#error VX1000_BYPASS_ALL_CHANS_STIMD cannot be enabled while VX1000_STIM_FORCE_V1 is disabled!
+#endif /* VX1000_BYPASS_ALL_CHANS_STIMD && !VX1000_STIM_FORCE_V1 */
+
+#if defined(VX1000_STIM_FORCE_V1) && (!defined(VX1000_SET_STIM_INFO))
+#error VX1000_SET_STIM_INFO() must be defined properly when VX1000_STIM_FORCE_V1 is enabled!
+#endif /* VX1000_STIM_FORCE_V1 && !VX1000_SET_STIM_INFO */
+
+#if defined(VX1000_OVERLAY)
+
+#if (defined(VX1000_INIT_CAL_PAGE) && defined(VX1000_GET_CAL_PAGE)) && (defined(VX1000_SET_CAL_PAGE) && defined(VX1000_COPY_CAL_PAGE))
+#define VX1000_OVERLAY_USERMANAGED
+#endif /* VX1000_INIT_CAL_PAGE && VX1000_GET_CAL_PAGE && VX1000_SET_CAL_PAGE && VX1000_COPY_CAL_PAGE */
+
+#if ((defined(VX1000_OVLENBL_SYNC_PAGESWITCH) || defined(VX1000_OVLENBL_CORE_SYNC_PAGESW)) && defined(VX1000_OVERLAY_USERMANAGED))
+#error User-defined overlay handling callbacks cannot be used in conjunction with (core-) synchronous page switching
+#endif /* (VX1000_OVLENBL_SYNC_PAGESWITCH || VX1000_OVLENBL_CORE_SYNC_PAGESW) && VX1000_OVERLAY_USERMANAGED */
+
+#if defined(VX1000_OVERLAY_VX_CONFIGURABLE) && (defined(VX1000_OVERLAY_USERMANAGED))
+#error VX1000_xxx_CAL_PAGE() user callbacks will NOT be executed because VX1000_OVERLAY_VX_CONFIGURABLE is enabled
+#endif /* VX1000_OVERLAY_VX_CONFIGURABLE & VX1000_OVERLAY_USERMANAGED */
+
+#if defined(VX1000_TARGET_POWERPC)
+
+#if defined(VX1000_OVERLAY_VX_CONFIGURABLE) && (defined(VX1000_OVERLAY_TLB) || defined(VX1000_OVERLAY_DESCR_IDX))
+#error VX1000_OVERLAY_VX_CONFIGURABLE cannot be enabled while VX1000_OVERLAY_TLB or VX1000_OVERLAY_DESCR_IDX is enabled
+#endif /* VX1000_OVERLAY_VX_CONFIGURABLE && (VX1000_OVERLAY_TLB || VX1000_OVERLAY_DESCR_IDX) */
+
+#if defined(VX1000_OVERLAY_USERMANAGED) && defined(VX1000_OVERLAY_TLB)
+#error VX1000_xxx_CAL_PAGE() user callbacks will NOT be executed because VX1000_OVERLAY_TLB is enabled
+#endif /* VX1000_OVERLAY_USERMANAGED & VX1000_OVERLAY_TLB */
+
+#if defined(VX1000_OVERLAY_USERMANAGED) && (defined(VX1000_OVERLAY_DESCR_IDX))
+#error VX1000_xxx_CAL_PAGE() user callbacks will NOT be executed because VX1000_OVERLAY_DESCR_IDX is enabled
+#endif /* VX1000_OVERLAY_USERMANAGED & VX1000_OVERLAY_DESCR_IDX */
+
+#if ((!defined(VX1000_OVERLAY_TLB)) && (!defined(VX1000_OVERLAY_DESCR_IDX)) && (!defined(VX1000_MPC56xCRAM_BASE_ADDR)) && (!defined(VX1000_OVERLAY_VX_CONFIGURABLE))) && (!defined(VX1000_OVERLAY_USERMANAGED))
+#error To use VX1000_OVERLAY, configure VX1000_MPC56xCRAM_BASE_ADDR, VX1000_OVERLAY_TLB, VX1000_OVERLAY_DESCR_IDX or VX1000_OVERLAY_VX_CONFIGURABLE or all VX1000_xxx_CAL_PAGE() macros in VX1000_cfg.h !
+#endif /* !VX1000_OVERLAY_TLB & !VX1000_OVERLAY_DESCR_IDX & !VX1000_MPC56xCRAM_BASE_ADDR & !VX1000_OVERLAY_VX_CONFIGURABLE && !VX1000_OVERLAY_USERMANAGED */
+
+#endif /* VX1000_TARGET_POWERPC */
+
+#if defined(VX1000_TARGET_TRICORE)
+
+#if defined(VX1000_OVERLAY_VX_CONFIGURABLE) && (defined(VX1000_OVERLAY_DESCR_IDX))
+#error VX1000_OVERLAY_VX_CONFIGURABLE cannot be enabled while VX1000_OVERLAY_DESCR_IDX is enabled
+#endif /* VX1000_OVERLAY_VX_CONFIGURABLE & VX1000_OVERLAY_DESCR_IDX */
+
+#if ( (!defined(VX1000_OVERLAY_DESCR_IDX)) && (!defined(VX1000_OVERLAY_VX_CONFIGURABLE)) ) && (!defined(VX1000_OVERLAY_USERMANAGED))
+#error To use VX1000_OVERLAY, configure VX1000_OVERLAY_DESCR_IDX or VX1000_OVERLAY_VX_CONFIGURABLE or all VX1000_xxx_CAL_PAGE() macros in VX1000_cfg.h !
+#endif /* !VX1000_OVERLAY_DESCR_IDX && !VX1000_OVERLAY_VX_CONFIGURABLE && !VX1000_OVERLAY_USERMANAGED */
+
+#if defined(VX1000_OVERLAY_USERMANAGED) && (defined(VX1000_OVERLAY_DESCR_IDX))
+#error VX1000_xxx_CAL_PAGE() user callbacks will NOT be executed because VX1000_OVERLAY_DESCR_IDX is enabled
+#endif /* VX1000_OVERLAY_USERMANAGED & VX1000_OVERLAY_DESCR_IDX */
+
+#endif /* VX1000_TARGET_TRICORE */
+
+#if defined(VX1000_TARGET_SH2)
+
+#if defined(VX1000_OVERLAY_USERMANAGED) && (defined(VX1000_SH2_FCU_BASE_ADDR))
+#error VX1000_xxx_CAL_PAGE() user callbacks will NOT be executed because VX1000_SH2_FCU_BASE_ADDR is enabled
+#endif /* VX1000_OVERLAY_USERMANAGED & VX1000_SH2_FCU_BASE_ADDR */
+
+#if ( (!defined(VX1000_SH2_FCU_BASE_ADDR)) && (!defined(VX1000_OVERLAY_VX_CONFIGURABLE)) ) && (!defined(VX1000_OVERLAY_USERMANAGED))
+#error To use VX1000_OVERLAY, configure VX1000_SH2_FCU_BASE_ADDR or VX1000_OVERLAY_VX_CONFIGURABLE or all VX1000_xxx_CAL_PAGE() macros in VX1000_cfg.h !
+#endif /* !VX1000_SH2_FCU_BASE_ADDR && !VX1000_OVERLAY_VX_CONFIGURABLE && !VX1000_OVERLAY_USERMANAGED */
+
+#endif /* VX1000_TARGET_SH2 */
+
+#if defined(VX1000_TARGET_X850)
+
+#if (!defined(VX1000_OVERLAY_VX_CONFIGURABLE)) && (!defined(VX1000_OVERLAY_USERMANAGED))
+#error To use VX1000_OVERLAY, configure VX1000_OVERLAY_VX_CONFIGURABLE or all VX1000_xxx_CAL_PAGE() macros in VX1000_cfg.h !
+#endif /* !VX1000_OVERLAY_VX_CONFIGURABLE && !VX1000_OVERLAY_USERMANAGED */
+
+#endif /* VX1000_TARGET_X850 */
+
+#if defined(VX1000_TARGET_TMS570)
+
+#if (!defined(VX1000_OVERLAY_VX_CONFIGURABLE)) && (!defined(VX1000_OVERLAY_USERMANAGED))
+#error To use VX1000_OVERLAY, configure VX1000_OVERLAY_VX_CONFIGURABLE or all VX1000_xxx_CAL_PAGE() macros in VX1000_cfg.h !
+#endif /* !VX1000_OVERLAY_VX_CONFIGURABLE && !VX1000_OVERLAY_USERMANAGED */
+
+#endif /* VX1000_TARGET_TMS570 */
+
+#if defined(VX1000_TARGET_XC2000)
+
+#if (!defined(VX1000_OVERLAY_VX_CONFIGURABLE)) && (!defined(VX1000_OVERLAY_USERMANAGED))
+#error To use VX1000_OVERLAY, configure VX1000_OVERLAY_VX_CONFIGURABLE or all VX1000_xxx_CAL_PAGE() macros in VX1000_cfg.h !
+#endif /* !VX1000_OVERLAY_VX_CONFIGURABLE && !VX1000_OVERLAY_USERMANAGED */
+
+#endif /* VX1000_TARGET_XC2000 */
+
+#if (!defined(VX1000_OVERLAY_VX_CONFIGURABLE)) && (!defined(VX1000_OVERLAY_USERMANAGED))
+
+/* check completeness of the common settings */
+#if ((!defined(VX1000_OVERLAY_ADDR)) || (!defined(VX1000_OVERLAY_SIZE)) || (!defined(VX1000_CALRAM_ADDR)) )
+#error Please define the overlay parameters VX1000_OVERLAY_SIZE, VX1000_OVERLAY_ADDR and VX1000_CALRAM_ADDR in VX1000_cfg.h !
+#endif /* !VX1000_OVERLAY_ADDR | !VX1000_OVERLAY_SIZE | !VX1000_CALRAM_ADDR */
+
+#if defined(VX1000_TARGET_POWERPC)
+
+/* check completeness of the settings for the MMU method */
+#if defined(VX1000_OVERLAY_TLB)
+#if !(defined(VX1000_MPC_MMU_MTMAS0)&&defined(VX1000_MPC_MMU_MTMAS1)&&defined(VX1000_MPC_MMU_MTMAS2)&&defined(VX1000_MPC_MMU_MTMAS3))
+#error VX1000_MPC_MMU_MTMASxx() must be defined for your compiler in VX1000_cfg.h
+#endif /* VX1000_MPC_MMU_MTMAS** */
+#if !defined(VX1000_MPC_MMU_TLBWE)
+#error VX1000_MPC_MMU_TLBWE() must be defined for your compiler in VX1000_cfg.h
+#endif /* !VX1000_MPC_MMU_TLBWE */
+#endif /* VX1000_OVERLAY_TLB */
+
+/* check completeness of the settings for the flash port method */
+#if defined(VX1000_OVERLAY_DESCR_IDX) && (!defined(VX1000_FLASHPORTCTLR_BASE_ADDR))
+#error Please define the overlay parameters VX1000_FLASHPORTCTLR_BASE_ADDR in VX1000_cfg.h !
+#endif /* VX1000_OVERLAY_DESCR_IDX && !VX1000_FLASHPORTCTLR_BASE_ADDR */
+
+#endif /* VX1000_TARGET_POWERPC */
+
+#if defined(VX1000_TARGET_XC2000)
+
+/* check completeness of the common settings */
+#if ((!defined(VX1000_OVERLAY_ADDR)) || (!defined(VX1000_OVERLAY_SIZE)) || (!defined(VX1000_CALRAM_ADDR)) )
+#error Please define the overlay parameters VX1000_OVERLAY_SIZE, VX1000_OVERLAY_ADDR and VX1000_CALRAM_ADDR in VX1000_cfg.h !
+#endif /* !VX1000_OVERLAY_ADDR | !VX1000_OVERLAY_SIZE | !VX1000_CALRAM_ADDR */
+
+#endif /* VX1000_TARGET_XC2000 */
+
+#endif /* !VX1000_OVERLAY_VX_CONFIGURABLE && !VX1000_OVERLAY_USERMANAGED */
+
+#endif /* VX1000_OVERLAY */
+
+#if defined(VX1000_OVLENBL_USE_VX_EPK_TRANS) && (!defined(VX1000_OVLENBL_VALIDATE_PAGESW))
+#error VX1000_OVLENBL_USE_VX_EPK_TRANS cannot be enabled while VX1000_OVLENBL_VALIDATE_PAGESW is disabled!
+#endif /* VX1000_OVLENBL_USE_VX_EPK_TRANS & !VX1000_OVLENBL_VALIDATE_PAGESW */
+
+#if defined(VX1000_OVLENBL_USE_VX_EPK_TRANS) && (!defined(VX1000_SYNCAL_VALIDATE_WP_CB))
+#error VX1000_SYNCAL_VALIDATE_WP_CB must be configured to be able to use the EPK translation!
+#endif /* VX1000_OVLENBL_USE_VX_EPK_TRANS & !VX1000_OVLENBL_USE_VX_EPK_TRANS */
+
+#if defined(VX1000_OVLENBL_USE_VX_EPK_TRANS) && (!defined(VX1000_OVL_EPK_REFPAGE_ADDR))
+#error VX1000_OVL_EPK_REFPAGE_ADDR must be configured to be able to use the EPK translation!
+#endif /* VX1000_OVLENBL_USE_VX_EPK_TRANS & !VX1000_OVL_EPK_REFPAGE_ADDR */
+
+#if defined(VX1000_OVLENBL_USE_VX_EPK_TRANS) && (!defined(VX1000_OVL_EPK_LENGTH))
+#error VX1000_OVL_EPK_LENGTH must be configured to be able to use the EPK translation!
+#endif /* VX1000_OVLENBL_USE_VX_EPK_TRANS & !VX1000_OVL_EPK_LENGTH */
+
+#if defined(VX1000_OVLENBL_VALIDATE_PAGESW) && (!(defined(VX1000_SYNCAL_USRVALIDATE_WP_CB) || defined(VX1000_OVLENBL_USE_VX_EPK_TRANS)))
+#error VX1000_OVLENBL_VALIDATE_PAGESW cannot be enabled while neither VX1000_SYNCAL_USRVALIDATE_WP_CB nor EPK translation are configured!
+#endif /* VX1000_OVLENBL_VALIDATE_PAGESW & !VX1000_SYNCAL_USRVALIDATE_WP_CB & !VX1000_OVLENBL_USE_VX_EPK_TRANS */
+
+#if defined(VX1000_OVLENBL_CORE_SYNC_PAGESW) && (!defined(VX1000_OVL_CAL_BUS_MASTER))
+#error VX1000_OVLENBL_CORE_SYNC_PAGESW cannot be enabled while VX1000_OVL_CAL_BUS_MASTER is not configured!
+#endif /* VX1000_OVLENBL_CORE_SYNC_PAGESW & !VX1000_OVL_CAL_BUS_MASTER */
+
+#if defined(VX1000_OVLENBL_SYNC_PAGESWITCH) && (!defined(VX1000_OVL_CAL_BUS_MASTER))
+#error VX1000_OVLENBL_SYNC_PAGESWITCH cannot be enabled while VX1000_OVL_CAL_BUS_MASTER is not configured!
+#endif /* VX1000_OVLENBL_SYNC_PAGESWITCH & !VX1000_OVL_CAL_BUS_MASTER */
+
+#if defined(VX1000_OVLENBL_CORE_SYNC_PAGESW) && (!defined(VX1000_OVLENBL_SYNC_PAGESWITCH))
+#error VX1000_OVLENBL_CORE_SYNC_PAGESW cannot be used without VX1000_OVLENBL_SYNC_PAGESWITCH!
+#endif /* VX1000_OVLENBL_CORE_SYNC_PAGESW & !VX1000_OVLENBL_SYNC_PAGESWITCH */
+
+#if defined(VX1000_OVLENBL_RST_ON_CALWAKEUP) && (!defined(VX1000_OVL_RST_ON_CAL_WAKEUP_CB))
+#error VX1000_OVL_RST_ON_CAL_WAKEUP_CB() must be configured because VX1000_OVLENBL_RST_ON_CALWAKEUP is enabled!
+#endif /* VX1000_OVLENBL_RST_ON_CALWAKEUP & !VX1000_OVL_RST_ON_CAL_WAKEUP_CB */
+
+#if defined(VX1000_MAILBOX) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+#if (VX1000_MAILBOX_SLOT_DWORDS) < 3U
+#error VX1000_MAILBOX_SLOT_DWORDS must be at least 3 ! /* 4 bytes + 8 bytes xcp command = 12bytes = 3 dwords */
+#endif /* VX1000_MAILBOX_SLOT_DWORDS */
+#if (VX1000_MAILBOX_SLOTS < 1U) || (((VX1000_MAILBOX_SLOTS) & ((VX1000_MAILBOX_SLOTS) - 1U)) != 0U)
+#error VX1000_MAILBOX_SLOTS must be a power of 2 !
+#endif /* VX1000_MAILBOX_SLOTS */
+#endif /* VX1000_MAILBOX & ! VX1000_COMPILED_FOR_SLAVECORES */
+
+#if (defined(VX1000_DETECTION) && defined(VX1000_OLDA)) && (defined(VX1000_OLDA_FORCE_V6))
+/* The coldstart settings in VxConfig lack the "SwapValue" field, therefore VX can only handle address encodings that are not based on swapValue -> only v7 encoding possible */
+#error Coldstart/VX1000Detection is incompatible to olda v6 --> either disable VX1000_DETECTION or VX1000_OLDA_FORCE_V6!
+#endif /* VX1000_DETECTION && VX1000_OLDA_FORCE_V6 */
+
+#if (!defined(VX1000_MEMSYNC_TRIGGER_COUNT)) || ((VX1000_MEMSYNC_TRIGGER_COUNT) == 0)
+#if defined(VX1000_MEMSYNC_COPY_COUNT)
+#if ((VX1000_MEMSYNC_COPY_COUNT) > 0)
+#error VX1000_MEMSYNC_COPY_COUNT cannot be defined > 0 unless VX1000_MEMSYNC_TRIGGER_COUNT is defined > 0, too!
+#endif /* VX1000_MEMSYNC_COPY_COUNT > 0*/
+#endif /* VX1000_MEMSYNC_COPY_COUNT */
+#endif /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+
+#if defined(VX1000_OLDA_BENCHMARK)
+#if ((VX1000_OLDA_BENCHMARK_CNT) == 0U)
+#error VX1000_OLDA_BENCHMARK_CNT must be defined greater than zero when VX1000_OLDA_BENCHMARK is enabled!
+#endif /* !VX1000_OLDA_BENCHMARK_CNT */
+#endif /* VX1000_OLDA_BENCHMARK */
+
+#if defined(VX1000_LFAST_BASEADDR) && (!defined(VX1000_SIPI_CLK_TXN_TXP_RXN_RXP))
+#error Please define VX1000_SIPI_CLK_TXN_TXP_RXN_RXP() to C code that enables the 5 LFAST pins as clock out plus 2 LVDS pairs.
+#endif /* VX1000_LFAST_BASEADDR & !VX1000_SIPI_CLK_TXN_TXP_RXN_RXP */
+
+#endif /* !VX1000_DISABLE_INSTRUMENTATION */
+
+/* States */
+
+/* ToolDetectState */
+#define VX1000_TDS_INIT                  0x00000001UL    /* VX1000_INIT() has been called */
+#define VX1000_TDS_DETECT                0x00000002UL    /* VX1000_DETECT_VX() has been called */
+#define VX1000_TDS_DETECTED              0x00000004UL    /* VX1000 was detected by VX1000_DETECT_VX() */
+#define VX1000_TDS_COLDSTART_DELAY_REQ   0x00000008UL    /* Coldstart delay request has been accepted by VX */
+#define VX1000_TDS_COLDSTART_DONE        0x00000010UL    /* Coldstart handshake successfully executed */
+#define VX1000_TDS_COLDSTART_TIMEOUT     0x00000020UL    /* Coldstart handshake resulted in timeout */
+#define VX1000_TDS_COLDSTART_DELAY       0x00000040UL    /* Coldstart Delay has been entered */
+#define VX1000_TDS_APPRST                0x00000080UL    /* Resume after application reset done */
+#define VX1000_TDS_FKL_REQ_DETECTED      0x00000100UL    /* FlashPrepare request detected: trying to handle it */
+#define VX1000_TDS_FKL_REQ_IGNORED       0x00000200UL    /* FlashPrepare request could not be served right now; app still runs */
+#define VX1000_TDS_FKL_FORCED_IDLE       0x00000400UL    /* request served: ECU stays idle; FKL can be downloaded by the tool; */
+                                                         /* gVX1000.MagicId contains a pointer to the new communication space. */
+#define VX1000_TDS_DETECT_DONE           0x00000800UL    /* VX1000 Tooldetection sequence finished */
+#define VX1000_TDS_ERROR                 0x00001000UL    /* VX1000_INIT() detected a misconfiguration */
+#define VX1000_TDS_VX_ACCESS_DISABLED    0x00002000UL    /* The VX has NO access to the ECU, another tool is connected */
+#define VX1000_TDS_WORKING_PAGE          0x00004000UL    /* 0: ECU is on reference page / 1: ECU is on working page */
+
+#define VX1000_TDS_COLDSTART_CHS_BUSY    0x00010000UL    /* Coldstart checksum calculation ongoing */
+#define VX1000_TDS_COLDSTART_CHS_DONE    0x00020000UL    /* Coldstart checksum calculation done */
+
+#define VX1000_TDS_NO_BYP_RESUME         0x00040000UL    /* Inform VX1000 not to resume VX bypassing */
+
+/* ToolCtrlState */
+#define VX1000_TCS_PRESENT               0x00000001UL    /* VX1000 is present */
+#define VX1000_TCS_COLDSTART_DELAY       0x00000002UL    /* VX1000 requests coldstart delay */
+#define VX1000_TCS_COLDSTART_DONE        0x00000004UL    /* VX1000 coldstart configuration done */
+#define VX1000_TCS_FKL_REQUEST           0x00000008UL    /* VX1000 requests the appl to go idle and prepare to jump to a pointer */
+#define VX1000_TCS_SOFTRESET_PREP        0x00000010UL    /* VX1000 acknowledges a soft-reset announcement */
+#define VX1000_TCS_SWITCH_TO_WP          0x00000020UL    /* Tell the ECU to switch to WP */
+#define VX1000_TCS_CAL_WAKEUP            0x00000040UL    /* The VX1000 has woken up the ECU */
+#define VX1000_TCS_SKIP_WP_INIT          0x00000080UL    /* Inform the ECU that the WP\'s RAM content is still intact */
+
+
+/*------------------------------------------------------------------------------ */
+/* VX1000 Detection                                                              */
+
+#if defined(VX1000_DETECTION) || (defined(VX1000_TARGET_TRICORE) && (!defined(VX1000_DISABLE_INSTRUMENTATION)))
+/* Check whether a VX1000 was already detected by VX1000_DETECT_VX() */
+/*#define VX1000_DETECTED()   ((gVX1000.ToolCtrlState  & (VX1000_TDS_DETECTED)) != 0) //really "Ctrl & TDS"? and not #define VX1000_DETECTED() ((gVX1000.ToolDetectState & (VX1000_TDS_DETECTED)) != 0)*/
+#define VX1000_DETECTED() (((gVX1000.ToolCtrlState & (VX1000_TCS_PRESENT)) != 0UL) || ((gVX1000.ToolDetectState & (VX1000_TDS_DETECTED)) != 0UL)) /* Wrapper API:   VX1000If_DeviceDetected */
+#else /* !VX1000_DETECTION & !VX1000_TARGET_TRICORE | VX1000_DISABLE_INSTRUMENTATION */
+#define VX1000_DETECTED()                (0)             /* means "no VX detected" */
+#endif /* !VX1000_DETECTION & !VX1000_TARGET_TRICORE | VX1000_DISABLE_INSTRUMENTATION */
+
+
+/*------------------------------------------------------------------------------ */
+/* Coldstart                                                                     */
+
+#define VX1000_COLDSTART_CHS_MAGIC 0xFEC70A09UL
+#if (defined(VX1000_DETECTION) || (defined(VX1000_TARGET_TRICORE) && (!defined(VX1000_DISABLE_INSTRUMENTATION)))) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+extern volatile VX1000_UINT32 gVX1000_DETECT_StartTime;
+#if defined(VX1000_COLDSTART_BENCHMARK) && defined(VX1000_OLDA)
+extern volatile VX1000_UINT32 gVX1000_DETECT_StartTimeAsyncEnd, gVX1000_DETECT_ToolDetectTime, gVX1000_DETECT_ChecksumDoneTime, gVX1000_DETECT_EndTimeAsyncStart, gVX1000_DETECT_EndTime;
+#define VX1000_COLDSTART_BENCHMARK_DATA volatile VX1000_UINT32 gVX1000_DETECT_StartTime, gVX1000_DETECT_StartTimeAsyncEnd, gVX1000_DETECT_ToolDetectTime, gVX1000_DETECT_ChecksumDoneTime, gVX1000_DETECT_EndTimeAsyncStart, gVX1000_DETECT_EndTime
+#else /* !VX1000_COLDSTART_BENCHMARK || !VX1000_OLDA*/
+#define VX1000_COLDSTART_BENCHMARK_DATA volatile VX1000_UINT32 gVX1000_DETECT_StartTime
+#endif /* !VX1000_COLDSTART_BENCHMARK || !VX1000_OLDA*/
+#else  /* (!VX1000_DETECTION & !VX1000_TARGET_TRICORE) | VX1000_DISABLE_INSTRUMENTATION | VX1000_COMPILED_FOR_SLAVECORES */
+#endif /* (!VX1000_DETECTION & !VX1000_TARGET_TRICORE) | VX1000_DISABLE_INSTRUMENTATION | VX1000_COMPILED_FOR_SLAVECORES */
+
+
+/*------------------------------------------------------------------------------ */
+/* Flash kernel download support                                                 */
+#if defined(VX1000_FKL_SUPPORT_ADDR)
+extern void VX1000_SUFFUN(vx1000_FlashPrepareLoop)(void);
+#define VX1000_DETECT_FKL_REQUESTS() do                                                                                         \\
+  {                                                                                                                             \\
+    if ((gVX1000.MagicId == (VX1000_UINT32)(VX1000_STRUCT_MAGIC)) && ((gVX1000.ToolCtrlState & (VX1000_TCS_FKL_REQUEST)) != 0)) \\
+    {                                                                                                                           \\
+      VX1000_SUFFUN(vx1000_FlashPrepareLoop)();                                                                                 \\
+    }                                                                                                                           \\
+  } while (0); /* This dummy loop is only here for MISRA */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+
+typedef void VX1000_FKL_FCT(VX1000_UINT32, VX1000_UINT32, VX1000_UINT32); /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+typedef struct
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 DeprotectTrigger;        /*  0+ */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 DeprotectState;          /*  2+ */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 TransitionTimeout;       /*  4+ */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 WdgData1;                /*  8+ */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 WdgData2;                /* 12+ */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 WdgData3_FklParam3;      /* 16+ */ /* it depends on the platform whether the watchdog handler or the kernel needs more parameters */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 FklParam1;               /* 20+ */
+  VX1000_FKL_FCT * VX1000_INNERSTRUCT_VOLATILE EntryPoint;           /* 24+ */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 FklParam2;               /* 28+ */
+} VX1000_FKL_WORKSPACE_T;              /* PRQA S 3205 */ /* Accepting to define a type that might be unused in some users\' configurations/applications */
+#define VX1000_FKL_WORKSPACE           (VX1000_ADDR_TO_PTR2FW(0xFFFFffe0UL & (VX1000_UINT32)(VX1000_FKL_SUPPORT_ADDR)))
+#define VX1000_FKL_TRANSITION_TIMEOUT  0xffffffffUL
+#define VX1000_FKL_STATE1CODE          0x1243U
+#define VX1000_FKL_STATE2CODE          0x2486U
+#define VX1000_FKL_STATE3CODE          0x36c9U
+#define VX1000_FKL_STATE4CODE          0x480cU
+#define VX1000_FKL_STATE5CODE          0x5a4fU
+#define VX1000_FKL_TOSTATE1CODE        0x6bf0U
+#define VX1000_FKL_TOSTATE2CODE        0x7a0fU
+#define VX1000_FKL_TOSTATE3CODE        0x891eU
+#define VX1000_FKL_TOSTATE4CODE        0x98e1U
+#define VX1000_FKL_TOSTATE5CODE        0xa72dU
+#define VX1000_FKL_LAUNCHCODE          0xb6d2U
+#else  /* !VX1000_FKL_SUPPORT_ADDR */
+#if defined(VX1000_DISABLE_INSTRUMENTATION)
+#define VX1000_DETECT_FKL_REQUESTS()   /* empty */
+#else /* !VX1000_DISABLE_INSTRUMENTATION)*/
+#define VX1000_DETECT_FKL_REQUESTS() do                                                        \\
+{                                                                                              \\
+  if ((gVX1000.ToolCtrlState & (VX1000_TCS_FKL_REQUEST)) != 0)                                 \\
+  {                                                                                            \\
+    gVX1000.ToolDetectState |= (VX1000_TDS_FKL_REQ_DETECTED) | (VX1000_TDS_FKL_REQ_IGNORED);   \\
+  }                                                                                            \\
+} while (0);  /* This dummy loop is only here for MISRA */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#endif /* !VX1000_DISABLE_INSTRUMENTATION */
+#endif /* !VX1000_FKL_SUPPORT_ADDR */
+
+
+/*------------------------------------------------------------------------------ */
+/* VX1000 Mailbox                                                                */
+
+#define VX1000_MAILBOX_OK              0UL
+#define VX1000_MAILBOX_ERR_FULL        1UL
+#define VX1000_MAILBOX_ERR_EMPTY       2UL
+#define VX1000_MAILBOX_ERR_INDICES     3UL
+#define VX1000_MAILBOX_ERR_SEQUENCE    4UL
+#define VX1000_MAILBOX_ERR_SIZE        5UL
+#define VX1000_MAILBOX_SLOT_RSVD       6UL
+#define VX1000_MAILBOX_ERR_NULL        7UL
+#define VX1000_MAILBOX_ERR_SPLIT_PEND  8UL
+
+#define VX1000_CRC_CMD_UNKNOWN         0x20U
+#define VX1000_CRC_CMD_BUSY            0x10U
+#define VX1000_CRC_CMD_SYNTAX          0x21U
+#define VX1000_CRC_OUT_OF_RANGE        0x22U
+#define VX1000_CRC_WRITE_PROTECTED     0x23U
+#define VX1000_CRC_ACCESS_DENIED       0x24U
+#define VX1000_CRC_ACCESS_LOCKED       0x25U
+#define VX1000_CRC_PAGE_NOT_VALID      0x26U
+#define VX1000_CRC_PAGE_MODE_NOT_VALID 0x27U
+#define VX1000_CRC_SEGMENT_NOT_VALID   0x28U
+
+#define VX1000_CAL_ECU                 0x01U
+#define VX1000_CAL_XCP                 0x02U
+#define VX1000_CAL_ALL                 0x80U
+
+#if defined(VX1000_MAILBOX) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+
+#define VX1000_MAILBOX_MAGIC           0xFEC70A06UL
+#define VX1000_MAILBOX_FREE_WR_SLOTS   (((VX1000_UINT8)(gVX1000.Mailbox.SM_ReadIdx-gVX1000.Mailbox.SM_WriteIdx-1)) & ((VX1000_MAILBOX_SLOTS)-1U))
+#define VX1000_MAILBOX_USED_RD_SLOTS   (((VX1000_UINT32)(gVX1000.Mailbox.MS_WriteIdx - gVX1000.Mailbox.MS_ReadIdx)) & ((VX1000_MAILBOX_SLOTS) - 1U))
+#define VX1000_MAILBOX_NEXT(idx)       (((idx) + 1U) & ((VX1000_MAILBOX_SLOTS) - 1U))  /* PRQA S 3453 */ /* Accepting violation of MISRA rule 19.7 because a function call would consume unnecessarily high resources */
+
+typedef struct
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32  MagicId;       /* 0x00 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32  Version;       /* 0x04 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16  SlotSize;      /* 0x08 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8   MS_Slots;      /* 0x0A */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8   SM_Slots;      /* 0x0B */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32  MS_Ptr;        /* 0x0C */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32  SM_Ptr;        /* 0x10 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8   MS_ReadIdx;    /* 0x14 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8   MS_WriteIdx;   /* 0x15 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8   SM_ReadIdx;    /* 0x16 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8   SM_WriteIdx;   /* 0x17 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16  RstReq;        /* 0x18 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16  RstAck;        /* 0x1A */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32  MSData[VX1000_MAILBOX_SLOTS][VX1000_MAILBOX_SLOT_DWORDS]; /* 0x1C */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32  SMData[VX1000_MAILBOX_SLOTS][VX1000_MAILBOX_SLOT_DWORDS]; /* no fix offset */
+} VX1000_MAILBOX_T;
+
+#if (defined(VX1000_MAILBOX_OVERLAY_CONTROL) || defined(VX1000_MAILBOX_FLASH)) || defined(VX1000_MAILBOX_CAL_READ_WRITE)
+extern void VX1000_SUFFUN(vx1000_MailboxHandler)(void);
+#define VX1000_MAILBOX_CONTROL() VX1000_SUFFUN(vx1000_MailboxHandler)(); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#else /* !VX1000_MAILBOX_OVERLAY_CONTROL & !VX1000_MAILBOX_FLASH & !VX1000_MAILBOX_CAL_READ_WRITE */
+#define VX1000_MAILBOX_CONTROL() /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#endif /* !VX1000_MAILBOX_OVERLAY_CONTROL & !VX1000_MAILBOX_FLASH & !VX1000_MAILBOX_CAL_READ_WRITE */
+extern VX1000_UINT32 VX1000_SUFFUN(vx1000_MailboxWrite)(VX1000_UINT32 len, const VX1000_CHAR * pBuf);
+#define VX1000_MAILBOX_WRITE(     L, B)       VX1000_SUFFUN(vx1000_MailboxWrite)((L), (const VX1000_CHAR*)(B))  /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_MAILBOX_WRITE_VOID(L, B) (void)VX1000_SUFFUN(vx1000_MailboxWrite)((L), (const VX1000_CHAR*)(B)); /* usable as a whole statement */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+extern VX1000_UINT32 VX1000_SUFFUN(vx1000_MailboxRead)(VX1000_UINT32 * pLen, VX1000_CHAR * pBuf);
+#define VX1000_MAILBOX_READ(     L, B)       VX1000_SUFFUN(vx1000_MailboxRead)((L), (B))  /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_MAILBOX_READ_VOID(L, B) (void)VX1000_SUFFUN(vx1000_MailboxRead)((L), (B)); /* usable as a whole statement */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#define VX1000_MAILBOX_DATA VX1000_MAILBOX_T Mailbox
+#define VX1000_MAILBOX_PTR             (VX1000_PTR2VM_TO_ADDRESS(&gVX1000.Mailbox))
+
+#else /* !VX1000_MAILBOX | VX1000_COMPILED_FOR_SLAVECORES */
+
+#define VX1000_MAILBOX_CONTROL()       /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_MAILBOX_WRITE(     L, B) VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(VX1000_MAILBOX_ERR_FULL), (L),((const VX1000_CHAR*)(B)-(const VX1000_CHAR*)(0)),(0),(0)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 0488 */ /* cannot avoid violating MISRA rule 17.4 because pointer arithmetic is the only simple way to cast qualified pointers to integers with only-level-4 violations */
+#define VX1000_MAILBOX_WRITE_VOID(L, B) VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(VX1000_MAILBOX_ERR_FULL), (L),((const VX1000_CHAR*)(B)-(const VX1000_CHAR*)(0)),(0),(0)))/* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 0488 */ /* cannot avoid violating MISRA rule 17.4 because pointer arithmetic is the only simple way to cast qualified pointers to integers with only-level-4 violations */
+#define VX1000_MAILBOX_READ(     L, B) VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(VX1000_MAILBOX_ERR_EMPTY), ((VX1000_UINT32*)(L)-(VX1000_UINT32*)(0)),((VX1000_CHAR*)(B)-(VX1000_CHAR*)(0)),(0),(0)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 0488 */ /* cannot avoid violating MISRA rule 17.4 because pointer arithmetic is the only simple way to cast qualified pointers to integers with only-level-4 violations */
+#define VX1000_MAILBOX_READ_VOID(L, B) VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(VX1000_MAILBOX_ERR_EMPTY), ((VX1000_UINT32*)(L)-(VX1000_UINT32*)(0)),((VX1000_CHAR*)(B)-(VX1000_CHAR*)(0)),(0),(0)))/* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 0488 */ /* cannot avoid violating MISRA rule 17.4 because pointer arithmetic is the only simple way to cast qualified pointers to integers with only-level-4 violations */
+#define VX1000_MAILBOX_PTR             0UL
+
+#endif /* !VX1000_MAILBOX | VX1000_COMPILED_FOR_SLAVECORES */
+
+#if (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_PROVIDE_SPLITWRITE)) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+extern VX1000_UINT32 VX1000_SUFFUN(vx1000_MailboxWriteDone)(VX1000_UINT32 len);
+#define VX1000_MAILBOX_WRITEDONE(      L)       VX1000_SUFFUN(vx1000_MailboxWriteDone)((L))           /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_MAILBOX_WRITEDONE_VOID( L) (void)VX1000_SUFFUN(vx1000_MailboxWriteDone)((L));          /* usable as a whole statement */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+extern VX1000_UINT32 VX1000_SUFFUN(vx1000_MailboxWriteSplit)(VX1000_UINT32 * * ppBuf);
+#define VX1000_MAILBOX_WRITESPLIT(     B)       VX1000_SUFFUN(vx1000_MailboxWriteSplit)((B))          /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_MAILBOX_WRITESPLIT_VOID(B) (void)VX1000_SUFFUN(vx1000_MailboxWriteSplit)((B));         /* usable as a whole statement */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#else /* !VX1000_MAILBOX || !VX1000_MAILBOX_PROVIDE_SPLITWRITE || VX1000_COMPILED_FOR_SLAVECORES */
+#define VX1000_MAILBOX_WRITEDONE(      L) VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(VX1000_MAILBOX_ERR_SIZE), (L),(0),(0),(0)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_MAILBOX_WRITEDONE_VOID( L) VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(VX1000_MAILBOX_ERR_SIZE), (L),(0),(0),(0))) /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_MAILBOX_WRITESPLIT(     B) VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(VX1000_MAILBOX_ERR_FULL), ((VX1000_UINT32**)(B)-(VX1000_UINT32**)(0)),(0),(0),(0)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 0488 */ /* cannot avoid violating MISRA rule 17.4 because pointer arithmetic is the only simple way to cast qualified pointers to integers with only-level-4 violations */
+#define VX1000_MAILBOX_WRITESPLIT_VOID(B) VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(VX1000_MAILBOX_ERR_FULL), ((VX1000_UINT32**)(B)-(VX1000_UINT32**)(0)),(0),(0),(0))) /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 0488 */ /* cannot avoid violating MISRA rule 17.4 because pointer arithmetic is the only simple way to cast qualified pointers to integers with only-level-4 violations */
+#endif /* !VX1000_MAILBOX || !VX1000_MAILBOX_PROVIDE_SPLITWRITE || VX1000_COMPILED_FOR_SLAVECORES */
+#if (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_PROVIDE_SPLITREAD)) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+extern VX1000_UINT32 VX1000_SUFFUN(vx1000_MailboxReadDone)(void);
+#define VX1000_MAILBOX_READDONE(     )       VX1000_SUFFUN(vx1000_MailboxReadDone)()                  /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_MAILBOX_READDONE_VOID() (void)VX1000_SUFFUN(vx1000_MailboxReadDone)();                 /* usable as a whole statement */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+extern VX1000_UINT32 VX1000_SUFFUN(vx1000_MailboxReadSplit)(VX1000_UINT32 * pLen, VX1000_UINT32 * * ppBuf);
+#define VX1000_MAILBOX_READSPLIT(     L, B)       VX1000_SUFFUN(vx1000_MailboxReadSplit)((L), (B))    /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_MAILBOX_READSPLIT_VOID(L, B) (void)VX1000_SUFFUN(vx1000_MailboxReadSplit)((L), (B));   /* usable as a whole statement */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#else /* !VX1000_MAILBOX || !VX1000_MAILBOX_PROVIDE_SPLITREAD || VX1000_COMPILED_FOR_SLAVECORES */
+#define VX1000_MAILBOX_READDONE(     ) (VX1000_MAILBOX_ERR_SPLIT_PEND) /* todo: find a better one */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_MAILBOX_READDONE_VOID() /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_MAILBOX_READSPLIT(     L, B) VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(VX1000_MAILBOX_ERR_EMPTY), ((VX1000_UINT32*)(L)-(VX1000_UINT32*)(0)),((VX1000_UINT32**)(B)-(VX1000_UINT32**)(0)),(0),(0)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 0488 */ /* cannot avoid violating MISRA rule 17.4 because pointer arithmetic is the only simple way to cast qualified pointers to integers with only-level-4 violations */
+#define VX1000_MAILBOX_READSPLIT_VOID(L, B) VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(VX1000_MAILBOX_ERR_EMPTY), ((VX1000_UINT32*)(L)-(VX1000_UINT32*)(0)),((VX1000_UINT32**)(B)-(VX1000_UINT32**)(0)),(0),(0)))/* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 0488 */ /* cannot avoid violating MISRA rule 17.4 because pointer arithmetic is the only simple way to cast qualified pointers to integers with only-level-4 violations */
+#endif /* !VX1000_MAILBOX || !VX1000_MAILBOX_PROVIDE_SPLITREAD || VX1000_COMPILED_FOR_SLAVECORES */
+#if (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_PRINTF)) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+void VX1000_SUFFUN(vx1000_MailboxPrintf)( const VX1000_CHAR *format, ... ); /* PRQA S 5069 */ /* Cannot avoid violating MISRA rule 16.1 because a C++-based workaround would only violate other rules */
+#define VX1000_PRINTF VX1000_SUFFUN(vx1000_MailboxPrintf)
+#else  /* !VX1000_MAILBOX || !VX1000_MAILBOX_PRINTF || VX1000_COMPILED_FOR_SLAVECORES */
+#define VX1000_PRINTF  (void)
+#endif /* !VX1000_MAILBOX || !VX1000_MAILBOX_PRINTF || VX1000_COMPILED_FOR_SLAVECORES */
+#if (defined(VX1000_OVERLAY) && (!defined(VX1000_COMPILED_FOR_SLAVECORES)))
+#if (defined(VX1000_INIT_CAL_PAGE)) && (!defined(VX1000_OVERLAY_VX_CONFIGURABLE))
+#endif /* VX1000_INIT_CAL_PAGE && !VX1000_OVERLAY_VX_CONFIGURABLE */
+#if (!defined(VX1000_INIT_CAL_PAGE)) && (!defined(VX1000_OVERLAY_VX_CONFIGURABLE))
+#define VX1000_INIT_CAL_PAGE_INTERNAL
+#endif /* !VX1000_INIT_CAL_PAGE & !VX1000_OVERLAY_VX_CONFIGURABLE */
+#endif /* VX1000_OVERLAY & !VX1000_COMPILED_FOR_SLAVECORES */
+#if ((!defined(VX1000_OVERLAY)) || ((defined(VX1000_COMPILED_FOR_SLAVECORES)) || defined(VX1000_OVERLAY_VX_CONFIGURABLE)))
+#endif /* !VX1000_OVERLAY | VX1000_COMPILED_FOR_SLAVECORES | VX1000_OVERLAY_VX_CONFIGURABLE */
+#if (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_OVERLAY_CONTROL)) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+#if !defined(VX1000_GET_CAL_PAGE)
+#define VX1000_GET_CAL_PAGE(seg, mod)  VX1000_SUFFUN(vx1000_GetCalPage)((VX1000_UINT8)(seg), (VX1000_UINT8)(mod)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to use reconfigurable API wrappers */
+#define VX1000_GET_CAL_PAGE_INTERNAL
+#endif /* !VX1000_GET_CAL_PAGE */
+#define VX1000_WRP_SET_CAL_PAGE(seg, pag, mod, stup) VX1000_SUFFUN(vx1000_SetCalPage)((VX1000_UINT8)(seg), (VX1000_UINT8)(pag), (VX1000_UINT8)(mod), (VX1000_UINT8)(stup)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to use reconfigurable API wrappers */
+#define VX1000_WRP_SET_CAL_PAGE_VOID(seg, pag, mod, stup) (void)VX1000_WRP_SET_CAL_PAGE((seg), (pag), (mod), (stup));  /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#if defined(VX1000_SET_CAL_PAGE)
+#define VX1000_SET_CAL_PAGE_EXTERNAL
+#else /* !VX1000_SET_CAL_PAGE */
+#define VX1000_SET_CAL_PAGE_INTERNAL
+#endif /* !VX1000_SET_CAL_PAGE */
+#else /* !VX1000_MAILBOX | !VX1000_MAILBOX_OVERLAY_CONTROL | VX1000_COMPILED_FOR_SLAVECORES */
+#define VX1000_WRP_SET_CAL_PAGE( seg, pag, mod, stup) VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,(VX1000_CRC_OUT_OF_RANGE), (seg), (pag), (mod), (stup))/* return code for "inactive" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_WRP_SET_CAL_PAGE_VOID(seg, pag, mod, stup) VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,(VX1000_CRC_OUT_OF_RANGE), (seg), (pag), (mod), (stup)))/* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#endif  /* !VX1000_MAILBOX | !VX1000_MAILBOX_OVERLAY_CONTROL | VX1000_COMPILED_FOR_SLAVECORES */
+#if (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_OVERLAY_CONTROL)) && ((!defined(VX1000_COMPILED_FOR_SLAVECORES)) && (!defined(VX1000_OVERLAY_VX_CONFIGURABLE)))
+#if !defined(VX1000_COPY_CAL_PAGE)
+#define VX1000_COPY_CAL_PAGE(sseg, spag, dseg, dpag) VX1000_SUFFUN(vx1000_CopyCalPage)((VX1000_UINT8)(sseg), (VX1000_UINT8)(spag), (VX1000_UINT8)(dseg), (VX1000_UINT8)(dpag)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to use reconfigurable API wrappers */
+#define VX1000_COPY_CAL_PAGE_INTERNAL
+#endif /* !VX1000_COPY_CAL_PAGE */
+#endif  /* VX1000_MAILBOX && VX1000_MAILBOX_OVERLAY_CONTROL && !VX1000_COMPILED_FOR_SLAVECORES && !VX1000_OVERLAY_VX_CONFIGURABLE */
+
+
+/*------------------------------------------------------------------------------ */
+/* VX1000 ECU ID                                                                 */
+
+#if !defined(VX1000_ECUID_PTR)
+#if defined(VX1000_ECUID) && defined(VX1000_ECUID_LEN)
+extern const VX1000_UINT8 gVX1000_ECUID[(VX1000_ECUID_LEN) + 1U];
+#define VX1000_ECUID_DATA              const VX1000_UINT8 gVX1000_ECUID[(VX1000_ECUID_LEN) + 1U] = VX1000_ECUID
+#define VX1000_ECUID_PTR               (VX1000_PTR2CU8_TO_ADDRESS(&gVX1000_ECUID[0]))
+#else /* !VX1000_ECUID || !VX1000_ECUID_LEN */
+#define VX1000_ECUID_PTR               0UL
+#endif /* !VX1000_ECUID || !VX1000_ECUID_LEN */
+#endif /* !VX1000_ECUID_PTR */
+
+#if !defined(VX1000_ECUID_LEN)
+#define VX1000_ECUID_LEN               0U
+#endif /* !VX1000_ECUID_LEN */
+
+
+/*------------------------------------------------------------------------------ */
+/* OLDA                                                                          */
+
+#if defined(VX1000_OLDA)
+
+#if defined(VX1000_OLDA_FORCE_V7)
+#define VX1000_OLDA_VERSION            0x07U /* Olda Version 7 + 0x10 * Plattform code 0x0 (same as MPC56x) */
+#define VX1000_OLDA_SIZE_SWAP_VALUE    0x00000000UL     /* dummy value, only used in coldstart verification */
+#define VX1000_OLDA_SIZE_LENGTH        0x0              /* dummy value, only used in coldstart verification */
+#define VX1000_OLDA_SIZE_OFFSET        0x0              /* dummy value, only used in coldstart verification */
+#elif defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_OLDA_VERSION            0x08U /* Olda Version 7 + 0x10 * Plattform code 0x0 (same as MPC56x) */
+#define VX1000_OLDA_SIZE_SWAP_VALUE    0x00000000UL     /* dummy value, only used in coldstart verification */
+#define VX1000_OLDA_SIZE_LENGTH        0x0              /* dummy value, only used in coldstart verification */
+#define VX1000_OLDA_SIZE_OFFSET        0x0              /* dummy value, only used in coldstart verification */
+#else /* !VX1000_OLDA_FORCE_xx */
+#if defined(VX1000_TARGET_XC2000)
+#define VX1000_OLDA_VERSION            0x0016U /* Olda Version 6 + 0x10 * Plattform code 0x1 (XC2000) */
+#else  /* !VX1000_TARGET_XC2000 */
+#define VX1000_OLDA_VERSION            0x06U /* Olda Version 6 + 0x10 * Plattform code 0x0 (same as PowerPC)*/
+#endif /* !VX1000_TARGET_XC2000 */
+/* As olda_V6 allows overloading of the SWAP, LENGTH and OFFSET defaults via the CFG file, first check if already defined: */
+
+#if defined(VX1000_TARGET_POWERPC)
+#if !defined(VX1000_OLDA_SIZE_SWAP_VALUE)
+#define VX1000_OLDA_SIZE_SWAP_VALUE    0x00000000UL     /* use olda-v5-like default for backward compatibility */
+#endif /* !VX1000_OLDA_SIZE_SWAP_VALUE */
+#if !defined(VX1000_OLDA_SIZE_LENGTH)
+#define VX1000_OLDA_SIZE_LENGTH        6UL              /* use olda-v5-like default for backward compatibility */
+#endif /* !VX1000_OLDA_SIZE_LENGTH */
+#if !defined(VX1000_OLDA_SIZE_OFFSET)
+#define VX1000_OLDA_SIZE_OFFSET        22UL             /* use olda-v5-like default for backward compatibility */
+#endif /* !VX1000_OLDA_SIZE_OFFSET */
+#endif /* VX1000_TARGET_POWERPC */
+#if defined(VX1000_TARGET_SH2)
+#if !defined(VX1000_OLDA_SIZE_SWAP_VALUE)
+#define VX1000_OLDA_SIZE_SWAP_VALUE    0x0000000FUL
+#endif /* !VX1000_OLDA_SIZE_SWAP_VALUE */
+#if !defined(VX1000_OLDA_SIZE_LENGTH)
+#define VX1000_OLDA_SIZE_LENGTH        4UL
+#endif /* !VX1000_OLDA_SIZE_LENGTH */
+#if !defined(VX1000_OLDA_SIZE_OFFSET)
+ #define VX1000_OLDA_SIZE_OFFSET       20UL
+#endif /* !VX1000_OLDA_SIZE_OFFSET */
+#endif /* VX1000_TARGET_SH2 */
+#if defined(VX1000_TARGET_TMS570)
+#if !defined(VX1000_OLDA_SIZE_SWAP_VALUE)
+#define VX1000_OLDA_SIZE_SWAP_VALUE    0x0000000FUL
+#endif /* !VX1000_OLDA_SIZE_SWAP_VALUE */
+#if !defined(VX1000_OLDA_SIZE_LENGTH)
+#define VX1000_OLDA_SIZE_LENGTH        4UL
+#endif /* !VX1000_OLDA_SIZE_LENGTH */
+#if !defined(VX1000_OLDA_SIZE_OFFSET)
+ #define VX1000_OLDA_SIZE_OFFSET       20UL
+#endif /* !VX1000_OLDA_SIZE_OFFSET */
+#endif /* VX1000_TARGET_TMS570 */
+#if defined(VX1000_TARGET_TRICORE)
+#if !defined(VX1000_OLDA_SIZE_SWAP_VALUE)
+#define VX1000_OLDA_SIZE_SWAP_VALUE    0x00000000UL
+#endif /* !VX1000_OLDA_SIZE_SWAP_VALUE */
+#if !defined(VX1000_OLDA_SIZE_LENGTH)
+#define VX1000_OLDA_SIZE_LENGTH        6UL
+#endif /* !VX1000_OLDA_SIZE_LENGTH */
+#if !defined(VX1000_OLDA_SIZE_OFFSET)
+#define VX1000_OLDA_SIZE_OFFSET        21UL
+#endif /* !VX1000_OLDA_SIZE_OFFSET */
+#endif /* VX1000_TARGET_TRICORE */
+#if defined(VX1000_TARGET_X850)
+#if !defined(VX1000_OLDA_SIZE_SWAP_VALUE)
+#define VX1000_OLDA_SIZE_SWAP_VALUE    0x0000003bUL     /* all V850 addresses have these bits set: 0x0EC00000 */
+#endif /* !VX1000_OLDA_SIZE_SWAP_VALUE */
+#if !defined(VX1000_OLDA_SIZE_LENGTH)
+#define VX1000_OLDA_SIZE_LENGTH        6UL              /* size/4 is encoded within 6 bit */
+#endif /* !VX1000_OLDA_SIZE_LENGTH */
+#if !defined(VX1000_OLDA_SIZE_OFFSET)
+#define VX1000_OLDA_SIZE_OFFSET        22UL             /* Default address format is with mask 0xF03FFFFF */
+#endif /* !VX1000_OLDA_SIZE_OFFSET */
+#endif /* VX1000_TARGET_X850 */
+#if defined(VX1000_TARGET_XC2000)
+#if !defined(VX1000_OLDA_SIZE_SWAP_VALUE)
+#define VX1000_OLDA_SIZE_SWAP_VALUE    0x00000000UL
+#endif /* !VX1000_OLDA_SIZE_SWAP_VALUE */
+#if !defined(VX1000_OLDA_SIZE_LENGTH)
+#define VX1000_OLDA_SIZE_LENGTH        6UL
+#endif /* !VX1000_OLDA_SIZE_LENGTH */
+#if !defined(VX1000_OLDA_SIZE_OFFSET)
+#define VX1000_OLDA_SIZE_OFFSET        24UL
+#endif /* !VX1000_OLDA_SIZE_OFFSET */
+#endif /* VX1000_TARGET_XC2000 */
+
+#if ( ((VX1000_OLDA_SIZE_LENGTH) < 4U) || ((VX1000_OLDA_SIZE_LENGTH) > 7U) )
+#error "VX1000_OLDA_SIZE_LENGTH not in allowed range of 4..7!"
+#endif /* ! 4 <= VX1000_OLDA_SIZE_LENGTH <= 7 */
+#if (((VX1000_OLDA_SIZE_OFFSET) + (VX1000_OLDA_SIZE_LENGTH)) > 32U)
+#error "VX1000_OLDA_SIZE_OFFSET + VX1000_OLDA_SIZE_LENGTH exceeds DWORD border!"
+#endif /* VX1000_OLDA_SIZE_OFFSET + VX1000_OLDA_SIZE_LENGTH > 32 */
+#endif /* !VX1000_OLDA_FORCE_V7 */
+
+#define VX1000_OLDA_MAGIC              0x2603U
+
+
+/* Generate Olda Size mask and replacement */
+#define VX1000_OLDA_SIZE_MASK ( ((1UL << (VX1000_OLDA_SIZE_LENGTH)) - 1UL) << (VX1000_OLDA_SIZE_OFFSET))
+#define VX1000_OLDA_SIZE_REPLACEMENT ((VX1000_UINT32) (((VX1000_OLDA_SIZE_SWAP_VALUE) << (VX1000_OLDA_SIZE_OFFSET)) & (VX1000_OLDA_SIZE_MASK)))
+
+#if (((VX1000_OLDA_SIZE_SWAP_VALUE) & (~((1UL << (VX1000_OLDA_SIZE_LENGTH)) - 1UL))) != 0UL) /* PRQA S 3302 */ /* Accepted violation of MISRA rule 12.11 because this formula deals with bitfields and not with numbers */
+#error Overlapping data fields inside the olda descriptors (SIZE_SWAP_VALUE vs. SIZE_LENGTH)!
+#endif /* VX1000_OLDA_SIZE_SWAP_VALUE , VX1000_OLDA_SIZE_LENGTH */
+
+
+#if defined(VX1000_TARGET_TRICORE)
+/* Default memory size and address */
+#if !defined(VX1000_OLDA_MEMORY_SIZE)
+#define VX1000_OLDA_MEMORY_SIZE         0UL
+#if !defined(VX1000_OLDA_MEMORY_ADDR)
+#define VX1000_OLDA_MEMORY_ADDR         0UL
+#endif /* !VX1000_OLDA_MEMORY_ADDR */
+#else /* !VX1000_OLDA_MEMORY_SIZE */
+#if !defined(VX1000_MEMORY_ADDR)
+#define VX1000_MEMORY_ADDR              (&gVX1000_OldaMem)
+#endif /* !VX1000_MEMORY_ADDR */
+#endif /* !VX1000_OLDA_MEMORY_SIZE */
+#else  /* !VX1000_TARGET_TRICORE */
+/* Default memory size */
+#if (!defined(VX1000_OLDA_MEMORY_SIZE)) && (!defined(VX1000_DISABLE_INSTRUMENTATION))
+#error VX1000_OLDA_MEMORY_SIZE must be defined in VX1000_cfg.h!
+#endif /* !VX1000_OLDA_MEMORY_SIZE */
+#endif /* !VX1000_TARGET_TRICORE */
+
+/* Feature flags */
+/* using 1st featureFlags field: */
+#define VX1000_FEAT_OLDA_TRIGGER_TYPE0   (((0x0U << 15U) | (0x0U << 4U)) | (0x0U << 3U)) /* all targets: 32bits in gVX1000 */
+#define VX1000_FEAT_OLDA_TRIGGER_TYPE1   (((0x0U << 15U) | (0x0U << 4U)) | (0x1U << 3U)) /* SHx: 16bits in AUDMBR; PowerPC: 32bits + 32duplicatebits in DTS; TC1xxx: 32bits in TRIGS; reserved on other targets */
+#define VX1000_FEAT_OLDA_TRIGGER_TYPE2   (((0x0U << 15U) | (0x1U << 4U)) | (0x0U << 3U)) /* TC24x..TC29x: 32bits in TRIGS; reserved on other targets */
+#define VX1000_FEAT_OLDA_TRIGGER_TYPE3   (((0x0U << 15U) | (0x1U << 4U)) | (0x1U << 3U)) /* TC21x..TC23x: 16bits in TRIGS; reserved on other targets */
+#define VX1000_FEAT_OLDA_TRIGGER_TYPE4   (((0x1U << 15U) | (0x0U << 4U)) | (0x0U << 3U)) /* all targets: 32bits + 32inversebits in gVX1000 */
+#define VX1000_FEAT_OLDA_TRIGGER_TYPE5   (((0x1U << 15U) | (0x0U << 4U)) | (0x1U << 3U)) /* all targets (except Tricore): event signalling via trace */
+#define VX1000_FEAT_OLDA_TRIGGER_TYPE6   (((0x1U << 15U) | (0x1U << 4U)) | (0x0U << 3U)) /* reserved */
+#define VX1000_FEAT_OLDA_TRIGGER_TYPE7   (((0x1U << 15U) | (0x1U << 4U)) | (0x1U << 3U)) /* reserved */
+#if defined(VX1000_OLDA_AUDMBR_REG_ADDR) || defined(VX1000_OLDA_DTS_BASE_ADDR)
+#define VX1000_FEAT_OLDA_TRIGGER        (VX1000_FEAT_OLDA_TRIGGER_TYPE1)
+#else  /* classic olda event trigger with inverse */
+#if defined(VX1000_SUPPRESS_TRACE_SUPPORT)
+#define VX1000_FEAT_OLDA_TRIGGER        (VX1000_FEAT_OLDA_TRIGGER_TYPE4)
+#else /* !VX1000_SUPPRESS_TRACE_SUPPORT */
+#define VX1000_FEAT_OLDA_TRIGGER        (VX1000_FEAT_OLDA_TRIGGER_TYPE5)
+#endif /* !VX1000_SUPPRESS_TRACE_SUPPORT */
+#endif /* classic olda event trigger with inverse */
+/* note: bit 15 already used for TRIGGER_TYPE */
+#if defined(VX1000_OLDA_BENCHMARK)
+#define VX1000_FEAT_OLDA_BENCHMARK      (1U << 14U)
+#else  /* !VX1000_OLDA_BENCHMARK */
+#define VX1000_FEAT_OLDA_BENCHMARK      (0U << 14U)
+#endif /* !VX1000_OLDA_BENCHMARK */
+#define VX1000_FEAT_OLDA_UNUSED_FLAG13  (0U << 13U) /* still free for future use */
+#define VX1000_FEAT_OLDA_UNUSED_FLAG12  (0U << 12U) /* still free for future use */
+#define VX1000_FEAT_OLDA_UNUSED_FLAG11  (0U << 11U) /* still free for future use */
+#define VX1000_FEAT_OLDA_512EVENTS      (1U << 10U)
+#if defined(VX1000_SUPPORT_OLDA_MULTIBUFFER)
+#define VX1000_FEAT_OLDA_MULTIBUFFER    (1U << 9U)
+#else  /* !VX1000_SUPPORT_OLDA_MULTIBUFFER */
+#define VX1000_FEAT_OLDA_MULTIBUFFER    (0U << 9U)
+#endif /* !VX1000_SUPPORT_OLDA_MULTIBUFFER */
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE) && (defined(VX1000_OLDA_FORCE_V7) || (defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8)))
+#define VX1000_FEAT_OLDA_V7_ASMDAQBOOKE (1U << 8U)
+#else  /* !VX1000_SUPPORT_OLDA7_ASMGNUBOOKE || !VX1000_OLDA_FORCE_V7 */
+#define VX1000_FEAT_OLDA_V7_ASMDAQBOOKE (0U << 8U)
+#endif /* !VX1000_SUPPORT_OLDA7_ASMGNUBOOKE || !VX1000_OLDA_FORCE_V7 */
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE) && (defined(VX1000_OLDA_FORCE_V7) || (defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8)))
+#define VX1000_FEAT_OLDA_V7_ASMDAQVLE   (1U << 7U)
+#else  /* !VX1000_SUPPORT_OLDA7_ASMGNUVLE || !VX1000_OLDA_FORCE_V7 */
+#define VX1000_FEAT_OLDA_V7_ASMDAQVLE   (0U << 7U)
+#endif /* !VX1000_SUPPORT_OLDA7_ASMGNUVLE || !VX1000_OLDA_FORCE_V7 */
+#if (defined(VX1000_SUPPORT_OLDA7_BYTEDAQ) || ((VX1000_MEMSYNC_TRIGGER_COUNT > 0))) && (defined(VX1000_OLDA_FORCE_V7) || (defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8)))
+#define VX1000_FEAT_OLDA_V7_BYTEDAQ     (1U << 6U)
+#define VX1000_FEAT_OLDA_V7_MEMSY_SEL   (1U << 6U)
+#else  /* !(VX1000_SUPPORT_OLDA7_BYTEDAQ || VX1000_MEMSYNC_TRIGGER_COUNT) || !VX1000_OLDA_FORCE_V7 */
+#define VX1000_FEAT_OLDA_V7_BYTEDAQ     (0U << 6U)
+#define VX1000_FEAT_OLDA_V7_MEMSY_SEL   (0U << 6U)
+#endif /* !(VX1000_SUPPORT_OLDA7_BYTEDAQ || VX1000_MEMSYNC_TRIGGER_COUNT) || !VX1000_OLDA_FORCE_V7 */
+#if defined(VX1000_HOOK_BASED_BYPASSING)
+#define VX1000_FEAT_OLDA_HBB            (1U << 5U)
+#else  /* !VX1000_HOOK_BASED_BYPASSING */
+#define VX1000_FEAT_OLDA_HBB            (0U << 5U)
+#endif /* !VX1000_HOOK_BASED_BYPASSING */
+/* note: bits 3,4 already used for TRIGGER_TYPE */
+#if defined(VX1000_STIM_BY_OLDA)
+#define VX1000_FEAT_OLDA_STIM           (1U << 2U)
+#else  /* !VX1000_STIM_BY_OLDA */
+#define VX1000_FEAT_OLDA_STIM           (0U << 2U)
+#endif /* !VX1000_STIM_BY_OLDA */
+#define VX1000_FEAT_OLDA_V5_DYNSIZE     (0U << 1U) /* V5 no longer used */
+#if defined(VX1000_SUPPORT_OLDA7_COMPRESS)  && (defined(VX1000_OLDA_FORCE_V7) || (defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8)))
+#define VX1000_FEAT_OLDA_V7_COMPRESS    (1U << 1U)
+#else  /* !VX1000_SUPPORT_OLDA7_COMPRESS  || !VX1000_OLDA_FORCE_V7 */
+#define VX1000_FEAT_OLDA_V7_COMPRESS    (0U << 1U)
+#endif /* !VX1000_SUPPORT_OLDA7_COMPRESS || !VX1000_OLDA_FORCE_V7 */
+#if defined(VX1000_OLDA_OVERLOAD_DETECTION)
+#define VX1000_FEAT_OLDA_OVERLOADDETECT (1U << 0U)
+#else  /* !VX1000_OLDA_OVERLOAD_DETECTION */
+#define VX1000_FEAT_OLDA_OVERLOADDETECT (0U << 0U)
+#endif /* !VX1000_OLDA_OVERLOAD_DETECTION */
+/* using featureFlags2 field: */
+#if defined(VX1000_MEMCPY)&& defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_FEAT_OLDA_V8CMD_USRCPY   (1U << 14U)
+#else  /* !VX1000_MEMCPY  || !VX1000_OLDA_FORCE_V8 */
+#define VX1000_FEAT_OLDA_V8CMD_USRCPY   (0U << 14U)
+#endif /* !VX1000_MEMCPY  || !VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_SUPPORT_OLDA8CMD_SP8N)  && defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_FEAT_OLDA_V8CMD_SP8N     (1U << 13U)
+#else  /* !VX1000_SUPPORT_OLDA8CMD_SP8N    || !VX1000_OLDA_FORCE_V8 */
+#define VX1000_FEAT_OLDA_V8CMD_SP8N     (0U << 13U)
+#endif /* !VX1000_SUPPORT_OLDA8CMD_SP8N   || !VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CP8N)  && defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_FEAT_OLDA_V8CMD_CP8N     (1U << 12U)
+#else  /* !VX1000_SUPPORT_OLDA8CMD_CP8N    || !VX1000_OLDA_FORCE_V8 */
+#define VX1000_FEAT_OLDA_V8CMD_CP8N     (0U << 12U)
+#endif /* !VX1000_SUPPORT_OLDA8CMD_CP8N   || !VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CP16N) && defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_FEAT_OLDA_V8CMD_CP16N    (1U << 11U)
+#else  /* !VX1000_SUPPORT_OLDA8CMD_CP16N   || !VX1000_OLDA_FORCE_V8 */
+#define VX1000_FEAT_OLDA_V8CMD_CP16N    (0U << 11U)
+#endif /* !VX1000_SUPPORT_OLDA8CMD_CP16N  || !VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CP32N) && defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_FEAT_OLDA_V8CMD_CP32N    (1U << 10U)
+#else  /* !VX1000_SUPPORT_OLDA8CMD_CP32N   || !VX1000_OLDA_FORCE_V8 */
+#define VX1000_FEAT_OLDA_V8CMD_CP32N    (0U << 10U)
+#endif /* !VX1000_SUPPORT_OLDA8CMD_CP32N  || !VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CP64N) && defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_FEAT_OLDA_V8CMD_CP64N    (1U << 9U)
+#else  /* !VX1000_SUPPORT_OLDA8CMD_CP64N   || !VX1000_OLDA_FORCE_V8 */
+#define VX1000_FEAT_OLDA_V8CMD_CP64N    (0U << 9U)
+#endif /* !VX1000_SUPPORT_OLDA8CMD_CP64N  || !VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_FEAT_OLDA_V8CMD_LEGACYVR (1U << 8U)
+#else  /* !VX1000_SUPPORT_OLDA8CMD_LEGACYVR || !VX1000_OLDA_FORCE_V8 */
+#define VX1000_FEAT_OLDA_V8CMD_LEGACYVR (0U << 8U)
+#endif /* !VX1000_SUPPORT_OLDA8CMD_LEGACYVR || !VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_SUPPORT_OLDA8CMD_WAIT)  && defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_FEAT_OLDA_V8CMD_WAIT     (1U << 7U)
+#else  /* !VX1000_SUPPORT_OLDA8CMD_WAIT    || !VX1000_OLDA_FORCE_V8 */
+#define VX1000_FEAT_OLDA_V8CMD_WAIT     (0U << 7U)
+#endif /* !VX1000_SUPPORT_OLDA8CMD_WAIT   || !VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_SUPPORT_OLDA8CMD_SUBEVT)&& defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_FEAT_OLDA_V8CMD_SUBEVT   (1U << 6U)
+#else  /* !VX1000_SUPPORT_OLDA8CMD_SUBEVT  || !VX1000_OLDA_FORCE_V8 */
+#define VX1000_FEAT_OLDA_V8CMD_SUBEVT   (0U << 6U)
+#endif /* !VX1000_SUPPORT_OLDA8CMD_SUBEVT || !VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CALLJITA)  && defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_FEAT_OLDA_V8CMD_CALLJITA (1U << 1U)
+#else  /* !VX1000_SUPPORT_OLDA8CMD_CALLJITA  || !VX1000_OLDA_FORCE_V8 */
+#define VX1000_FEAT_OLDA_V8CMD_CALLJITA (0U << 1U)
+#endif /* !VX1000_SUPPORT_OLDA8CMD_CALLJITA || !VX1000_OLDA_FORCE_V8 */
+
+#if defined(VX1000_TARGET_X850)
+
+/* advice the compiler to pack the data of the following structures byte-wise ==> todo: shall be moved to userconfig (VX1000_BEGSECT_VXMODULE_H) */
+#pragma pack(1) /* syntax valid for both GCC and for GHS as well as for Renesas-CX; may need adaptation for other compilers */
+
+#endif /* VX1000_TARGET_X850 */
+typedef struct
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   EventCounter;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   EventTimestamp;  /* NB: for OLDA stimulation, this field is used to store the address of the stimulation buffer */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   TransferDest;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16   TransferIndex;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16   TransferCount;   /* NB: for OLDAv8, this field is used to define the aligned size in bytes of the event\'s olda buffer */
+} VX1000_OLDA_EVENT_T;
+
+typedef struct
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16        MagicId;              /* 0x00 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8         Version;              /* 0x02 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8         Running;              /* 0x03 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32        MemoryAddr;           /* 0x04 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16        MemorySize;           /* 0x08 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16        EventCount;           /* 0x0A */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32        EventList;            /* 0x0C */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32        TransferList;         /* 0x10 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8         SizeLengthNOffset;    /* 0x14 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8         SizeSwapValue;        /* 0x15 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16        OldaFeatures;         /* 0x16 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16        OldaFeatures2;        /* 0x18 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16        OldaBenchmarkCnt;     /* 0x1A */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32        Res2;                 /* 0x1C */
+#if !defined(VX1000_OLDA_MEMORY_ADDR)
+#if defined(VX1000_TARGET_XC2000)
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16        Data[(VX1000_OLDA_MEMORY_SIZE) / 2UL]; /* TODO: align on 32bit-boundaries */
+#else  /* !VX1000_TARGET_XC2000 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32        Data[(VX1000_OLDA_MEMORY_SIZE) / 4UL];
+#endif /* !VX1000_TARGET_XC2000 */
+#endif /* !VX1000_OLDA_MEMORY_ADDR */
+} VX1000_OLDA_T;
+
+#if defined(VX1000_TARGET_X850)
+
+/* restore previous padding strategy for the application ==> todo: shall be moved to user-config (VX1000_ENDSECT_VXMODULE_H) */
+#if defined(__CX__)
+/* Renesas CX compiler syntax */
+#pragma pack(4)
+#else /* !__CX__ */
+/* GHS compiler syntax */
+#pragma pack()
+#endif /* !__CX__ */
+
+#endif /* VX1000_TARGET_X850 */
+
+#if defined(VX1000_OLDA_FORCE_V8)
+extern void VX1000_SUFFUN(vx1000_OldaEvent)( VX1000_UINT16 eventNumber, VX1000_UINT32 extendedParameter );
+#define VX1000_OLDA_EVENT(x)           VX1000_SUFFUN(vx1000_OldaEvent)((1+(x)), 0); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#define VX1000_OLDA_EVENT_COUNT2       ((VX1000_OLDA_EVENT_COUNT) + 1)
+#define VX1000_OLDA_BENCHMARK_CNT2     ((VX1000_OLDA_BENCHMARK_CNT) + 1)
+#else /* !VX1000_OLDA_FORCE_V8 */
+extern void VX1000_SUFFUN(vx1000_OldaEvent)( VX1000_UINT16 eventNumber );
+#define VX1000_OLDA_EVENT(x)           VX1000_SUFFUN(vx1000_OldaEvent)((x)); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#define VX1000_OLDA_EVENT_COUNT2       (VX1000_OLDA_EVENT_COUNT)
+#define VX1000_OLDA_BENCHMARK_CNT2     (VX1000_OLDA_BENCHMARK_CNT)
+#endif /* !VX1000_OLDA_FORCE_V8 */
+#define VX1000_OLDA_DATA               VX1000_OLDA_T Olda
+#define VX1000_OLDA_PTR                (VX1000_PTR2VO_TO_ADDRESS(&gVX1000.Olda))
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0) && (!defined(VX1000_OLDA_FORCE_V8))
+extern void VX1000_SUFFUN(vx1000_OldaSpecialEvent)( VX1000_UINT32 eventNumber );
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT & !VX1000_OLDA_FORCE_V8 */
+
+#if defined(VX1000_OLDA_BENCHMARK)
+extern VX1000_UINT32 gVX1000_OLDA_Duration[VX1000_OLDA_BENCHMARK_CNT2];
+extern VX1000_UINT32 gVX1000_OLDA_TransferSize[VX1000_OLDA_BENCHMARK_CNT2];
+extern VX1000_UINT32 gVX1000_OLDA_TransferCount[VX1000_OLDA_BENCHMARK_CNT2];
+#define VX1000_OLDA_BENCHMARK_DATA     VX1000_UINT32 gVX1000_OLDA_Duration[VX1000_OLDA_BENCHMARK_CNT2], gVX1000_OLDA_TransferSize[VX1000_OLDA_BENCHMARK_CNT2], gVX1000_OLDA_TransferCount[VX1000_OLDA_BENCHMARK_CNT2]
+#define VX1000_OLDA_DURARRAY_PTR       (VX1000_PTR2U32_TO_ADDRESS(gVX1000_OLDA_Duration))
+#else /* !VX1000_OLDA_BENCHMARK */
+#define VX1000_OLDA_DURARRAY_PTR       0UL
+#endif /* VX1000_OLDA_BENCHMARK */
+
+#define VX1000_STRUCT_OFSADDR(OFS)     ((OFS) + VX1000_PTR2VVX_TO_ADDRESS(&gVX1000)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compiletime and thus cannot be turned into a function */
+#define VX1000_O8DESC_DONE             0x00000005UL /* without colon beause it is always the last entry in the array */
+#define VX1000_O8DLEN_DONE             1
+#if (!defined(VX1000_CLOCK)) || (!defined(VX1000_CLOCK_TICKS_PER_BASE))
+#define VX1000_O8DESC_TIMESTAMP_EV     /* empty */
+#define VX1000_O8DLEN_TIMESTAMP_EV     0
+#define VX1000_O8DESC_TIMESTAMP_NOW    /* empty */
+#define VX1000_O8DLEN_TIMESTAMP_NOW    0
+#endif /* !VX1000_CLOCK || !VX1000_CLOCK_TICKS_PER_BASE */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 0)
+#define VX1000_O8DESC_TRIGSPCEV        0x00970108UL, VX1000_STRUCT_OFSADDR(0x0UL),
+#define VX1000_O8DLEN_TRIGSPCEV        2
+#define VX1000_O8DESC_TRIGDAQEV(IDX)   0x00960108UL, VX1000_STRUCT_OFSADDR(0x0UL), (IDX), /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compiletime and thus cannot be turned into a function */
+#define VX1000_O8DLEN_TRIGDAQEV        3
+#if defined(VX1000_CLOCK) && defined(VX1000_CLOCK_TICKS_PER_BASE)
+#define VX1000_O8DESC_TIMESTAMP_EV     0x00980108UL, VX1000_STRUCT_OFSADDR(0x4UL),
+#define VX1000_O8DLEN_TIMESTAMP_EV     2
+#define VX1000_O8DESC_TIMESTAMP_NOW    0x00990108UL, VX1000_STRUCT_OFSADDR(0x4UL),
+#define VX1000_O8DLEN_TIMESTAMP_NOW    2
+#endif /* VX1000_CLOCK && VX1000_CLOCK_TICKS_PER_BASE */
+#else  /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+#define VX1000_O8DESC_TRIGSPCEV        0x00900108UL, VX1000_STRUCT_OFSADDR(0x0UL),
+#define VX1000_O8DLEN_TRIGSPCEV        2
+#define VX1000_O8DESC_TRIGDAQEV(IDX)   0x00800108UL, VX1000_STRUCT_OFSADDR(0x0UL), (IDX), /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because this expression is evaluated at compiletime and thus cannot be turned into a function */
+#define VX1000_O8DLEN_TRIGDAQEV        3
+#if defined(VX1000_CLOCK) && defined(VX1000_CLOCK_TICKS_PER_BASE)
+#define VX1000_O8DESC_TIMESTAMP_EV     0x00910108UL, VX1000_STRUCT_OFSADDR(0x4UL),
+#define VX1000_O8DLEN_TIMESTAMP_EV     2
+#define VX1000_O8DESC_TIMESTAMP_NOW    0x009A0108UL, VX1000_STRUCT_OFSADDR(0x4UL),
+#define VX1000_O8DLEN_TIMESTAMP_NOW    2
+#endif /* VX1000_CLOCK && VX1000_CLOCK_TICKS_PER_BASE */
+#endif /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+
+#else /* !VX1000_OLDA */
+
+#define VX1000_OLDA_EVENT(x)           /*VX1000_DUMMYREAD((x))*/
+#define VX1000_OLDA_PTR                0UL
+#define VX1000_OLDA_DURARRAY_PTR       0UL
+
+#endif /* !VX1000_OLDA */
+
+
+/*------------------------------------------------------------------------------ */
+/* Driver Error Logger                                                           */
+
+#define VX1000_ERRLOG_NO_ERROR         0x0000U /* no error at all */
+
+#define VX1000_ERRLOG_STRUCTS_PADDED   0x0101U /* due to bad compiler settings, the VX1000 structures were padded (but they must be packed) */
+#define VX1000_ERRLOG_JTAGID_UNKNOWN   0x0102U /* the driver found a derivative that it does not know how to handle (e.g. support was de-configured to reduce code size) */
+#define VX1000_ERRLOG_TYPESIZE_INVAL   0x0103U /* due to bad compiler settings or wrong user configuration the VX1000_xxxINTxx typedefs result in wrong byte size */
+#define VX1000_ERRLOG_PTR_NONREPSTBL   0x0104U /* the driver received a linear pointer from the tool that has no valid representation in the used compiler memory model */
+#define VX1000_ERRLOG_TOO_MANY_CORES   0x0105U /* VX1000_CURRENT_CORE_IDX() returned a core index that exceeds the configured maximum */
+
+#define VX1000_ERRLOG_TM_RESO_TOO_LOW  0x0201U /* the resolution of the timer is too low for some features */
+#define VX1000_ERRLOG_TM_RESO_TOO_HIGH 0x0202U /* the resolution of the timer is too high for some features */
+#define VX1000_ERRLOG_TM_DT_IS_ZERO    0x0203U /* due to a low resolution, the conversion from a non-zero time resulted in a tick count of zero */
+#define VX1000_ERRLOG_TM_DTDT_TOO_LONG 0x0204U /* the user requested a VX1000_DETECT() timeout that cannot be represented within the available bit slice */
+#define VX1000_ERRLOG_TM_DTCS_TOO_LONG 0x0205U /* the user requested a VX1000_INIT() timeout that cannot be represented within the available bit slice */
+#define VX1000_ERRLOG_TM_DTST_TOO_LONG 0x0206U /* the user called the STIM API with a timeout that cannot be represented within the available bit slice */
+#define VX1000_ERRLOG_TM_DTSR_TOO_LONG 0x0207U /* the user requested a VX1000_PREPARE_SOFTRESET() timeout that cannot be represented within the available bit slice */
+
+#define VX1000_ERRLOG_OLDA_UNIMPLCMD   0x0301U /* the olda descriptors contain an unimplemented command */
+#define VX1000_ERRLOG_OLDA_UNIMPLSUB   0x0302U /* the olda descriptors contain an unimplemented subcommand */
+#define VX1000_ERRLOG_OLDA_BUFINVAL    0x0303U /* the olda buffer is linked to an invalid address / not linked at all */
+#define VX1000_ERRLOG_OLDA_BUFSMALL    0x0304U /* the olda buffer was configured too small */
+
+#define VX1000_ERRLOG_OVL_INVALID_PAGE 0x0401U /* the XCP master requested a page number > 1 which is not supported by the driver */
+#define VX1000_ERRLOG_OVL_INVALID_SIZE 0x0402U /* the user specified an overlay size that is not supported by the hardware/driver */
+#define VX1000_ERRLOG_OVL_MISALIGNED   0x0403U /* the user specified an overlay alignment that is not supported by the hardware/driver */
+#define VX1000_ERRLOG_OVL_TOO_MANY     0x0404U /* the XCP master requested a segment number > 1 which is not supported by the driver */
+#define VX1000_ERRLOG_OVL_USER_FAILED  0x0405U /* a user\'s overlay callback returned a value != 0 */
+#define VX1000_ERRLOG_OVL_UNIMPL       0x0406U /* code was triggered that is not implemented for the derivative it is executed on */
+#define VX1000_ERRLOG_OVL_NONEXCLUSIVE 0x0407U /* the AppDriver was triggered to handle overlays but not all descriptors were assigned to his control */
+
+/* reserved range for DAS:             0x05xxU */
+
+#if (VX1000_ERRLOG_SIZE != 0)
+extern void VX1000_SUFFUN(vx1000_ErrLogger)( VX1000_UINT16 errorcode );
+#define VX1000_ERRLOGGER(E)            VX1000_SUFFUN(vx1000_ErrLogger)(E); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#define VX1000_ERRLOG_DATA             VX1000_UINT16 ErrLog[VX1000_ERRLOG_SIZE]
+#define VX1000_ERRLOG_ADDR             (VX1000_PTR2VU16_TO_ADDRESS(gVX1000.ErrLog))
+#else /* !VX1000_ERRLOG_SIZE */
+#define VX1000_ERRLOGGER(E)            /* empty */
+#define VX1000_ERRLOG_ADDR             0UL
+#endif /* !VX1000_ERRLOG_SIZE */
+
+
+/*------------------------------------------------------------------------------ */
+/* VX1000 Stimulation                                                            */
+
+/* STIM event API return codes */
+#define VX1000_STIM_RET_INACTIVE       0
+#define VX1000_STIM_RET_SUCCESS        1
+#define VX1000_STIM_RET_TIMEOUT        2
+#define VX1000_STIM_RET_ERROR          3
+
+#if defined(VX1000_STIM)
+
+#define VX1000_STIM_MAGIC              0xFEC70A07UL
+#define VX1000_STIM_EVENT_MAGIC        0xFEC70A19UL
+
+#if !defined(VX1000_STIM_FORCE_V1)
+typedef struct
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 MagicId;           /* 0x00 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 Version;           /* 0x04 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 Control;           /* 0x06 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  EvtOffset;         /* 0x08 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  EvtNumber;         /* 0x09 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 Padding1;          /* 0x0A */
+  struct VX1000_stim_event                                     /* 0x0C */
+  {
+    VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 Ctr;              /* 0x0C + 4*e */
+    VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 RqCtr;            /* 0x0D + 4*e */
+    VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 Enable;           /* 0x0E + 4*e */
+    VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 Copying;          /* 0x0F + 4*e */
+  } Event[VX1000_STIM_EVENT_COUNT];
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 Enable;            /* 0x0C + 4*VX1000_STIM_EVENT_COUNT */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 TimeoutCtr;        /* 0x0E + 4*VX1000_STIM_EVENT_COUNT */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 TimeoutCtr2;       /* 0x10 + 4*VX1000_STIM_EVENT_COUNT */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 Padding2;          /* 0x12 + 4*VX1000_STIM_EVENT_COUNT */
+} VX1000_STIM_T;
+#define VX1000_STIMEVENT_ARRAYNAME gVX1000.Stim.Event
+#else /* VX1000_STIM_FORCE_V1 */
+typedef struct
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 MagicId;           /* 0x20 + 0x00 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 Version;           /* 0x20 + 0x04 */
+  struct VX1000_stim_event                                     /* 0x20 + 0x08 */
+  {
+    VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 EventType;        /* 0x20 + 0x08 + 8*e */
+    VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 DaqEvent;         /* 0x20 + 0x09 + 8*e */
+    VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 Enable;           /* 0x20 + 0x0A + 8*e */
+    VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 Copying;          /* 0x20 + 0x0B + 8*e */
+    VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 Ctr;              /* 0x20 + 0x0C + 8*e */
+    VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 RqCtr;            /* 0x20 + 0x0D + 8*e */
+    VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 Reserved;        /* 0x20 + 0x0E + 8*e */
+  } Event[VX1000_STIM_EVENT_COUNT];
+} VX1000_STIM_EVENT_T;
+
+typedef struct VX1000_hbb_table
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 StimEvent;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 Reserved;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 OldaAddress;
+} VX1000_HBB_VX_TABLE_ENTRY_T;
+
+typedef struct
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 MagicId;           /* 0x00 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 Version;           /* 0x04 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 Control;           /* 0x06 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 EvtOffset;          /* 0x08 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8 EvtNumber;          /* 0x09 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 Enable;            /* 0x0a */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 EventPointer;      /* 0x0c */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 TimeoutCtr;        /* 0x10 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 TimeoutCtr2;       /* 0x12 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 hbbLUTNumber;      /* 0x14 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 hbbLUTPointer;     /* 0x18 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 hbbLUTVXPointer;   /* 0x1c */
+  VX1000_STIM_EVENT_T Events;                                  /* 0x20 */ /* attention: no reserved field for future extensions! */
+} VX1000_STIM_T;
+#define VX1000_STIMEVENT_ARRAYNAME gVX1000.Stim.Events.Event
+#endif /* VX1000_STIM_FORCE_V1 */
+
+/* STIM event enable flag     */
+#define VX1000_STIM_INACTIVE         0
+#define VX1000_STIM_VX_ENABLE        1
+#define VX1000_STIM_DAQ_SENT         2
+#define VX1000_STIM_BUFFER_VALID     3
+#define VX1000_STIM_BUFFER_INVALID   4
+
+/* STIM event global enable   */
+#define VX1000_STIM_GLOBAL_INACTIVE  0
+#define VX1000_STIM_GLOBAL_VX_ENABLE 1
+#define VX1000_STIM_GLOBAL_ALL_CHAN  2
+
+/* STIM event types           */
+#define VX1000_BYPASS_TYPE_DIRECT    1
+#define VX1000_BYPASS_TYPE_OLDA      2
+#define VX1000_BYPASS_TYPE_HOOK      3
+
+/* Copy Active Flag meanings - used for direct stimulation  */
+#define VX1000_BP_CPACT_WAITING_DAQ  0
+#define VX1000_BP_CPACT_WAITING_STIM 1
+#define VX1000_BP_CPACT_DATA_READY   2
+#define VX1000_BP_CPACT_COPYING      3
+
+#define VX1000_BP_TIMESTAMP_SIZE     4
+
+
+/* stim API */
+#define VX1000_STIM_DATA               VX1000_STIM_T Stim
+#define VX1000_STIM_PTR                (VX1000_PTR2VS_TO_ADDRESS(&gVX1000.Stim))
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_StimWait)( VX1000_UINT8 stim_event, VX1000_UINT8 copy_enable, VX1000_UINT32 timeout_us );
+#define VX1000_STIM_WAIT(     E, T)          VX1000_SUFFUN(vx1000_StimWait)((E), 1, (T) )  /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_STIM_WAIT_VOID(E, T)    (void)VX1000_SUFFUN(vx1000_StimWait)((E), 1, (T) ); /* usable as a whole statement */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#if defined(VX1000_STIM_BY_OLDA)
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_Stimulate)( VX1000_UINT8 stim_trigger_event, VX1000_UINT8 stim_event,
+                                                     VX1000_UINT8 cycle_delay, VX1000_UINT32 timeout_us);
+#define VX1000_STIMULATE(     D, S, P, T)       VX1000_SUFFUN(vx1000_Stimulate)((D), (S), (P), (T))  /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_STIMULATE_VOID(D, S, P, T) (void)VX1000_SUFFUN(vx1000_Stimulate)((D), (S), (P), (T)); /* usable as a whole statement */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#else  /* !VX1000_STIM_BY_OLDA */
+#define VX1000_STIMULATE(     D, S, P, T) VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (D),(S),(P),(T))   /* return code for "inactive" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_STIMULATE_VOID(D, S, P, T) VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (D),(S),(P),(T)))      /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#endif /* !VX1000_STIM_BY_OLDA */
+extern void VX1000_SUFFUN(vx1000_StimControl)( void );
+#define VX1000_STIM_CONTROL()          VX1000_SUFFUN(vx1000_StimControl)(); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_CONTROL()        VX1000_SUFFUN(vx1000_StimControl)(); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassTrigger)( VX1000_UINT8 daq_event, VX1000_UINT8 stim_event );
+#define VX1000_BYPASS_TRIGGER(     D, S)       VX1000_SUFFUN(vx1000_BypassTrigger)((D), (S))  /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_TRIGGER_VOID(D, S) (void)VX1000_SUFFUN(vx1000_BypassTrigger)((D), (S)); /* usable as a whole statement */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassDaq) ( VX1000_UINT8 daq_event, VX1000_UINT8 stim_event );
+#define VX1000_BYPASS_DAQ(     D, S)         VX1000_SUFFUN(vx1000_BypassDaq) ((D), (S))       /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_DAQ_VOID(D, S)   (void)VX1000_SUFFUN(vx1000_BypassDaq) ((D), (S));      /* usable as a whole statement */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_STIM(     S )          VX1000_SUFFUN(vx1000_StimWait)((S), 1, 0 )       /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_STIM_VOID(S)     (void)VX1000_SUFFUN(vx1000_StimWait)((S), 1, 0 );      /* usable as a whole statement */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassWait)( VX1000_UINT8 stim_event, VX1000_UINT32 timeout_us);
+#define VX1000_BYPASS_WAIT(     S, T)        VX1000_SUFFUN(vx1000_BypassWait)((S), (T))       /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_WAIT_VOID(S, T)  (void)VX1000_SUFFUN(vx1000_BypassWait)((S), (T));      /* usable as a whole statement */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_Bypass)( VX1000_UINT8 daq_event, VX1000_UINT8 stim_event, VX1000_UINT32 timeout_us );
+#define VX1000_BYPASS(      D, S, T)         VX1000_SUFFUN(vx1000_Bypass)( (D), (S), (T))     /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_VOID( D, S, T)   (void)VX1000_SUFFUN(vx1000_Bypass)( (D), (S), (T));    /* usable as a whole statement */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#if (0==(VX1000_STIM_EVENT_OFFSET))
+#define VX1000_REGISTER_STIM_EVENT(daq_event, stim_event, stim_type) do                                \\
+  {                                                                                                    \\
+    if ((stim_event) < ((VX1000_STIM_EVENT_OFFSET) + (VX1000_STIM_EVENT_COUNT)))                       \\
+    {                                                                                                  \\
+      (VX1000_STIMEVENT_ARRAYNAME)[(stim_event) - (VX1000_STIM_EVENT_OFFSET)].DaqEvent = (daq_event);  \\
+      (VX1000_STIMEVENT_ARRAYNAME)[(stim_event) - (VX1000_STIM_EVENT_OFFSET)].EventType = (stim_type); \\
+    }                                                                                                  \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#else /* VX1000_STIM_EVENT_OFFSET */
+#define VX1000_REGISTER_STIM_EVENT(daq_event, stim_event, stim_type) do                                                          \\
+  {                                                                                                                              \\
+    if (((stim_event) < ((VX1000_STIM_EVENT_OFFSET) + (VX1000_STIM_EVENT_COUNT))) && ((stim_event) >= VX1000_STIM_EVENT_OFFSET)) \\
+    {                                                                                                                            \\
+      (VX1000_STIMEVENT_ARRAYNAME)[(stim_event) - (VX1000_STIM_EVENT_OFFSET)].DaqEvent = (daq_event);                            \\
+      (VX1000_STIMEVENT_ARRAYNAME)[(stim_event) - (VX1000_STIM_EVENT_OFFSET)].EventType = (stim_type);                           \\
+    }                                                                                                                            \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#endif /* VX1000_STIM_EVENT_OFFSET */
+#if defined(VX1000_STIM_BENCHMARK)
+extern volatile VX1000_UINT32 gVX1000_STIM_Begin[VX1000_STIM_EVENT_COUNT];
+extern volatile VX1000_UINT32 gVX1000_STIM_Duration[VX1000_STIM_EVENT_COUNT];
+#if defined(VX1000_STIM_HISTOGRAM)
+extern volatile VX1000_UINT32 gVX1000_STIM_Histogram[256];
+extern volatile VX1000_UINT32 gVX1000_STIM_Histogram2[16];
+#define VX1000_STIM_BENCHMARK_DATA     volatile VX1000_UINT32 gVX1000_STIM_Begin[VX1000_STIM_EVENT_COUNT], gVX1000_STIM_Duration[VX1000_STIM_EVENT_COUNT], gVX1000_STIM_Histogram[256], gVX1000_STIM_Histogram2[16]
+#else /* !VX1000_STIM_HISTOGRAM */
+#define VX1000_STIM_BENCHMARK_DATA     volatile VX1000_UINT32 gVX1000_STIM_Begin[VX1000_STIM_EVENT_COUNT], gVX1000_STIM_Duration[VX1000_STIM_EVENT_COUNT]
+#endif /* !VX1000_STIM_HISTOGRAM */
+#define VX1000_STIM_DURARRAY_PTR       (VX1000_PTR2VU32_TO_ADDRESS(gVX1000_STIM_Duration))
+#else /* !VX1000_STIM_BENCHMARK */
+#define VX1000_STIM_DURARRAY_PTR       0UL
+#endif /* !VX1000_STIM_BENCHMARK */
+
+#define VX1000_STIM_TIMEOUTS gVX1000.Stim.TimeoutCtr
+#define VX1000_STIM_TIMEOUTS_IN_SEQ gVX1000.Stim.TimeoutCtr2
+
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_StimActive)( VX1000_UINT8 stim_event );
+#define VX1000_STIM_ACTIVE(S) VX1000_SUFFUN(vx1000_StimActive)((S))   /* usable in/as an expression */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+extern void VX1000_SUFFUN(vx1000_StimRequest)( VX1000_UINT8 stim_event );
+#define VX1000_STIM_REQUEST(S) VX1000_SUFFUN(vx1000_StimRequest)((S)); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+extern void VX1000_SUFFUN(vx1000_StimSkip)( VX1000_UINT8 stim_event );
+#define VX1000_STIM_SKIP(S) VX1000_SUFFUN(vx1000_StimSkip)((S)); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+
+#if defined(VX1000_STIM_BY_OLDA)
+#if defined(VX1000_OLDA_FORCE_V8)
+extern void VX1000_SUFFUN(vx1000_OldaStimRequestEvent)( VX1000_UINT16 eventNumber );
+#else  /* !VX1000_OLDA_FORCE_V8 */
+extern void VX1000_SUFFUN(vx1000_OldaStimRequestEvent)( VX1000_UINT8 eventNumber );
+#endif /* !VX1000_OLDA_FORCE_V8 */
+#define VX1000_STIM_REQUEST_EVENT(x) VX1000_SUFFUN(vx1000_OldaStimRequestEvent)((x)); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#else /* !VX1000_STIM_BY_OLDA */
+#define VX1000_STIM_REQUEST_EVENT(x) VX1000_EVENT((x)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#endif /* !VX1000_STIM_BY_OLDA */
+
+#else /* !VX1000_STIM */
+
+#define VX1000_STIM_PTR                      0UL /* "invalid" */
+#define VX1000_STIM_WAIT(     E, T)          VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,1, (E),(T),(0),(0))  /* return code for "timeout" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_STIM_WAIT_VOID(E, T)          VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,1, (E),(T),(0),(0)))    /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_STIMULATE(     D, S, P, T)    VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (D),(S),(P),(T)) /* return code for "inactive" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_STIMULATE_VOID(D, S, P, T)    VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (D),(S),(P),(T)))    /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_STIM_ACTIVE(S)                VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (S),(0),(0),(0)) /* return code for "inactive" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_STIM_CONTROL()                /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_STIM_REQUEST(S)               VX1000_DUMMYREAD((S)) /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_STIM_SKIP(S)                  VX1000_DUMMYREAD((S)) /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_CONTROL()              /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_DAQ(     D, S)         VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (D),(S),(0),(0)) /* return code for "inactive" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_DAQ_VOID(D, S)         VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (D),(S),(0),(0)))    /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_STIM(      S)          VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (S),(0),(0),(0)) /* return code for "inactive" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_STIM_VOID( S)          VX1000_DUMMYREAD(S) /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_TRIGGER(     D, S)     VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (D),(S),(0),(0)) /* return code for "inactive" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_TRIGGER_VOID(D, S)     VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (D),(S),(0),(0)))    /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_WAIT(     S, T)        VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (S),(T),(0),(0)) /* return code for "inactive" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_WAIT_VOID(S, T)        VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (S),(T),(0),(0)))    /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS(     D, S, T)          VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (D),(S),(T),(0)) /* return code for "inactive" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_VOID(D, S, T)          VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (D),(S),(T),(0)))    /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_REGISTER_STIM_EVENT(D, S, T)  VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,0, (D),(S),(T),(0)))   /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_STIM_DURARRAY_PTR             0UL
+
+#endif /* !VX1000_STIM */
+
+/* Hook based bypassing macros */
+#if defined(VX1000_HOOK_BASED_BYPASSING) && defined(VX1000_STIM)
+
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassHbbGetVal_8) ( VX1000_UINT32 HookID, VX1000_UINT8 DefaultValue );
+#define VX1000_BYPASS_HBB_GETVAL_8( H, D )      VX1000_SUFFUN(vx1000_BypassHbbGetVal_8) ((H), (D))      /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+extern VX1000_UINT16 VX1000_SUFFUN(vx1000_BypassHbbGetVal_16) ( VX1000_UINT32 HookID, VX1000_UINT16 DefaultValue );
+#define VX1000_BYPASS_HBB_GETVAL_16( H, D )     VX1000_SUFFUN(vx1000_BypassHbbGetVal_16) ((H), (D))     /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+extern VX1000_UINT32 VX1000_SUFFUN(vx1000_BypassHbbGetVal_32) ( VX1000_UINT32 HookID, VX1000_UINT32 DefaultValue );
+#define VX1000_BYPASS_HBB_GETVAL_32( H, D )     VX1000_SUFFUN(vx1000_BypassHbbGetVal_32) ((H), (D))     /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+extern VX1000_UINT64 VX1000_SUFFUN(vx1000_BypassHbbGetVal_64) ( VX1000_UINT32 HookID, VX1000_UINT64 DefaultValue );
+#define VX1000_BYPASS_HBB_GETVAL_64( H, D )     VX1000_SUFFUN(vx1000_BypassHbbGetVal_64) ((H), (D))     /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+extern VX1000_FLOAT VX1000_SUFFUN(vx1000_BypassHbbGetVal_Float) ( VX1000_UINT32 HookID, VX1000_FLOAT DefaultValue );
+#define VX1000_BYPASS_HBB_GETVAL_FLOAT( H, D )  VX1000_SUFFUN(vx1000_BypassHbbGetVal_Float) ((H), (D))  /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+extern VX1000_DOUBLE VX1000_SUFFUN(vx1000_BypassHbbGetVal_Double) ( VX1000_UINT32 HookID, VX1000_DOUBLE DefaultValue );
+#define VX1000_BYPASS_HBB_GETVAL_DOUBLE( H, D ) VX1000_SUFFUN(vx1000_BypassHbbGetVal_Double) ((H), (D)) /* usable in/as an expression  */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+
+#else /* !VX1000_HOOK_BASED_BYPASSING || !VX1000_STIM */
+
+#define VX1000_BYPASS_HBB_GETVAL_8( H, D )      ((VX1000_UINT8)(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,(D), (H),(0),(0),(0))))   /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_HBB_GETVAL_16( H, D )     ((VX1000_UINT16)(VX1000_DISCARD4DUMMYARGS(VX1000_UINT16,(D), (H),(0),(0),(0)))) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_HBB_GETVAL_32( H, D )     VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(D), (H),(0),(0),(0))   /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_HBB_GETVAL_64( H, D )     VX1000_DISCARD4DUMMYARGS((VX1000_UINT64),(D), (H),(0),(0),(0)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_HBB_GETVAL_FLOAT( H, D )  VX1000_DISCARD4DUMMYARGS(VX1000_FLOAT,(D), (H),(0),(0),(0))    /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_BYPASS_HBB_GETVAL_DOUBLE( H, D ) VX1000_DISCARD4DUMMYARGS(VX1000_DOUBLE,(D), (H),(0),(0),(0))   /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+
+#endif /* !VX1000_HOOK_BASED_BYPASSING || !VX1000_STIM */
+
+
+/*------------------------------------------------------------------------------ */
+/* Calibration                                                                   */
+
+#if defined(VX1000_CAL)
+
+#include "cc_autosar.h"
+#define CC_PTR                         (VX1000_PTR2V_TO_ADDRESS(&gCC))
+
+#else /* !VX1000_CAL */
+
+#define CC_PTR                         0UL
+
+#endif /* !VX1000_CAL */
+
+
+/*------------------------------------------------------------------------------ */
+/* Overlay                                                                       */
+
+#if defined(VX1000_OVERLAY)
+
+#define VX1000_OVL_MAGIC                 0xfec70a17UL
+#define VX1000_EMEM_HDR_MAGIC            0xfec81b28UL
+
+#define VX1000_OVLFEAT_KEEP_AWAKE        (1UL << 0) /* VX may suppress ECU falling asleep and/or shut down */
+#define VX1000_OVLFEAT_SYNC_PAGESWITCH   (1UL << 1) /* ... */
+#define VX1000_OVLFEAT_PERSISTENT_EMEM   (1UL << 2) /* ... */
+#define VX1000_OVLFEAT_RST_ON_CALWAKEUP  (1UL << 3) /* ... */
+#define VX1000_OVLFEAT_USE_VX_EPK_TRANS  (1UL << 4) /* ... */
+#define VX1000_OVLFEAT_VALIDATE_PAGESW   (1UL << 5) /* ... */
+#define VX1000_OVLFEAT_CORE_SYNC_PAGESW  (1UL << 6) /* After a page switch request, cores will switch their respective pages individually */
+#define VX1000_OVLFEAT_NONE              (0x0UL << 7)
+#define VX1000_OVLFEAT_USER              (0x1UL << 7)
+#define VX1000_OVLFEAT_DRIVER            (0x2UL << 7)
+#define VX1000_OVLFEAT_VX                (0x3UL << 7)
+#define VX1000_OVLFEAT_ECU_REGS_VIA_MX   (1UL << 9)  /* overlay registers are configured over mailbox */
+#define VX1000_OVLFEAT_RST_ON_SNCPAGESW  (1UL << 10) /* ECU will perform an ECU Reset on Sync_Cal_Page_Switch */
+
+#if defined(VX1000_TARGET_POWERPC)
+typedef struct s_ecu_ovl_descriptor
+{    /* 4x4 = 16B = 0x10 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 MAS0;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 MAS1;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 MAS2;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 MAS3;
+} VX1000_OVL_DESCRIPTOR_T;
+typedef struct s_ecu_ovl_config_regs
+{   /* 16*1*64 + 4*2 + 2 + 2 = 1036 = 0x40C Bytes */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 magicId;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 version;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 reserved1;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 reserved2;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_OVL_DESCRIPTOR_T DESCR[64];   /* for all cores, the descriptors need the same value; there are maximum 64 descriptors in the hardware */
+} VX1000_OVL_CONFIG_REGS_T;
+#endif /* VX1000_TARGET_POWERPC */
+
+#if defined(VX1000_TARGET_SH2)
+typedef struct s_ecu_ovl_descriptor
+{    /* 4x4 = 16B = 0x10 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 TODO_SH2;
+} VX1000_OVL_DESCRIPTOR_T;
+typedef struct s_ecu_ovl_config_regs
+{   /* 16*1*64 + 4*2 + 2 + 2 = 1036 = 0x40C Bytes */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 TODO_SH2;
+} VX1000_OVL_CONFIG_REGS_T;
+#endif /* VX1000_TARGET_SH2 */
+
+#if defined(VX1000_TARGET_TMS570)
+typedef struct s_ecu_ovl_descriptor
+{    /* 4x4 = 16B = 0x10 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 TODO_TMS570;
+} VX1000_OVL_DESCRIPTOR_T;
+typedef struct s_ecu_ovl_config_regs
+{   /* 16*1*64 + 4*2 + 2 + 2 = 1036 = 0x40C Bytes */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 TODO_TMS570;
+} VX1000_OVL_CONFIG_REGS_T;
+#endif /* VX1000_TARGET_TMS570 */
+
+#if defined(VX1000_TARGET_TRICORE)
+typedef struct s_ecu_ovl_descriptor
+{    /* 4x3 = 12B = 0xC */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 RABR;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 OTAR;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 OMASK;
+} VX1000_OVL_DESCRIPTOR_T;
+typedef struct s_ecu_ovl_config_regs
+{   /* 12*1*32 + 4*2 + 2 + 2 = 396 = 0x18C Bytes */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 magicId;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 version;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 reserved;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 OSEL;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_OVL_DESCRIPTOR_T DESCR[32];   /* for all cores, the descriptors need the same value; there are maximum 32 descriptors in the hardware */
+} VX1000_OVL_CONFIG_REGS_T;
+#endif /* VX1000_TARGET_TRICORE */
+
+#if defined(VX1000_TARGET_X850)
+typedef struct s_ecu_ovl_descriptor
+{    /* 4x4 = 16B = 0x10 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 TODO_x850;
+} VX1000_OVL_DESCRIPTOR_T;
+typedef struct s_ecu_ovl_config_regs
+{   /* 16*1*64 + 4*2 + 2 + 2 = 1036 = 0x40C Bytes */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 TODO_x850;
+} VX1000_OVL_CONFIG_REGS_T;
+#endif /* VX1000_TARGET_X850 */
+
+#if defined(VX1000_TARGET_XC2000)
+typedef struct s_ecu_ovl_descriptor
+{    /* 4x4 = 16B = 0x10 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 TODO_XC2000;
+} VX1000_OVL_DESCRIPTOR_T;
+typedef struct s_ecu_ovl_config_regs
+{   /* 16*1*64 + 4*2 + 2 + 2 = 1036 = 0x40C Bytes */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 TODO_XC2000;
+} VX1000_OVL_CONFIG_REGS_T;
+#endif /* VX1000_TARGET_XC2000 */
+
+typedef struct s_ecu_page_switch
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 magicId;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 version;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  pageSwitchRequested;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  targetPage;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 overlayValue;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 overlayMask;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 busMasterRequested;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  coreDone[32];
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 overlayValueB;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 overlayMaskB;
+} VX1000_SYNCAL_PAGE_SWITCH_T;
+
+/* Structure for EMEM invalidation when cal-wakeup and EMEM-supply is used */
+typedef struct s_ecu_emem_hdr
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 magicId;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 version;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 reserved;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ememInitEnd;           /* VX-RW, ECU-RO */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ememInitEndInvert;     /* VX-RW, ECU-RO */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ememInitStart;         /* VX-RW, ECU-RW */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ememInitStartInvert;   /* VX-RW, ECU-RW */
+#define VX1000_EMEM_HDR_VERSION 1
+} VX1000_EMEM_HDR_T;
+
+typedef struct
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 magicId;                        /* 0x00 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 version;                        /* 0x04 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 presenceCounter;                /* 0x06 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ovlConfigValue;                 /* 0x08 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ovlConfigMask;                  /* 0x0C */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 calFeaturesEnable;              /* 0x10 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 persistentECUEmemHeaderPtr;     /* 0x14 */    /* actually a segmented-huge-ptr to VX1000_EMEM_HDR_T */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ovlBusMasterMask;               /* 0x18 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 ecuLastPresenceCounter;         /* 0x1C */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 ovlEPKLength;                   /* 0x1E */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ovlReferencePageDataEPKAddress; /* 0x20 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ovlWorkingPageDataEPKAddress;   /* 0x24 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 syncCalSwitchDataPtr;           /* 0x28 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ovlConfigRegsPtr;               /* 0x2C */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ovlConfigValueB;                /* 0x30 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ovlConfigMaskB;                 /* 0x34 */
+  VX1000_SYNCAL_PAGE_SWITCH_T syncCalData;                                  /* 0x38 */
+  VX1000_OVL_CONFIG_REGS_T ovlConfigRegs;
+#define VX1000_OVL_VERSION             5
+} VX1000_OVL_T;
+
+#define VX1000_OVL_DATA                VX1000_OVL_T Ovl
+#define VX1000_OVL_PTR                 (VX1000_PTR2VO_TO_ADDRESS(&gVX1000.Ovl))
+#define VX1000_CAL_WAKEUP_REQUESTED()  ((gVX1000.ToolCtrlState & ((VX1000_UINT32)(VX1000_TCS_CAL_WAKEUP))) != 0) /* Wrapper API:   VX1000If_CalWakeupRequested */
+
+#if defined(VX1000_OVLENBL_KEEP_AWAKE)
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_IsCalWakeupActive)( void );
+#define VX1000_IS_CAL_WAKEUP_ACTIVE()  VX1000_SUFFUN(vx1000_IsCalWakeupActive)()
+#else /* !VX1000_OVLENBL_KEEP_AWAKE */
+#define VX1000_IS_CAL_WAKEUP_ACTIVE()  0 /* provide return value for "not active" */
+#endif /* !VX1000_OVLENBL_KEEP_AWAKE */
+
+#if defined(VX1000_OVLENBL_SYNC_PAGESWITCH)
+#if !defined(VX1000_OVL_SET_CONFIG)
+#define VX1000_OVL_SET_CONFIG_INTERNAL
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlaySetConfig)(VX1000_UINT32 value, VX1000_UINT32 mask, VX1000_UINT32 valueB, VX1000_UINT32 maskB, VX1000_UINT8 page, VX1000_UINT32 master, VX1000_UINT32 calMaster);
+#define VX1000_OVL_SET_CONFIG(value,mask,valueB,maskB,page,master,calMasters) VX1000_SUFFUN(vx1000_OverlaySetConfig)((value),(mask),(valueB),(maskB),(page),(master),(calMasters)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_OVL_SET_CONFIG_VOID(value,mask,valueB,maskB,page,master,calMasters) (void)VX1000_OVL_SET_CONFIG((value),(mask),(valueB),(maskB),(page),(master),(calMasters)); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#endif /* !VX1000_OVL_SET_CONFIG */
+
+extern void VX1000_SUFFUN(vx1000_OverlaySetConfigDone)( VX1000_UINT8 cfgResult, VX1000_UINT8 page, VX1000_UINT8 onStartup );
+#define VX1000_OVL_SET_CONFIG_DONE(result, page) VX1000_SUFFUN(vx1000_OverlaySetConfigDone)((result),(page), 0); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#define VX1000_OVL_SET_CONFIG_DONE_STUP(result,page) VX1000_SUFFUN(vx1000_OverlaySetConfigDone)((result),(page), 1); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlayChkPageSwitchDone)( void );
+#define VX1000_OVL_CHK_PAGESW_DONE() VX1000_SUFFUN(vx1000_OverlayChkPageSwitchDone)()
+#define VX1000_OVL_CHK_PAGESW_DONE_VOID()  (void)VX1000_OVL_CHK_PAGESW_DONE(); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlayChkPageSwitchCore)( VX1000_UINT32 master );
+#define VX1000_OVL_CHK_PAGESW_CORE(cores) VX1000_SUFFUN(vx1000_OverlayChkPageSwitchCore)((cores)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_OVL_CHK_PAGESW_CORE_VOID(cores) (void)VX1000_OVL_CHK_PAGESW_CORE((cores)); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_overlayIsPageSwitchReq)( VX1000_UINT32 master );
+#define VX1000_OVL_IS_PAGESW_REQUESTED(cores) VX1000_SUFFUN(vx1000_overlayIsPageSwitchReq)((cores)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+
+#else /* !VX1000_OVLENBL_SYNC_PAGESWITCH */
+
+#if !defined(VX1000_OVL_SET_CONFIG)
+#define VX1000_OVL_SET_CONFIG(value,mask,valueB,maskB,page,master,calMasters)   VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,(1), (value),(mask),(page),VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(master), (calMasters),(valueB),(maskB),(0))) /* return value for "nothing done" */  /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_OVL_SET_CONFIG_VOID(value,mask,valueB,maskB,page,master,calMasters) VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,(1), (value),(mask),(page),VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(master), (calMasters),(valueB),(maskB),(0)))) /* return value for "nothing done" */  /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#endif /* !VX1000_OVL_SET_CONFIG */
+#define VX1000_OVL_SET_CONFIG_DONE(result, page)     VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,0UL, (result),(page),(0),(0)))/* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_OVL_SET_CONFIG_DONE_STUP(result,page) VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,0UL, (result),(page),(0),(0)))/* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_OVL_CHK_PAGESW_DONE()                 ((VX1000_UINT8)(1)) /* provide return value "not ready" */
+#define VX1000_OVL_CHK_PAGESW_DONE_VOID()            /* empty */
+#define VX1000_OVL_CHK_PAGESW_CORE(cores)            VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,((VX1000_UINT8)(1)), (cores),(0),(0),(0))/* provide return value "not ready" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_OVL_CHK_PAGESW_CORE_VOID(cores)       VX1000_DUMMYREAD((cores))/* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_OVL_IS_PAGESW_REQUESTED(cores)        VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (cores),(0),(0),(0))/* provide return value "no" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+
+#endif /* !VX1000_OVLENBL_SYNC_PAGESWITCH */
+
+#if defined(VX1000_OVLENBL_PERSISTENT_EMEM)
+#if defined(VX1000_EMEM_HDR_MEMORY_SECTION)
+#define VX1000_EMEM_HDR_DATA           VX1000_EMEM_HDR_MEMORY_SECTION volatile VX1000_EMEM_HDR_T gVXEmemHdr
+#else /* !VX1000_EMEM_HDR_MEMORY_SECTION */
+#define VX1000_EMEM_HDR_DATA           volatile VX1000_EMEM_HDR_T gVXEmemHdr
+#endif /* !VX1000_EMEM_HDR_MEMORY_SECTION */
+#define VX1000_EMEM_HDR_PTR            (VX1000_PTR2VEHM_TO_ADDRESS(&gVXEmemHdr))
+extern void VX1000_SUFFUN(vx1000_InvalidateEmem)( void );
+#define VX1000_INVALIDATE_EMEM()       VX1000_SUFFUN(vx1000_InvalidateEmem)(); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+
+#else /* !VX1000_OVLENBL_PERSISTENT_EMEM */
+
+#define VX1000_EMEM_HDR_PTR            0UL
+#define VX1000_INVALIDATE_EMEM()       /* empty */
+
+#endif /* !VX1000_OVLENBL_PERSISTENT_EMEM */
+
+/* provide empty user callbacks if not already specified by the user: */
+#if !defined(VX1000_OVL_RST_ON_CAL_WAKEUP_CB)
+#define VX1000_OVL_RST_ON_CAL_WAKEUP_CB() /* empty */
+#endif /* !VX1000_OVL_RST_ON_CAL_WAKEUP_CB */
+
+
+#else /* !VX1000_OVERLAY */
+
+#define VX1000_OVL_PTR                 0UL
+#define VX1000_EMEM_HDR_PTR            0UL
+#define VX1000_INVALIDATE_EMEM()       /* empty */
+#define VX1000_CAL_WAKEUP_REQUESTED()  0 /* provide return value for "no request" */
+#define VX1000_IS_CAL_WAKEUP_ACTIVE()  0 /* provide return value for "not active" */
+#if !defined(VX1000_OVL_SET_CONFIG)
+#define VX1000_OVL_SET_CONFIG(value,mask,valueB,maskB,page,master,calMasters)      VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,(1), (value),(mask),(page),VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(master), (calMasters),(valueB),(maskB),(0)))  /* return value for "nothing done" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_OVL_SET_CONFIG_VOID(value,mask,valueB,maskB,page,master,calMasters) VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,(1), (value),(mask),(page),VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(master), (calMasters),(valueB),(maskB),(0))))  /* return value for "nothing done" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#endif /* !VX1000_OVL_SET_CONFIG */
+#define VX1000_OVL_SET_CONFIG_DONE(result, page)                      VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,0UL, (result),(page),(0),(0)))/* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_OVL_SET_CONFIG_DONE_STUP(result,page)                  VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,0UL, (result),(page),(0),(0)))/* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_OVL_CHK_PAGESW_DONE()                                  ((VX1000_UINT8)(1))         /* provide return value for "not ready" ? */
+#define VX1000_OVL_CHK_PAGESW_DONE_VOID()                             /* empty */
+#define VX1000_OVL_CHK_PAGESW_CORE(cores)                             VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,((VX1000_UINT8)(1)), (cores),(0),(0),(0))/* provide return value for "not ready" ? */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_OVL_CHK_PAGESW_CORE_VOID(cores)                        VX1000_DUMMYREAD((cores))/* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_OVL_IS_PAGESW_REQUESTED(cores)                         VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,0, (cores),(0),(0),(0))/* provide return value "no" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#endif /* !VX1000_OVERLAY */
+
+/*------------------------------------------------------------------------------ */
+/* VX1000_RES_MGMT                                                               */
+/* Note: this is a pure project specific feature.                                */
+/* The specification comes from the customer, so do not improve.                 */
+
+#if defined(VX1000_RES_MGMT)
+
+#define VX1000_RES_MGMT_MAGIC          0xFEC70A18UL
+
+typedef struct
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 magicId;                 /* 0x00 */ /* Version 2 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 version;                 /* 0x04 */
+  /* Resource 0 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  ovlConfigItemStart;      /* 0x06 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  ovlConfigItemLength;     /* 0x07 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 resMgmtEnable;           /* 0x08 */
+  /* Resource 1 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ovlRamStart;             /* 0x0C */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 ovlRamSize;              /* 0x10 */
+} VX1000_RES_MGMT_T;
+
+#define VX1000_RES_MGMT_RES_CONFIG_ITEM (1UL << 0)
+#define VX1000_RES_MGMT_RES_OVL_RAM    (1UL << 1)
+
+#define VX1000_RES_MGMT_DATA           VX1000_RES_MGMT_T ResMgmt
+#define VX1000_RES_MGMT_PTR            (VX1000_PTR2VRM_TO_ADDRESS(&gVX1000.ResMgmt))
+#define VX1000_ENABLE_ACCESS()         gVX1000.ToolDetectState &= ~(VX1000_TDS_VX_ACCESS_DISABLED); /* Wrapper API:   VX1000If_EnableAccess */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_DisableAccess)( void );
+#define VX1000_DISABLE_ACCESS()        VX1000_SUFFUN(vx1000_DisableAccess)()
+#define VX1000_DISABLE_ACCESS_VOID()   (void)VX1000_SUFFUN(vx1000_DisableAccess)(); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#define VX1000_IS_ACCESS_DISABLED()    ((gVX1000.ToolDetectState & (VX1000_TDS_VX_ACCESS_DISABLED)) != 0UL) /* Wrapper API:   VX1000If_IsAccessDisabled */
+#define VX1000_RES_MGMT_VERSION        1
+
+/* Resource Overlay Configuration Item */
+#if !defined(VX1000_RES_MGMT_CFG_ITEM_START)
+#define VX1000_RES_MGMT_CFG_ITEM_START 0
+#endif /* !VX1000_RES_MGMT_CFG_ITEM_START */
+
+#if !defined(VX1000_RES_MGMT_CFG_ITEM_LEN)
+#define VX1000_RES_MGMT_CFG_ITEM_LEN   32
+#endif /* !VX1000_RES_MGMT_CFG_ITEM_LEN */
+
+#if !defined(VX1000_RES_MGMT_ENABLE_CFG_ITEM)
+#define VX1000_RES_MGMT_ENBLVAL_CFG_ITEM 0
+#else /* VX1000_RES_MGMT_ENABLE_CFG_ITEM */
+#define VX1000_RES_MGMT_ENBLVAL_CFG_ITEM VX1000_RES_MGMT_RES_CONFIG_ITEM
+#endif /* VX1000_RES_MGMT_ENABLE_CFG_ITEM */
+
+/* Resource Ram */
+#if !defined(VX1000_RES_MGMT_RAM_START)
+#define VX1000_RES_MGMT_RAM_START  0
+#endif /* !VX1000_RES_MGMT_RAM_START */
+
+#if !defined(VX1000_RES_MGMT_RAM_SIZE)
+#define VX1000_RES_MGMT_RAM_SIZE   0
+#endif /* !VX1000_RES_MGMT_RAM_SIZE */
+
+#if !defined(VX1000_RES_MGMT_ENABLE_OVL_RAM)
+#define VX1000_RES_MGMT_ENBLVAL_OVL_RAM 0
+#else /* VX1000_RES_MGMT_ENABLE_OVL_RAM */
+#define VX1000_RES_MGMT_ENBLVAL_OVL_RAM VX1000_RES_MGMT_RES_OVL_RAM
+#endif /* VX1000_RES_MGMT_OVL_ENABLE */
+
+
+#else /* !VX1000_RES_MGMT */
+
+#define VX1000_DISABLE_ACCESS_VOID()   /* empty */
+#define VX1000_DISABLE_ACCESS()        (0) /* provide return value for "there is no VX anyway" */
+#define VX1000_ENABLE_ACCESS()         /* empty */
+#define VX1000_IS_ACCESS_DISABLED()    (1) /* provide return value for "tool is disabled" */
+#define VX1000_RES_MGMT_PTR            0UL
+
+#endif /* !VX1000_RES_MGMT */
+
+typedef struct
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 MagicId;               /* 0x00 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  StructVersion;         /* 0x04 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  Reserved0;             /* 0x05 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16 Reserved1;             /* 0x06 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 MemSync_0;             /* 0x08 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 MemSync_1;             /* 0x0C */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 MemSync_2;             /* 0x10 */
+} VX1000_MEMSYNC_TRIG_T;
+#define VX1000_STRUCT_MAGIC_MEMSYNCTRIG 0xFEC72016UL
+
+typedef struct
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 MagicId;               /* 0x00 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  StructVersion;         /* 0x04 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  SyncWinStatus;         /* 0x05 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  SyncMasterId;          /* 0x06 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8  SyncTriggerId;         /* 0x07 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 SyncWinStart;          /* 0x08 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 SyncWinSize;           /* 0x0C */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32 SyncChunkSize;         /* 0x10 */
+} VX1000_MEMSYNC_CPY_T;
+#define VX1000_STRUCT_MAGIC_MEMSYNCCPY 0xFEC70815UL
+
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) == 0)
+#define VX1000_MEMSYNC_TRIGGER_PTR     0UL
+#elif ((VX1000_MEMSYNC_TRIGGER_COUNT) == 1)
+#if !defined(VX1000_MEMSYNC_TRIGGER_PTR)
+#define VX1000_MEMSYNCTRIG_DATA        VX1000_MEMSYNC_TRIG_T MemSyncTrigger
+#define VX1000_MEMSYNC_TRIGGER_PTR     (VX1000_PTR2MT_TO_ADDRESS(&gVX1000.MemSyncTrigger))
+#endif /* !VX1000_MEMSYNC_TRIGGER_PTR */
+#else  /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+#define VX1000_MEMSYNCTRIG_DATA        VX1000_UINT32 MemSyncTrigger[VX1000_MEMSYNC_TRIGGER_COUNT]
+#define VX1000_MEMSYNC_TRIGGER_PTR     (VX1000_PTR2U32_TO_ADDRESS(gVX1000.MemSyncTrigger))
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+#if ((VX1000_MEMSYNC_COPY_COUNT) == 0)
+#define VX1000_MEMSYNC_COPY_PTR        0UL
+#else  /* VX1000_MEMSYNC_COPY_COUNT */
+#define VX1000_MEMSYNCCPY_DATA         VX1000_MEMSYNC_CPY_T MemSyncCopy[VX1000_MEMSYNC_COPY_COUNT]
+#define VX1000_MEMSYNC_COPY_PTR        (VX1000_PTR2MC_TO_ADDRESS(gVX1000.MemSyncCopy))
+#endif /* VX1000_MEMSYNC_COPY_COUNT */
+
+#if !defined(VX1000_ADDONS_INIT)
+#define VX1000_ADDONS_INIT()           /* empty */
+#endif /* !VX1000_ADDONS_INIT */
+#if !defined(VX1000_ADDONS_DASDAQ_OLDACMD)
+#define VX1000_ADDONS_DASDAQ_OLDACMD(A, B, C, D, E) VX1000_ERRLOGGER(VX1000_ERRLOG_OLDA_UNIMPLCMD)  /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to overload a simple default implementation by a premium version implemented in an optional source file */
+#endif /* VX1000_ADDONS_DASDAQ_OLDACMD */
+#if !defined(VX1000_ADDONS_DASSTIM_OLDACMD)
+#define VX1000_ADDONS_DASSTIM_OLDACMD(A, B, C, D, E) VX1000_ERRLOGGER(VX1000_ERRLOG_OLDA_UNIMPLCMD) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to overload a simple default implementation by a premium version implemented in an optional source file */
+#endif /* VX1000_ADDONS_DASSTIM_OLDACMD */
+
+
+#if defined(VX1000_DISABLE_INSTRUMENTATION)
+
+#define VX1000_DATA                     /* empty */
+#define VX1000_INIT()                   /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_INIT_ASYNC_START()       /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_INIT_ASYNC_END()         /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_PREPARE_SOFTRESET_VOID() /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_PREPARE_SOFTRESET()      (0) /* provide return value for "accepted" */
+#define VX1000_EVENT(e)                 VX1000_DUMMYREAD((e)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_TIMESTAMP_EVENT(e, t)    VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,0UL, (e),(t),(0),(0))) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_TIMESTAMP_UPDATE(t)      VX1000_DUMMYREAD((t)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_TIMESTAMP()              /* empty */
+
+#else /* !VX1000_DISABLE_INSTRUMENTATION */
+
+/*------------------------------------------------------------------------------ */
+/* User functions and macros for DAQ                                             */
+
+#if defined(VX1000_OLDA)
+
+#if defined(VX1000_OLDA_FORCE_V8)
+/* Trigger a universal event (TRACE or OLDA; event numbers 0 to 0xFFFE) */
+#else /* !VX1000_OLDA_FORCE_V8 */
+/* Trigger a universal event (TRACE or OLDA; event numbers 0 to 30) */
+#endif /* !VX1000_OLDA_FORCE_V8 */
+#define VX1000_EVENT(x)                VX1000_OLDA_EVENT((x)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+
+/* Trigger a special event (EventNumber=0..0xFFFFFFFF, OldaEventNumbers=31/30) */
+/* Note that we can\'t do the "gVX1000.Olda.EventList[31].EventCounter += 2;" because the array\'s */
+/* size is dynamically assigned by the VX at runtime depending on the current DAQ configuration! */
+#if defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_SPECIAL_EVENT(e)        VX1000_SUFFUN(vx1000_OldaEvent)(0U, (e)); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#define VX1000_SPECIAL_EVENT2(e)       VX1000_SPECIAL_EVENT((e)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#elif ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+#define VX1000_SPECIAL_EVENT(e)        VX1000_SUFFUN(vx1000_OldaSpecialEvent)((e)); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#define VX1000_SPECIAL_EVENT2(e)       VX1000_SPECIAL_EVENT((e)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#else /* !VX1000_OLDA_FORCE_V8 */
+#define VX1000_STORE_SPECIAL_EVENT(e) do                                                                              \\
+  {                                                                                                                   \\
+    VX1000_STORE_TIMESTAMP((VX1000_CLOCK()))                                                                          \\
+    VX1000_STORE_EVENT((VX1000_UINT32)(e))                                                                            \\
+  } while(0) /* this never-looping while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#if defined(VX1000_SUPPRESS_TRACE_SUPPORT) || defined(VX1000_TARGET_TRICORE)
+#if defined(VX1000_OLDA_AUDMBR_REG_ADDR)
+#define VX1000_TRIGGER_SPECIAL_EVENT() do                                                                             \\
+  {                                                                                                                   \\
+    (VX1000_ADDR_TO_PTR2VU16(VX1000_OLDA_AUDMBR_REG_ADDR))[0] = (1U << 15U);                                          \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#elif defined(VX1000_OLDA_DTS_BASE_ADDR)
+#define VX1000_TRIGGER_SPECIAL_EVENT() do                                                                             \\
+  {                                                                                                                   \\
+    VX1000_ADD_MPC_TRIGS(31);                                                                                         \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#elif defined(VX1000_TARGET_TRICORE)
+#define VX1000_TRIGGER_SPECIAL_EVENT() do                                                                             \\
+  {                                                                                                                   \\
+      if (VX1000_ECU_IS_AURIX()) { VX1000_MCREG_OCDS_TRIGS = 31UL;         }                                          \\
+      else                       { VX1000_MCREG_OCDS_TRIGS = 0x80000000UL; }                                          \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#elif defined(VX1000_TARGET_XC2000)
+#define VX1000_TRIGGER_SPECIAL_EVENT() do                                                                             \\
+  {                                                                                                                   \\
+      gVX1000.OldaEventNumber ^= (VX1000_UINT32)0x80000000UL;                                                         \\
+      gVX1000.CalPtr          ^= (VX1000_UINT32)0x80000000UL;                                                         \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#else /* classic olda event trigger */
+#define VX1000_TRIGGER_SPECIAL_EVENT() do                                                                             \\
+  {                                                                                                                   \\
+    VX1000_ATOMIC_XOR32X2((/*(VX1000_UINT32)*/&gVX1000.OldaEventNumber), 0x80000000UL);                               \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#define VX1000_SPECIAL_EVENT_BARRIER() do                                                                             \\
+  {                                                                                                                   \\
+    VX1000_ARM_DSB()                                                                                                  \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#endif /* classic olda event trigger */
+#else  /* !VX1000_SUPPRESS_TRACE_SUPPORT && !VX1000_TARGET_TRICORE */
+/* No need for process serialisation - just trigger a trace event but care for instruction serialisation */
+#define VX1000_TRIGGER_SPECIAL_EVENT() /* empty */
+#define VX1000_SPECIAL_EVENT_BARRIER() do                                                                             \\
+  {                                                                                                                   \\
+    VX1000_ARM_DSB()                                                                                                  \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#endif /* !VX1000_SUPPRESS_TRACE_SUPPORT && !VX1000_TARGET_TRICORE */
+#endif /* !VX1000_OLDA_FORCE_V8 */
+
+#if defined(VX1000_TARGET_TRICORE)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: None                                                                                                        */
+/* API name:      VX1000_TRACE_EVENT                                                                                          */
+/* Wrapper API:   None                                                                                                        */
+/* Parameter1:    eventNumber E [0,512)                                                                                       */
+/* Return value:  None                                                                                                        */
+/* Preemption:    No problem                                                                                                  */
+/* Termination:   No effect                                                                                                   */
+/* Precondition1:                                                                                                             */
+/* Description:   Trigger a TriCore specific TRACE event for the XCP master.                                                  */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+#define VX1000_TRACE_EVENT(e) do               \\
+  {                                            \\
+    VX1000_STORE_TIMESTAMP((VX1000_CLOCK()))   \\
+    VX1000_STORE_EVENT((VX1000_UINT32)(e))     \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#endif /* VX1000_TARGET_TRICORE */
+
+#if !defined(VX1000_SPECIAL_EVENT)
+#if !defined(VX1000_SPECIAL_EVENT_BARRIER)
+#define VX1000_SPECIAL_EVENT_BARRIER() /* empty */
+#endif /* !VX1000_SPECIAL_EVENT_BARRIER */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: None or vx1000_OldaEvent (depending on configuration)                                                       */
+/* API name:      VX1000_SPECIAL_EVENT                                                                                        */
+/* Wrapper API:   None                                                                                                        */
+/* Parameter1:    special eventNumber                                                                                         */
+/* Return value:  None                                                                                                        */
+/* Preemption:    No problem                                                                                                  */
+/* Termination:   No effect                                                                                                   */
+/* Precondition1:                                                                                                             */
+/* Description:   Trigger a special event for VX internal status synchronisation                                              */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+#define VX1000_SPECIAL_EVENT(e) do             \\
+  {                                            \\
+    VX1000_STORE_SPECIAL_EVENT(e);             \\
+    VX1000_TRIGGER_SPECIAL_EVENT()             \\
+    VX1000_SPECIAL_EVENT_BARRIER()             \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#define VX1000_SPECIAL_EVENT2(e) do            \\
+  {                                            \\
+    VX1000_STORE_SPECIAL_EVENT(e);             \\
+    VX1000_SPECIAL_EVENT_BARRIER()             \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#endif /* !VX1000_SPECIAL_EVENT */
+
+#else /* !VX1000_OLDA */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: None or vx1000_OldaEvent (depending on configuration)                                                       */
+/* API name:      VX1000_EVENT                                                                                                */
+/* Wrapper API:   VX1000If_Event                                                                                              */
+/* Parameter1:    eventNumber E [0,512)                                                                                       */
+/* Return value:  None                                                                                                        */
+/* Preemption:    No problem                                                                                                  */
+/* Termination:   No effect                                                                                                   */
+/* Precondition1:                                                                                                             */
+/* Description:   Trigger a normal TRACE event for the XCP master.                                                            */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+#define VX1000_EVENT(e) do                     \\
+  {                                            \\
+    VX1000_STORE_TIMESTAMP((VX1000_CLOCK()))   \\
+    VX1000_STORE_EVENT((e))                    \\
+    VX1000_ARM_DSB()                           \\
+  } while(0); /* this never-looping while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+
+#define VX1000_SPECIAL_EVENT(e)        VX1000_EVENT((e)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_SPECIAL_EVENT2(e)       VX1000_SPECIAL_EVENT((e)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+
+/* Update the ECU timestamp with a given value */
+#define VX1000_TIMESTAMP_UPDATE(t)             \\
+  VX1000_STORE_TIMESTAMP((VX1000_UINT32)(t)) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+
+#endif /* !VX1000_OLDA */
+
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: None                                                                                                        */
+/* API name:      VX1000_TIMESTAMP_EVENT                                                                                      */
+/* Wrapper API:   None                                                                                                        */
+/* Parameter1:    eventNumber E [0,512)                                                                                       */
+/* Parameter2:    timestamp (32bit upwards counting)                                                                          */
+/* Return value:  None                                                                                                        */
+/* Preemption:    No problem                                                                                                  */
+/* Termination:   No effect                                                                                                   */
+/* Precondition1:                                                                                                             */
+/* Description:   Trigger an event with a given value for ECU timestamp.                                                      */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+#define VX1000_TIMESTAMP_EVENT(e, t) do          \\
+  {                                              \\
+    VX1000_STORE_TIMESTAMP((VX1000_UINT32)(t))   \\
+    VX1000_STORE_EVENT((e))                      \\
+    VX1000_ARM_DSB()                             \\
+  } while(0); /* this never-loop-while is here only for MISRA */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: None                                                                                                        */
+/* API name:      VX1000_TIMESTAMP                                                                                            */
+/* Wrapper API:   None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Preemption:    No problem                                                                                                  */
+/* Termination:   No effect                                                                                                   */
+/* Precondition1:                                                                                                             */
+/* Description:   Update the timestamp (optional, only needed if timestamp update rate by events is too slow).                */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+#define VX1000_TIMESTAMP() VX1000_STORE_TIMESTAMP((VX1000_CLOCK())) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+
+
+/*------------------------------------------------------------------------------ */
+/* VX1000 data structure                                                         */
+/* Version history (as "new in version"):                                        */
+/*  4: OldaPtr                                                                   */
+/*  5: Olda integrated at fixed position 0x40                                    */
+/*  6: CalPtr                                                                    */
+/*  7: ToolCtrlState (written by tool)                                           */
+/*  8: ResMgmtPtr, OvlPtr                                                        */
+/*  9: FileVersion, FeatureFlags0, TimerXXX, xxxDur-pointers, ErrLog             */
+/* 10: MemSyncXXXPtr, MemSyncXXXCnt, ReleaseNamexxx, BuildNumber                 */
+
+#define VX1000_STRUCT_VERSION          11UL
+#define VX1000_STRUCT_MAGIC            0xFEC70A08UL
+
+#define VX1000_ECUFEAT_FKLINSTRUMENTED     (1UL << 0) /* The application provides support to download and start an external flash kernel*/
+#define VX1000_ECUFEAT_MX_FLASHSTART       (1UL << 1) /* reserved for mailbox flashing */
+#define VX1000_ECUFEAT_MX_FLASHMODIFY      (1UL << 2) /* reserved for mailbox flashing */
+#define VX1000_ECUFEAT_MX_SOFTRESET        (1UL << 3) /* reserved for mailbox flashing */
+#define VX1000_ECUFEAT_MX_CALPAGE_RW       (1UL << 4) /* The application wants to handle calpage up/downloads manually via mailbox callbacks */
+#define VX1000_ECUFEAT_MX_CALPAGE_GSC      (1UL << 5) /* The application provides mailbox handling for get/set/copy calpage commands */
+#define VX1000_ECUFEAT_STIMWT_DURATION     (1UL << 6) /* The application provides a snapshot of all STIM events\' busy waiting times */
+#define VX1000_ECUFEAT_STIMRT_DURATION     (1UL << 7) /* The application provides a snapshot of all STIM events\' round trip times and a global timeout counter */
+#define VX1000_ECUFEAT_STIMRT_HISTOGR      (1UL << 8) /* The application provides a histogram of one STIM event\'s round trip times since ECU boot */
+/* reserved range for DAS:                 (1UL << 9) */
+
+#if !defined(VX1000_ADDONS_FEATUREFLAGS0)
+#define VX1000_ADDONS_FEATUREFLAGS0        0
+#endif /* !VX1000_ADDONS_FEATUREFLAGS0 */
+
+#define VX1000_RELEASECODEH(LIST) VX1000_RELEASECODEH_(LIST) /* PRQA S 3453 */ /* Cannot avoid violating MISRA rule 19.7 because this macro may be used as initialiser of a constant and thus cannot be changed to a runtime function */
+#define VX1000_RELEASECODEB(LIST) VX1000_RELEASECODEB_(LIST) /* PRQA S 3453 */ /* Cannot avoid violating MISRA rule 19.7 because this macro may be used as initialiser of a constant and thus cannot be changed to a runtime function */
+#define VX1000_RELEASECODET(LIST) VX1000_RELEASECODET_(LIST) /* PRQA S 3453 */ /* Cannot avoid violating MISRA rule 19.7 because this macro may be used as initialiser of a constant and thus cannot be changed to a runtime function */
+#define VX1000_RELEASECODEH_(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11) (((VX1000_UINT8)((C0)-\' \')<<2) | ((VX1000_UINT8)((C1)-\' \')>>4)) /* PRQA S 3453 */ /* Cannot avoid violating MISRA rule 19.7 because this macro may be used as initialiser of a constant and thus cannot be changed to a runtime function */
+#define VX1000_RELEASECODEB_(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11) ((((VX1000_UINT32)(((C1)-\' \')&0xF)<<28) | ((VX1000_UINT32)((C2)-\' \')<<22)) | (((VX1000_UINT32)((C3)-\' \')<<16) | ((VX1000_UINT32)((C4)-\' \')<<10))) | (((VX1000_UINT32)((C5)-\' \')<<4) | ((VX1000_UINT32)((C6)-\' \')>>2))  /* PRQA S 3453 */ /* Cannot avoid violating MISRA rule 19.7 because this macro may be used as initialiser of a constant and thus cannot be changed to a runtime function */
+#define VX1000_RELEASECODET_(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11) ((((VX1000_UINT32)(((C6)-\' \')&0x3)<<30) | ((VX1000_UINT32)((C7)-\' \')<<24)) | (((VX1000_UINT32)((C8)-\' \')<<18) | ((VX1000_UINT32)((C9)-\' \')<<12))) | (((VX1000_UINT32)((C10)-\' \')<<6) | ((VX1000_UINT32)((C11)-\' \')>>0)) /* PRQA S 3453 */ /* Cannot avoid violating MISRA rule 19.7 because this macro may be used as initialiser of a constant and thus cannot be changed to a runtime function */
+
+typedef struct
+{
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   EventNumber;         /* 0x00 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   EventTimestamp;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   MagicId;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   Version;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   GetIdPtr;            /* 0x10 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   GetIdLen;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   XcpMailboxPtr;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   StimCtrlPtr;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   RamSynchField;       /* 0x20 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   ToolDetectState;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   OldaPtr;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   OldaEventNumber;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   CalPtr;              /* 0x30 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   ToolCtrlState;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   ErrLogAddr;          /* previous: VX1000_UINT32 TimestampInfoMant is no longer used, redefined in v9 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8    ErrLogSize;          /* previous: VX1000_INT16  TimestampInfoExpDiv, no longer used, redefined in v9 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8    ErrLogIndex;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16   FileVersion;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   ResMgmtPtr;          /* 0x40 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   OvlPtr;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   FeatureFlags0;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   TimerFreqkHz;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   TimerAddr;           /* 0x50 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8    TimerAddrRegion;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8    TimerSize;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8    TimerOffset;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8    TimerDirection;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   StimDurArrayPtr;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   OldaDurArrayPtr;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   MemSyncTrigPtr;      /* 0x60 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   Padding32;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   MemSyncCpyPtr;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8    MemSyncTrigCnt;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8    Padding8;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8    MemSyncCpyCnt;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT8    ReleaseNameHead;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   ReleaseNameBody;     /* 0x70 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   ReleaseNameTail;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   BuildNumber;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   MagicIdSfrAddr;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   StaticLutAddr;       /* 0x80 */
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   DynamicLutAddr;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32   MemsyncLutAddr;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16   DynamicAddressSignalsCnt;
+  VX1000_INNERSTRUCT_VOLATILE VX1000_UINT16   Padding16;
+
+  /* note: no pointer to VX1000_COLDSTART_BENCHMARK_DATA because that info is not settled, yet */
+  /* note: no pointer to VX1000_HOOK_CONTROL_DATA because that part of the driver is typically outsourced now */
+  /* note: no pointers to gVX1000_OLDA_TransferCount[] and gVX1000_OLDA_TransferSize[] because the VX can collect such info internally */
+#if defined(VX1000_MEMSYNCTRIG_DATA)
+  VX1000_MEMSYNCTRIG_DATA;             /* no fix offset */
+#endif /* VX1000_MEMSYNCTRIG_DATA */
+#if defined(VX1000_DYNADDRSIG_DYNAMICLUT_DT)
+  VX1000_DYNADDRSIG_DYNAMICLUT_DT;     /* no fix offset */
+#endif /* VX1000_DYNADDRSIG_DYNAMICLUT_DT */
+#if defined(VX1000_DYNADDRSIG_MEMSYNCLUT_DT)
+  VX1000_DYNADDRSIG_MEMSYNCLUT_DT;     /* no fix offset */
+#endif /* VX1000_DYNADDRSIG_MEMSYNCLUT_DT */
+#if defined(VX1000_OLDA_DATA)
+  VX1000_OLDA_DATA;                    /* no fix offset (note: FW < 1.8 expected 0x40 during cold-start!) */
+#endif /* VX1000_OLDA_DATA */
+#if defined(VX1000_STIM_DATA)
+  VX1000_STIM_DATA;                    /* no fix offset */
+#endif /* VX1000_STIM_DATA */
+#if defined(VX1000_MAILBOX_DATA)
+  VX1000_MAILBOX_DATA;                 /* no fix offset */
+#endif /* VX1000_MAILBOX_DATA */
+#if defined(VX1000_OVL_DATA)
+  VX1000_OVL_DATA;                     /* no fix offset */
+#endif /* VX1000_OVL_DATA */
+#if defined(VX1000_RES_MGMT_DATA)
+  VX1000_RES_MGMT_DATA;                /* no fix offset */
+#endif /* VX1000_RES_MGMT_DATA */
+#if defined(VX1000_ERRLOG_DATA)
+  VX1000_ERRLOG_DATA;                  /* no fix offset */
+#endif /* VX1000_ERRLOG_DATA */
+#if defined(VX1000_MEMSYNCCPY_DATA)
+  VX1000_MEMSYNCCPY_DATA;              /* no fix offset */
+#endif /* VX1000_MEMSYNCCPY_DATA */
+  /* note: other VX data not included by now to not loose backward compatibility of old A2L files; this will be changed changed when */
+  /* there\'d be a user\'s requirement for specific linkage of all VX objects or there is a requirement to split ROM and RAM anyway... */
+} VX1000_STRUCT_T;
+
+/*------------------------------------------------------------------------------ */
+/* VX1000_INIT_ASYNC_START(), VX1000_INIT_ASYNC_END(); legacy VX1000_DATA dummy  */
+/* API for declaring and initialising the global VX1000 data needed for VX1000   */
+/* Must be called before any other VX1000_xxxx() routine is called but _after_   */
+/* timestamp provider has been initialised                                       */
+
+extern void VX1000_SUFFUN(vx1000_Init)(void);
+#define VX1000_INIT() VX1000_SUFFUN(vx1000_Init)(); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+extern void VX1000_SUFFUN(vx1000_InitAsyncStart)(void);
+#define VX1000_INIT_ASYNC_START() VX1000_SUFFUN(vx1000_InitAsyncStart)(); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+extern void VX1000_SUFFUN(vx1000_InitAsyncEnd)(void);
+#define VX1000_INIT_ASYNC_END() VX1000_SUFFUN(vx1000_InitAsyncEnd)(); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+
+#if defined(VX1000_SOFTRESET_TIMEOUT_MS)
+extern VX1000_UINT8 VX1000_SUFFUN(vx1000_PrepareSoftreset)(void);
+#define VX1000_PREPARE_SOFTRESET() VX1000_SUFFUN(vx1000_PrepareSoftreset)() /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_PREPARE_SOFTRESET_VOID() (void)VX1000_SUFFUN(vx1000_PrepareSoftreset)(); /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */ /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to provide configurable API wrappers */
+#else /* !VX1000_SOFTRESET_TIMEOUT_MS */
+#define VX1000_PREPARE_SOFTRESET()      (0) /* provide return value for "accepted" */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#define VX1000_PREPARE_SOFTRESET_VOID() /* empty */ /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 to be able to provide configurable API wrappers */
+#endif /* !VX1000_SOFTRESET_TIMEOUT_MS */
+
+/* Define the global data needed for VX1000 (the user must ensure that the VX1000_STRUCT_DATA part is linked first!) */
+#define VX1000_DATA /* now an empty dummy because the actual data is already declared in VX1000.c module directly! */
+
+/* include user-defined lines with optional section pragmas to force individual linkage of VX1000 structure data. */
+/* Note that we\'re using nested section switches here (which might be unsupported by some compilers but has the  */
+/* advantage of not requiring #undefs as those would violate the MISRA coding guidelines).                       */
+#define VX1000_BEGSECT_VXSTRUCT_H
+#include "VX1000_cfg.h"  /* PRQA S 0883 */ /* Willingly violating MISRA rule 19.15: this file is included multiple times because it contains multiple disjunct parts that each are filtered exactly once by preprocessor conditions */ /* PRQA S 5087*/ /* Willingly violating MISRA rule 19.1: this file is included multiple at exactly those lines where it is needed to expand to the desired lines. Inclusion/expansion of those lines at the top of this file would not make sense and lead to compile errors */
+#define VX1000_BEGSECT_VXSTRUCT_H_UNDO
+
+#if defined(VX1000_TARGET_TRICORE)
+#if defined(VX1000_MEMORY_SECTION)
+#define VX1000_STRUCT_DATA VX1000_MEMORY_SECTION volatile VX1000_STRUCT_T gVX1000
+#elif defined(VX1000_STRUCT_ADDR)
+#define VX1000_STRUCT_DATA volatile VX1000_STRUCT_T gVX1000 __at(VX1000_STRUCT_ADDR) /* TaskingVX syntax */
+#else /* !VX1000_MEMORY_SECTION & !VX1000_STRUCT_ADDR */
+#define VX1000_STRUCT_DATA volatile VX1000_STRUCT_T gVX1000 /* Shall be linked into a memory segment with zero initialisation! */
+#endif /* !VX1000_MEMORY_SECTION & !VX1000_STRUCT_ADDR */
+#elif defined(VX1000_TARGET_XC2000)
+#if defined(VX1000_STRUCT_ADDR)
+#define VX1000_STRUCT_DATA volatile VX1000_STRUCT_T gVX1000 VX1000_OBJAT (VX1000_STRUCT_ADDR) /* TODO: how is the ADDR interpreted? huge? typecast needed? */
+#elif defined(VX1000_MEMORY_SECTION)
+#define VX1000_STRUCT_DATA volatile VX1000_STRUCT_T gVX1000 VX1000_MEMORY_SECTION
+#else /* !VX1000_MEMORY_SECTION & !VX1000_STRUCT_ADDR */
+#define VX1000_STRUCT_DATA volatile VX1000_STRUCT_T gVX1000 /* Shall be linked into a memory segment with zero initialisation! */
+#endif /* !VX1000_MEMORY_SECTION & !VX1000_STRUCT_ADDR */
+#else  /* !VX1000_TARGET_TRICORE & !VX1000_TARGET_XC2000 */
+#if defined(VX1000_STRUCT_ADDR)
+#error "VX1000_STRUCT_ADDR must not be defined (in VX1000_cfg.h), because this feature is not supported for this microcontroller!"
+#else /* !VX1000_STRUCT_ADDR */
+#if defined(VX1000_MEMORY_SECTION)
+#define VX1000_STRUCT_DATA VX1000_MEMORY_SECTION volatile VX1000_STRUCT_T gVX1000
+#else /* !VX1000_MEMORY_SECTION */
+#define VX1000_STRUCT_DATA volatile VX1000_STRUCT_T gVX1000
+#endif /* !VX1000_MEMORY_SECTION */
+#endif /* !VX1000_STRUCT_ADDR */
+#endif /* !VX1000_TARGET_TRICORE & !VX1000_TARGET_XC2000 */
+
+#if defined(VX1000_STRUCT_DATA)
+extern VX1000_STRUCT_DATA;
+#endif /* VX1000_STRUCT_DATA */
+
+/* include user-defined lines with optional section pragmas to restore previous linkage of data: */
+#define VX1000_ENDSECT_VXSTRUCT_H
+#include "VX1000_cfg.h"  /* PRQA S 0883 */ /* Willingly violating MISRA rule 19.15: this file is included multiple times because it contains multiple disjunct parts that each are filtered exactly once by preprocessor conditions */ /* PRQA S 5087*/ /* Willingly violating MISRA rule 19.1: this file is included multiple at exactly those lines where it is needed to expand to the desired lines. Inclusion/expansion of those lines at the top of this file would not make sense and lead to compile errors */
+#define VX1000_ENDSECT_VXSTRUCT_H_UNDO
+
+/* include user-defined lines with optional section pragmas to restore previous linkage of data: */
+#define VX1000_ENDSECT_VXMODULE_H
+#include "VX1000_cfg.h"  /* PRQA S 0883 */ /* Willingly violating MISRA rule 19.15: this file is included multiple times because it contains multiple disjunct parts that each are filtered exactly once by preprocessor conditions */ /* PRQA S 5087*/ /* Willingly violating MISRA rule 19.1: this file is included multiple at exactly those lines where it is needed to expand to the desired lines. Inclusion/expansion of those lines at the top of this file would not make sense and lead to compile errors */
+#define VX1000_ENDSECT_VXMODULE_H_UNDO
+
+#if defined(VX1000_OVLENBL_PERSISTENT_EMEM)
+/* include user-defined lines with optional section pragmas to force individual linkage of EMEM header data. */
+#define VX1000_BEGSECT_EMEM_HDR_H
+#include "VX1000_cfg.h"  /* PRQA S 0883 */ /* Willingly violating MISRA rule 19.15: this file is included multiple times because it contains multiple disjunct parts that each are filtered exactly once by preprocessor conditions */ /* PRQA S 5087*/ /* Willingly violating MISRA rule 19.1: this file is included multiple at exactly those lines where it is needed to expand to the desired lines. Inclusion/expansion of those lines at the top of this file would not make sense and lead to compile errors */
+#define VX1000_BEGSECT_EMEM_HDR_H_UNDO
+
+#if defined(VX1000_EMEM_HDR_DATA)
+extern VX1000_EMEM_HDR_DATA;
+#endif /* VX1000_EMEM_HDR_DATA */
+
+/* include user-defined lines with optional section pragmas to restore previous linkage of data: */
+#define VX1000_ENDSECT_EMEM_HDR_H
+#include "VX1000_cfg.h"  /* PRQA S 0883 */ /* Willingly violating MISRA rule 19.15: this file is included multiple times because it contains multiple disjunct parts that each are filtered exactly once by preprocessor conditions */ /* PRQA S 5087*/ /* Willingly violating MISRA rule 19.1: this file is included multiple at exactly those lines where it is needed to expand to the desired lines. Inclusion/expansion of those lines at the top of this file would not make sense and lead to compile errors */
+#define VX1000_ENDSECT_EMEM_HDR_H_UNDO
+#endif /* VX1000_OVLENBL_PERSISTENT_EMEM */
+
+#endif /* !VX1000_DISABLE_INSTRUMENTATION */
+
+#endif /* !VX1000_H */
+
diff --git a/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/include/VX1000If.h b/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/include/VX1000If.h
new file mode 100644
index 000000000..5a051f42f
--- /dev/null
+++ b/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/include/VX1000If.h
@@ -0,0 +1,967 @@
+/**********************************************************************************************************************
+ *  COPYRIGHT
+ *  -------------------------------------------------------------------------------------------------------------------
+ *  \\verbatim
+ *  Copyright (c) 2017 by Vector Informatik GmbH.                                                  All rights reserved.
+ *
+ *                This software is copyright protected and proprietary to Vector Informatik GmbH.
+ *                Vector Informatik GmbH grants to you only those rights as set out in the license conditions.
+ *                All other rights remain with Vector Informatik GmbH.
+ *  \\endverbatim
+ *  -------------------------------------------------------------------------------------------------------------------
+ *  FILE DESCRIPTION
+ *  -----------------------------------------------------------------------------------------------------------------*/
+ /**       \\file  VX1000If.h
+ *        \\brief  VX1000 Interface header file
+ *
+ *      \\details  Implementation of an API wrapper between ASAM names and proprietary VX1000 driver names.
+ *
+ *********************************************************************************************************************/ 
+
+/**********************************************************************************************************************
+ *  AUTHOR IDENTITY
+ *  -------------------------------------------------------------------------------------------------------------------
+ *  Name                          Initials      Company
+ *  -------------------------------------------------------------------------------------------------------------------
+ *  Oliver Reineke                visore        Vector Informatik GmbH
+ *  -------------------------------------------------------------------------------------------------------------------
+ *  REVISION HISTORY
+ *  -------------------------------------------------------------------------------------------------------------------
+ *  Version   Date        Author  Change Id     Description
+ *  -------------------------------------------------------------------------------------------------------------------
+ *  1.00.00   2015-03-16  visore  ESCAN00082675 FEAT-1488: Implement VX1000 Interface
+ *  1.01.00   2017-02-01  visore  ESCAN00093798 Add support for address update of dynamic-address signals.
+ *  1.02.00   2017-02-17  visore  ESCAN00094061 Add reference to supplemental VX1000If documentation.
+ *********************************************************************************************************************/
+
+#if !defined(VX1000IF_H)
+# define VX1000IF_H
+
+/**********************************************************************************************************************
+ *  INCLUDES
+ *********************************************************************************************************************/
+# include "Std_Types.h"
+# include "VX1000.h"
+
+/**********************************************************************************************************************
+ *  GLOBAL CONSTANT MACROS
+ *********************************************************************************************************************/
+
+/* ----- Component version information (decimal version of ALM implementation package) ----- */
+# define VX1000IF_SW_MAJOR_VERSION                    (1u)
+# define VX1000IF_SW_MINOR_VERSION                    (2u)
+# define VX1000IF_SW_PATCH_VERSION                    (0u)
+
+# if defined(VX1000IF_CFG_NO_TARGET)
+#  error "no target selected that tells the interface which driver files to include"
+# else /* !VX1000IF_CFG_NO_TARGET */
+#  if !defined(VX1000If_IsVX1000DriverAccessEnabled)
+#   error "no boolean expression defined that tells the interface whether to call or to not call the actual driver"
+#  else /* VX1000If_IsVX1000DriverAccessEnabled */
+
+/**********************************************************************************************************************
+ *  GLOBAL CONSTANT MACROS
+ *********************************************************************************************************************/
+
+/* ------- Modes ------- */
+#   define VX1000IF_UNINIT                              (0x00u)
+#   define VX1000IF_PRE_INIT                            (0x01u)
+#   define VX1000IF_INITIALIZED                         (0x02u)
+
+/* --- Return Values --- */
+#   define VX1000IF_RET_VOID                            (void)0
+#   define VX1000IF_RET_E_NOT_OK                        (0xFFu)
+
+/**********************************************************************************************************************
+ *  GLOBAL FUNCTION MACROS
+ *********************************************************************************************************************/
+
+/* PRQA S 0342 3 */ /* MD_VX1000IF_0342 */
+#   define VX1000IF_IMPL(functionName, retVal)      ((!VX1000If_IsVX1000DriverAccessEnabled) || (VX1000If_State != VX1000IF_INITIALIZED))?(VX1000If_ErrorCount++,retVal):VX1000_##functionName
+/* PRQA S 3412 1 */ /* MD_MSR_19.4 */
+#   define VX1000IF_IMPL_VOID(functionName)          if ((!VX1000If_IsVX1000DriverAccessEnabled) || (VX1000If_State != VX1000IF_INITIALIZED)) { VX1000If_ErrorCount++; } else VX1000_##functionName
+
+/**********************************************************************************************************************
+ *  VX1000If_InitAsyncStart()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to perform the VX1000 start-up handshaking
+ *  \\details     Makes the VX1000 device driver detect an attached VX1000 device and perform a first handshake. 
+ *  \\pre         VX1000If_Init must have been called.
+ *  \\context     TASK                                                     
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-812
+ *********************************************************************************************************************/
+/* PRQA S 3412 4 */ /* MD_MSR_19.4 */
+#   define   VX1000If_InitAsyncStart()             if ( (VX1000If_IsVX1000DriverAccessEnabled)                     &&       \\
+                                                        (VX1000If_State == VX1000IF_PRE_INIT))                              \\
+                                                        { VX1000_INIT_ASYNC_START(); VX1000If_State = VX1000IF_INITIALIZED; } \\
+                                                   else { VX1000If_ErrorCount++; }
+
+/**********************************************************************************************************************
+ *  VX1000If_InitAsyncEnd()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to finish the VX1000 start-up handshake
+ *  \\details     Makes the VX1000 device driver perform the second part of the handshake with an attached VX1000 device. 
+ *               Waits for end of handshake and can be used to synchronize the instrumentation on several cores.
+ *  \\pre         VX1000If_InitAsyncStart must have been called.
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-813
+ *********************************************************************************************************************/
+/* PRQA S 3412 4 */ /* MD_MSR_19.4 */
+#   define   VX1000If_InitAsyncEnd                    VX1000IF_IMPL_VOID(INIT_ASYNC_END)
+
+/**********************************************************************************************************************
+ *  VX1000If_PrepareSoftreset() / VX1000If_PrepareSoftresetVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros for Pre-restart handshake with the VX1000 device driver
+ *  \\details     Makes the VX1000 device driver inform an attached VX1000 device about an upcoming software reset. 
+ *  \\return      0 - reset procedure confirmed by tool
+ *  \\return      1 - handshake failed (measurement won\'t be resumed after the reset)
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-814
+ *********************************************************************************************************************/
+#   define   VX1000If_PrepareSoftreset                VX1000IF_IMPL(PREPARE_SOFTRESET        , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_PrepareSoftresetVoid            VX1000IF_IMPL_VOID(PREPARE_SOFTRESET_VOID)
+
+/********************** STIM API BEGIN *******************************************************************************/
+
+/**********************************************************************************************************************
+ *  VX1000If_StimControl() / VX1000If_BypassControl()
+ *********************************************************************************************************************/
+/*! \\brief       Macros for the STIM-Keep-Alive-Handler
+ *  \\details     DEPRECATED: VX1000If_BypassControl should be used for new projects instead of  VX1000If_StimControl! 
+ *               Must be cyclically called by the application if STIM/Bypassing is used. Makes the VX1000 device driver 
+ *               perform bypassing management tasks, like globally starting and stopping bypassing operation. 
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-805
+ *********************************************************************************************************************/
+#   define   VX1000If_StimControl                     VX1000IF_IMPL_VOID(STIM_CONTROL)
+#   define   VX1000If_BypassControl                   VX1000IF_IMPL_VOID(BYPASS_CONTROL)
+
+/**********************************************************************************************************************
+ *  VX1000If_StimRequest()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to a request STIM data set
+ *  \\details     Makes the VX1000 device driver request a specific STIM data set associated to event channel stim_event.
+ *  \\param[in]   stim_event:          The range for stim_event is defined in the VX1000 device driver configuration. 
+ *                                    It is a subset of the available DAQ event channels. 
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-806
+ *********************************************************************************************************************/
+#   define   VX1000If_StimRequest                     VX1000IF_IMPL_VOID(STIM_REQUEST)
+
+/**********************************************************************************************************************
+ *  VX1000If_StimWait() / VX1000If_StimWaitVoid() / VX1000If_BypassStim() / VX1000If_BypassStimVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to wait until a specific STIM request is fulfilled
+ *  \\details     Makes the VX1000 device driver wait in a busy polling loop until a specific STIM request is fulfilled. 
+ *               Depending on the STIM method used, on success all transfer descriptors assigned to stim_event are 
+ *               processed and the STIM data is transferred to its destination. 
+ *  \\param[in]   stim_event:          The range for stim_event is defined in the VX1000 device driver configuration. 
+ *                                    It is a subset of the available DAQ event channels. 
+ *  \\param[in]   timeout_us:          timeout in microseconds, starting from related call to VX1000If_StimRequest 
+ *  \\return      0 - data arrived before timeout or timeout but data still copied successfully
+ *  \\return      1 - timeout, no new data arrived or error during copying and destination data corrupted
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_StimRequest and VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-808
+ *********************************************************************************************************************/
+#   define   VX1000If_StimWait                        VX1000IF_IMPL(STIM_WAIT                , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_StimWaitVoid                    VX1000IF_IMPL_VOID(STIM_WAIT_VOID)
+#   define   VX1000If_BypassStim                      VX1000IF_IMPL(BYPASS_STIM              , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_BypassStimVoid                  VX1000IF_IMPL_VOID(BYPASS_STIM_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_StimActive()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to check the STIM status of an event
+ *  \\details     Makes the VX1000 device driver return whether STIM is active for the specific event channel and globally. 
+ *  \\param[in]   stim_event:          The range for stim_event is defined in the VX1000 device driver configuration. 
+ *                                    It is a subset of the available DAQ event channels. 
+ *  \\return      1 - active
+ *  \\return      0 - inactive
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-807
+ *********************************************************************************************************************/
+#   define   VX1000If_StimActive                      VX1000IF_IMPL(STIM_ACTIVE              , VX1000IF_RET_E_NOT_OK)
+
+/**********************************************************************************************************************
+ *  VX1000If_StimSkip()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to send a STIM skip event
+ *  \\details     Makes the VX1000 device driver send a STIM skip event to tell the attached VX1000 device not to 
+ *               stimulate the next cycle. This is in effect a dummy STIM request. 
+ *  \\param[in]   stim_event:          The range for stim_event is defined in the VX1000 device driver configuration. 
+ *                                    It is a subset of the available DAQ event channels. 
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-809
+ *********************************************************************************************************************/
+#   define   VX1000If_StimSkip                        VX1000IF_IMPL_VOID(STIM_SKIP)
+
+/**********************************************************************************************************************
+ *  VX1000If_Stimulate() / VX1000If_StimulateVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to initiate a bypass without sending DAQ data
+ *  \\details     Makes the VX1000 device driver perform a complete stimulation. This is done by requesting STIM data 
+ *               using the stim_trigger_event which is in fact a DAQ event with or without DAQ data. The first cycle_delay 
+ *               calls are used to fill a STIM data pipeline in the VX1000. During these calls the function will return 0. 
+ *               After the first cycle_delay calls, this function will busy wait with timeout for the VX1000 to actually 
+ *               complete the stimulation (stim_event). The pipeline depth / initial delay has to be considered when 
+ *               generating the STIM data. 
+ *  \\param[in]   stim_trigger_event:  DAQ event range 
+ *  \\param[in]   stim_event:          The range for stim_event is defined in the VX1000 device driver configuration. 
+ *                                    It is a subset of the available DAQ event channels. 
+ *  \\param[in]   cycle_delay:         Specifies the number of cycles between triggering and the associated 
+ *                                    stimulation. During the first cycle_delay cycles there is no stimulation in the 
+ *                                    ECU, instead the VX1000 device fills its STIM buffer FIFO. 
+ *  \\param[in]   timeout_us:          Timeout in microseconds, starting upon calling this function. 
+ *  \\return      0 - code to be bypassed shall be executed as bypassing is not active 
+ *  \\return      1 - STIM successful, code to be bypassed shall be skipped 
+ *  \\return      2 - STIM failed, it is up to the application to handle this error 
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-816
+ *********************************************************************************************************************/
+#   define   VX1000If_Stimulate                       VX1000IF_IMPL(STIMULATE                , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_StimulateVoid                   VX1000IF_IMPL_VOID(STIMULATE_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_Bypass() / VX1000If_BypassVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to initiate a bypass with sending DAQ data and wait for completion
+ *  \\details     Makes the VX1000 device driver initiate a bypass by sending DAQ data to the tool and implicitly requesting 
+ *               a stimulation (daq_event), then busy wait with timeout for the tool to complete the stimulation (stim_event). 
+ *  \\param[in]   daq_event:           DAQ event range 
+ *  \\param[in]   stim_event:          The range for stim_event is defined in the VX1000 device driver configuration. 
+ *                                    It is a subset of the available DAQ event channels. 
+ *  \\param[in]   timeout_us:          Timeout in microseconds, starting with the function call 
+ *  \\return      0 - code to be bypassed shall be executed as bypassing is not active 
+ *  \\return      1 - Bypass successful, code to be bypassed shall be skipped 
+ *  \\return      2 - Bypass failed, it is up to the application to handle this error 
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-815
+ *********************************************************************************************************************/
+#   define   VX1000If_Bypass                          VX1000IF_IMPL(BYPASS                   , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_BypassVoid                      VX1000IF_IMPL_VOID(BYPASS_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_BypassDaq() / VX1000If_BypassDaqVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to initiate a bypass by sending a DAQ event
+ *  \\details     Makes the VX1000 device driver initiate a bypass by sending a DAQ event followed by a STIM request. 
+ *  \\param[in]   daq_event:           DAQ event range 
+ *  \\param[in]   stim_event:          The range for stim_event is defined in the VX1000 device driver configuration. 
+ *                                    It is a subset of the available DAQ event channels. 
+ *  \\return      0 - bypassing is not active: code to be bypassed shall be executed 
+ *  \\return      1 - bypassing is active: code to be bypassed shall shall be skipped 
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-810
+ *********************************************************************************************************************/
+#   define   VX1000If_BypassDaq                      VX1000IF_IMPL(BYPASS_DAQ               , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_BypassDaqVoid                  VX1000IF_IMPL_VOID(BYPASS_DAQ_VOID) 
+
+/**********************************************************************************************************************
+ *  VX1000If_BypassTrigger() / VX1000If_BypassTriggerVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to initiate a bypass with sending DAQ data
+ *  \\details     Makes the VX1000 device driver initiate a bypass by sending DAQ data to the tool and implicitly requesting 
+ *               a stimulation (daq_event). 
+ *  \\param[in]   daq_event:           DAQ event range 
+ *  \\param[in]   stim_event:          The range for stim_event is defined in the VX1000 device driver configuration. 
+ *                                    It is a subset of the available DAQ event channels. 
+ *  \\return      0 - bypassing is not active: code to be bypassed shall be executed 
+ *  \\return      1 - bypassing is active: code to be bypassed shall shall be skipped 
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-839
+ *********************************************************************************************************************/
+#   define   VX1000If_BypassTrigger                  VX1000IF_IMPL(BYPASS_TRIGGER           , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_BypassTriggerVoid              VX1000IF_IMPL_VOID(BYPASS_TRIGGER_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_BypassWait() / VX1000If_BypassWaitVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to wait for the too to complete a stimulation
+ *  \\details     Makes the VX1000 device driver perform a busy wait with timeout for the tool to complete a stimulation 
+ *               (stim_event) that has been initiated beforehand by an appropriate call to VX1000If_BypassTrigger. 
+ *  \\param[in]   stim_event:          The range for stim_event is defined in the VX1000 device driver configuration. 
+ *                                    It is a subset of the available DAQ event channels. 
+ *  \\param[in]   timeout_us:          Timeout in microseconds, starting with the function call 
+ *  \\return      0 - bypassed code shall be activated because bypassing is not active 
+ *  \\return      1 - everything done, bypassed code shall be disabled
+ *  \\return      2 - bypassing failed; it\'s up to the application design whether executing the bypassed code makes sense here
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_BypassTrigger and VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-817
+ *********************************************************************************************************************/
+#   define   VX1000If_BypassWait                     VX1000IF_IMPL(BYPASS_WAIT              , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_BypassWaitVoid                 VX1000IF_IMPL_VOID(BYPASS_WAIT_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_Event() / VX1000If_OvlSetConfigVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to processes all transfer descriptors assigned to the given event.
+ *  \\details     Makes the VX1000 device driver trigger an XCP event. For copying-mechanism-based DAQ, makes the 
+ *               VX1000 device driver process all transfer descriptors assigned to eventNumber and to copy the DAQ data 
+ *               to an intermediate buffer to be read by the VX1000. 
+ *  \\param[in]   eventNumber:         DAQ event range 
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   TRUE (provided that simultaneous calls are passed different event numbers)
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-836
+ *********************************************************************************************************************/
+#   define   VX1000If_Event                          VX1000IF_IMPL_VOID(EVENT)
+
+/********************** STIM API END *********************************************************************************/
+
+/********************** Generic Hooking Control BEGIN ****************************************************************/
+
+/**********************************************************************************************************************
+ *  VX1000If_HookTrigger() / VX1000If_HookTriggerVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to trigger a generic bypass whose event IDs are related to HookID. 
+ *  \\details     Makes the VX1000 device driver trigger a generic bypass whose event IDs are related to HookID. 
+ *  \\param[in]   HookID:              Hook id range 
+ *  \\return      0 - inactive bypass or active bypass and original code enabled
+ *  \\return      1 - bypass active and original code disabled
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-821
+ *********************************************************************************************************************/
+#   define   VX1000If_HookTrigger                    VX1000IF_IMPL(HOOK_TRIGGER             , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_HookTriggerVoid                VX1000IF_IMPL_VOID(HOOK_TRIGGER_VOID) 
+
+/**********************************************************************************************************************
+ *  VX1000If_HookWait() / VX1000If_HookWaitVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to trigger with timeout for a generic bypass whose event IDs are related to HookID.
+ *  \\details     Makes the VX1000 device driver stimulate with timeout for a generic bypass whose event IDs are related to 
+ *               HookID. Optionally, an additional DAQ event will be triggered. 
+ *  \\param[in]   HookID:              Hook id range 
+ *  \\param[in]   timeout_us:          Timeout in microseconds, starting with the function call 
+ *  \\return      0 - bypass inactive 
+ *  \\return      1 - stimulation done, no timeout, OK
+ *  \\return      2 - stimulation not done, timeout
+ *  \\return      3 - stimulation not done, timeout, execute original code
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-822
+ *********************************************************************************************************************/
+#   define   VX1000If_HookWait                       VX1000IF_IMPL(HOOK_WAIT                , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_HookWaitVoid                   VX1000IF_IMPL_VOID(HOOK_WAIT_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_GenericEvent()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to trigger a generic event whose event ID is related to HookID.
+ *  \\details     Makes the VX1000 device driver trigger a generic event whose event ID is related to hook_id. 
+ *  \\param[in]   HookID:              Hook id range 
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-823
+ *********************************************************************************************************************/
+#   define   VX1000If_GenericEvent                   VX1000IF_IMPL_VOID(GENERIC_EVENT)
+
+/**********************************************************************************************************************
+ *  VX1000If_Hook()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to trigger a generic event whose event ID is related to HookID.
+ *  \\details     Makes the VX1000 device driver trigger a generic bypass for STIM events with VX1000  Hooks, then wait 
+ *               until the data set requests of this generic bypass are finished successfully and then trigger a DAQ event or 
+ *               in case of inactive hook or failed stimulation to execute user code without triggering the DAQ event. 
+ *  \\param[in]   HookID:              Hook id range as configured in the VX1000 device driver 
+ *  \\param[in]   timeout_us:          Timeout in microseconds, starting with the function call 
+ *  \\param[in]   code:                User code to be executed in case of failed stimulation or inactive hook. 
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-838
+ *********************************************************************************************************************/
+#   define   VX1000If_Hook                           VX1000IF_IMPL_VOID(HOOK)
+
+/********************** Generic Hooking Control END ******************************************************************/
+
+/********************** Hook based bypassing macros  BEGIN ***********************************************************/
+
+/**********************************************************************************************************************
+ *  VX1000If_BypassHbbGetval<8,16,32,64,Float,Double> ()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to wait for the too to complete a stimulation
+ *  \\details     Makes the VX1000 device driver check whether valid data corresponding to the given Hook ID is present in 
+ *               the buffer. 
+ *  \\param[in]   HookID:              HBB id range as configured in the VX1000 device driver 
+ *  \\param[in]   DefaultValue:        Specifies the default value to be returned if hook is not valid. 
+ *  \\return      Data corresponding to the stimulated value, if hook is valid, data available and VX1000If_IsVX1000DriverAccessEnabled returned TRUE. 
+ *               Otherwise DefaultValue is returned
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-824
+ *********************************************************************************************************************/
+/* PRQA S 3453 FUNCTIONLIKEMACRO */ /* MD_MSR_19.7 */
+#   define   VX1000If_BypassHbbGetval8(H, D)        VX1000IF_IMPL(BYPASS_HBB_GETVAL_8,       (D))((H), D)
+#   define   VX1000If_BypassHbbGetval16(H, D)       VX1000IF_IMPL(BYPASS_HBB_GETVAL_16,      (D))((H), D)
+#   define   VX1000If_BypassHbbGetval32(H, D)       VX1000IF_IMPL(BYPASS_HBB_GETVAL_32,      (D))((H), D)
+#   define   VX1000If_BypassHbbGetval64(H, D)       VX1000IF_IMPL(BYPASS_HBB_GETVAL_64,      (D))((H), D)
+#   define   VX1000If_BypassHbbGetvalFloat(H, D)    VX1000IF_IMPL(BYPASS_HBB_GETVAL_FLOAT,   (D))((H), D)
+#   define   VX1000If_BypassHbbGetvalDouble(H, D)   VX1000IF_IMPL(BYPASS_HBB_GETVAL_DOUBLE,  (D))((H), D)
+/* PRQA L:FUNCTIONLIKEMACRO */ /* MD_MSR_19.7 */
+
+/********************** Hook based bypassing macros  END *************************************************************/
+
+/********************** VX1000 Mailbox BEGIN *************************************************************************/
+
+/**********************************************************************************************************************
+ *  VX1000If_MailboxControl()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to check the VX1000 mailbox system for pending requests
+ *  \\details     Makes the VX1000 device driver check the VX1000 mailbox for pending requests and trigger necessary 
+ *               actions. 
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        This function must not be interrupted by any VX1000 mailbox read function.                                 
+ *               This function must not interrupt any VX1000 mailbox read function.                                         
+ *  \\trace       CREQ-825
+ *********************************************************************************************************************/
+#   define   VX1000If_MailboxControl                 VX1000IF_IMPL_VOID(MAILBOX_CONTROL)
+
+/**********************************************************************************************************************
+ *  VX1000If_MailboxWrite() / VX1000If_MailboxWriteVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to write to the Slave->Master mailbox and notify the master.
+ *  \\details     Makes the VX1000 device driver write len bytes from pBuf to the Slave->Master mailbox and notify the 
+ *               master. 
+ *  \\param[in]   len:                 Speficies the message size in bytes.
+ *  \\param[in]   pBuf:                Specifies the pointer to message data input.
+ *  \\return      VX1000_MAILBOX_OK       - mailbox transfer successful 
+ *  \\return      VX1000_MAILBOX_ERR_FULL - error: no free mailbox slots available 
+ *  \\return      VX1000_MAILBOX_ERR_NULL - error: pBuf is null pointer 
+ *  \\return      VX1000_MAILBOX_ERR_SIZE - error: len exceeds mailbox slot size 
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        This function must not be interrupted by any VX1000 mailbox write function.                                 
+ *               This function must not interrupt any VX1000 mailbox write function.                                         
+ *  \\trace       CREQ-826
+ *********************************************************************************************************************/
+#   define   VX1000If_MailboxWrite                   VX1000IF_IMPL(MAILBOX_WRITE            , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_MailboxWriteVoid               VX1000IF_IMPL_VOID(MAILBOX_WRITE_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_MailboxWrite() / VX1000If_MailboxWriteVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to find out the location of the next unused message buffer
+ *  \\details     Makes the VX1000 device driver find out the location of the next unused message buffer and return the info 
+ *               to the caller. 
+ *               The mailbox state is neither changed nor is the master notified. To finalize writing data to the mailbox, 
+ *               VX1000If_MailboxWriteDone must be called. 
+ *  \\param[in,out] ppBuf:             (IN)  pointer to a pointer variable. 
+ *                                    (OUT) pointer to the data field of the next free Slave->Master mailbox. 
+ *  \\return      VX1000_MAILBOX_OK             - mailbox transfer successful 
+ *  \\return      VX1000_MAILBOX_ERR_FULL       - error: no free mailbox slots available 
+ *  \\return      VX1000_MAILBOX_ERR_NULL       - error: pBuf is null pointer 
+ *  \\return      VX1000_MAILBOX_ERR_SPLIT_PEND - error: no pending write transaction 
+ *  \\return      VX1000IF_RET_E_NOT_OK         - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        This function must not be interrupted by any VX1000 mailbox read function.                                 
+ *               This function must not interrupt any VX1000 mailbox read function.                                         
+ *  \\trace       CREQ-827
+ *********************************************************************************************************************/
+#   define   VX1000If_MailboxWriteSplit              VX1000IF_IMPL(MAILBOX_WRITESPLIT       , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_MailboxWriteSplitVoid          VX1000IF_IMPL_VOID(MAILBOX_WRITESPLIT_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_MailboxWrite() / VX1000If_MailboxWriteVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to Finish a Slave->Master mailbox transfer.
+ *  \\details     Makes the VX1000 device driver finalize a Slave->Master mailbox transfer that has been started by calling 
+ *               VX1000If_MailboxWriteSplit. 
+ *  \\param[in]   len:                 The size of the entire message in bytes. 
+ *  \\return      VX1000_MAILBOX_OK             - mailbox transfer successful 
+ *  \\return      VX1000_MAILBOX_ERR_SIZE       - error: len exceeds mailbox slot size 
+ *  \\return      VX1000_MAILBOX_ERR_SPLIT_PEND - error: no pending write transaction 
+ *  \\return      VX1000IF_RET_E_NOT_OK         - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        This function must not be interrupted by any VX1000 mailbox write function.                                 
+ *               This function must not interrupt any VX1000 mailbox write function.                                         
+ *  \\trace       CREQ-828
+ *********************************************************************************************************************/
+#   define   VX1000If_MailboxWriteDone               VX1000IF_IMPL(MAILBOX_WRITEDONE        , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_MailboxWriteDoneVoid           VX1000IF_IMPL_VOID(MAILBOX_WRITEDONE_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_MailboxRead() / VX1000If_MailboxReadVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to read the data from next filled Master->Slave mailbox slot.
+ *  \\details     Makes the VX1000 device driver read the data from the next filled Master->Slave mailbox slot into pBuf 
+ *               and return the number of bytes in pLen. 
+ *  \\param[in,out]   pLen:            Pointer holding the maximum allowed message size. 
+ *                                    The value is overwritten with the actual message size if successful.
+ *  \\param[in,out]   pBuf:            Pointer to destination for the next message.
+ *                                    The caller is responsible that the destination contains at least *pLen writeable bytes.
+ *                                    The function aborts with an error if the buffer is too small for the current message 
+ *                                    (no bytes copied).
+ *                                    pBuf holds a copy of the entire message if successful.
+ *  \\return      VX1000_MAILBOX_OK             - mailbox transfer successful 
+ *  \\return      VX1000_MAILBOX_ERR_EMPTY      - error: mailbox is empty  
+ *  \\return      VX1000_MAILBOX_ERR_NULL       - error: pLen or pBuf are null pointers 
+ *  \\return      VX1000_MAILBOX_ERR_SIZE       - error: mailbox slot content exceeds pLen 
+ *  \\return      VX1000_MAILBOX_ERR_SPLIT_PEND - error: split read transaction pending 
+ *  \\return      VX1000IF_RET_E_NOT_OK         - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        This function must not be interrupted by any VX1000 mailbox read function.                                 
+ *               This function must not interrupt any VX1000 mailbox read function.                                    
+ *  \\trace       CREQ-829
+ *********************************************************************************************************************/
+#   define   VX1000If_MailboxRead                    VX1000IF_IMPL(MAILBOX_READ             , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_MailboxReadVoid                VX1000IF_IMPL_VOID(MAILBOX_READ_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_MailboxReadSplit() / VX1000If_MailboxReadSplitVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to find out the location and length of the next unread message.
+ *  \\details     Makes the VX1000 device driver return the location and length of the next unread mailbox message. 
+ *               Note: the mailbox state is not changed nor is the master notified. 
+ *               VX1000If_MailboxReadDone must be called to complete the transaction. 
+ *  \\param[out]  pLen:                Pointer to a 32bit variable.
+ *                                    The value is overwritten with the byte count of the next message if successful.
+ *                                    The caller is responsible that the pointer is valid and that the destination is writeable.
+ *  \\param[in,out]   pBuf:            Pointer to the data field of the next unread message.
+ *                                    The caller is responsible that the pointer is valid and that the destination is writeable.
+ *  \\return      VX1000_MAILBOX_OK        - mailbox transfer successful 
+ *  \\return      VX1000_MAILBOX_ERR_EMPTY - error: mailbox is empty  
+ *  \\return      VX1000_MAILBOX_ERR_NULL  - error: pLen or ppBuf  is a null pointer 
+ *  \\return      VX1000_MAILBOX_ERR_SIZE  - error: mailbox slot content exceeds pLen 
+ *  \\return      VX1000_MAILBOX_ERR_SPLIT_PEND - error: another split read transaction is pending 
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        This function must not be interrupted by any VX1000 mailbox read function.                                 
+ *               This function must not interrupt any VX1000 mailbox read function.                                         
+ *  \\trace       CREQ-830
+ *********************************************************************************************************************/
+#   define   VX1000If_MailboxReadSplit               VX1000IF_IMPL(MAILBOX_READSPLIT        , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_MailboxReadSplitVoid           VX1000IF_IMPL_VOID(MAILBOX_READSPLIT_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_MailboxReadDone() / VX1000If_MailboxReadDoneVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to mark the filled Master->Slave mailbox slot as empty
+ *  \\details     Makes the VX1000 device driver mark the Master->Slave mailbox slot for the pending read transaction as 
+ *               empty and notify the master afterwards. 
+ *  \\return      VX1000_MAILBOX_OK             - mailbox transfer successful 
+ *  \\return      VX1000_MAILBOX_ERR_SPLIT_PEND - no pending read split transaction 
+ *  \\return      VX1000IF_RET_E_NOT_OK         - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_MailboxReadSplit and VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        This function must not be interrupted by any VX1000 mailbox read function.                                 
+ *               This function must not interrupt any VX1000 mailbox read function.                                         
+ *  \\trace       CREQ-831
+ *********************************************************************************************************************/
+#   define   VX1000If_MailboxReadDone                VX1000IF_IMPL(MAILBOX_READDONE         , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_MailboxReadDoneVoid            VX1000IF_IMPL_VOID(MAILBOX_READDONE_VOID)
+
+/********************** VX1000 Mailbox END ***************************************************************************/
+
+/********************** VX1000 Overlay BEGIN *************************************************************************/
+
+/**********************************************************************************************************************
+ *  VX1000If_OvlSetConfig() / VX1000If_OvlSetConfigVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to globally enable/disable overlays
+ *  \\details     Makes the VX1000 device driver execute a derivative-specific method to globally enable/disable overlays.
+ *  \\param[in]   value:               Overlay windows to be activated/deactivated
+ *  \\param[in]   mask:                Resource Mask
+ *  \\param[in]   page:                Overlay Page
+ *  \\param[in]   master:              Masters to be activated
+ *  \\param[in]   calMaster:           Masters resource Mask
+ *  \\return      0 - Nothing done
+ *  \\return      1 - Page switch done  
+ *  \\return      2 - Value not written correctly 
+ *  \\return      3 - No single-master page-switch possible
+ *  \\return      4 - Generic error
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        The VX1000 device driver assumes exclusive ownership of the overlay unit.
+ *  \\trace       CREQ-832
+ *********************************************************************************************************************/
+#   define   VX1000If_OvlSetConfig                  VX1000IF_IMPL(OVL_SET_CONFIG           , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_OvlSetConfigVoid              VX1000IF_IMPL_VOID(OVL_SET_CONFIG_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_OvlSetConfigDone() / VX1000If_OvlSetConfigDoneVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to transmit the status of a page switching attempt to the VX1000 driver
+ *  \\details     Transmits the status of a page switching attempt to the VX1000 driver and optionally also to the XCP tool.
+ *  \\param[in]   value:               Overlay windows to be activated/deactivated
+ *  \\param[in]   mask:                Resource Mask
+ *  \\param[in]   page:                Overlay Page
+ *  \\param[in]   master:              Masters to be activated
+ *  \\param[in]   calMaster:           Masters resource Mask
+ *  \\return      0 - Nothing done
+ *  \\return      1 - Page switch done  
+ *  \\return      2 - Value not written correctly 
+ *  \\return      3 - No single-master page-switch possible
+ *  \\return      4 - Generic error
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        The VX1000 device driver assumes exclusive ownership of the overlay unit.
+ *  \\trace       CREQ-864
+ *********************************************************************************************************************/
+#   define   VX1000If_OvlSetConfigDone             VX1000IF_IMPL_VOID(OVL_SET_CONFIG_DONE)
+#   define   VX1000If_OvlSetConfigDoneVoid         VX1000IF_IMPL_VOID(OVL_SET_CONFIG_DONE_STUP)
+
+/**********************************************************************************************************************
+ *  VX1000If_OvlChkPageSwDone() / VX1000If_OvlChkPageSwDoneVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to check page switching status of all bus masters for which a page switch was requested.
+ *  \\details     Makes the VX1000 driver check and finalize page switching status of all bus masters for which a page 
+ *               switch was requested.
+ *  \\return      0 - Nothing done
+ *  \\return      1 - Page switch done  
+ *  \\return      2 - Value not written correctly 
+ *  \\return      3 - No single-master page-switch possible
+ *  \\return      4 - Generic error
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called.  
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        The VX1000 device driver assumes exclusive ownership of the overlay unit.
+ *  \\trace       CREQ-865
+ *********************************************************************************************************************/
+#   define   VX1000If_OvlChkPageSwDone             VX1000IF_IMPL(OVL_CHK_PAGESW_DONE      , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_OvlChkPageSwDoneVoid         VX1000IF_IMPL_VOID(OVL_CHK_PAGESW_DONE_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_OvlChkPageSwCore() / VX1000If_OvlChkPageSwCoreVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to check page switching status of a specific bus master
+ *  \\details     Makes the VX1000 driver check the page switching status of a specific bus master.
+ *  \\param[in]   master:              bus master to be checked
+ *  \\return      0 - Nothing done
+ *  \\return      1 - Page switch done  
+ *  \\return      2 - Value not written correctly 
+ *  \\return      3 - No single-master page-switch possible
+ *  \\return      4 - Generic error
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called.  
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        The VX1000 device driver assumes exclusive ownership of the overlay unit.
+ *  \\trace       CREQ-866
+ *********************************************************************************************************************/
+#   define   VX1000If_OvlChkPageSwCore             VX1000IF_IMPL(OVL_CHK_PAGESW_CORE      , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_OvlChkPageSwCoreVoid         VX1000IF_IMPL_VOID(OVL_CHK_PAGESW_CORE_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_OvlIsPageSwRequested()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to check whether a page switch request is pending for a bus master
+ *  \\details     Makes the VX1000 driver check whether a page switch request is pending for a bus master or not.
+ *  \\param[in]   master:              bus master to be checked
+ *  \\return      0 - Page switch is not pending
+ *  \\return      1 - Page switch is pending
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called.  
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        The VX1000 device driver assumes exclusive ownership of the overlay unit.
+ *  \\trace       CREQ-867
+ *********************************************************************************************************************/
+#   define   VX1000If_OvlIsPageSwRequested         VX1000IF_IMPL(OVL_IS_PAGESW_REQUESTED  , VX1000IF_RET_E_NOT_OK)
+
+/**********************************************************************************************************************
+ *  VX1000If_InvalidateEmem()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to invalidate the signature of the VX1000-allocated persistent ECU-RAM
+ *  \\details     Invalidate the signature of the VX1000-allocated persistent ECU-RAM.
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        The VX1000 device driver assumes exclusive ownership of the overlay unit.
+ *  \\trace       CREQ-868
+ *********************************************************************************************************************/
+#   define   VX1000If_InvalidateEmem               VX1000IF_IMPL_VOID(INVALIDATE_EMEM)
+
+/**********************************************************************************************************************
+ *  VX1000If_CalWakeupRequested()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to check whether the XCP tool requested a wakeup for calibration purposes or not.
+ *  \\details     Makes the VX1000 driver check whether the XCP tool has requested a wakeup for calibration purposes.
+ *  \\return      0 - No request pending
+ *  \\return      1 - Request pending
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        The VX1000 device driver assumes exclusive ownership of the overlay unit.
+ *  \\trace       CREQ-869
+ *********************************************************************************************************************/
+#   define   VX1000If_CalWakeupRequested           VX1000IF_IMPL(CAL_WAKEUP_REQUESTED     , VX1000IF_RET_E_NOT_OK)
+
+/**********************************************************************************************************************
+ *  VX1000If_IsCalWakeupActive()
+ *********************************************************************************************************************/
+/*! \\brief       Macros to check whether the ECU must stay awake for calibration purposes or not.
+ *  \\details     Makes the VX1000 driver check whether the ECU must stay awake for calibration purposes or not.
+ *  \\return      0 - ECU must not stay awake
+ *  \\return      1 - ECU must stay awake
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        The VX1000 device driver assumes exclusive ownership of the overlay unit.
+ *  \\trace       CREQ-870
+ *********************************************************************************************************************/
+#   define   VX1000If_IsCalWakeupActive            VX1000IF_IMPL(IS_CAL_WAKEUP_ACTIVE     , VX1000IF_RET_E_NOT_OK)
+/********************** VX1000 Overlay END ***************************************************************************/
+
+/********************** VX1000 Resource Management BEGIN *************************************************************/
+
+/**********************************************************************************************************************
+ *  VX1000If_EnableAccess()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to enable the VX1000 tool access.
+ *  \\details     Makes the VX1000 driver enable the VX1000 tool access.
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-833
+ *********************************************************************************************************************/
+#   define   VX1000If_EnableAccess                 VX1000IF_IMPL_VOID(ENABLE_ACCESS)
+
+/**********************************************************************************************************************
+ *  VX1000If_DisableAccess() / VX1000If_DisableAccessVoid()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to disable the VX1000 tool access.
+ *  \\details     Disables the VX1000 tool access.
+ *  \\return      0 - VX1000 tool access successfully disabled
+ *  \\return      1 - unable to disable VX1000 tool access
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-834
+ *********************************************************************************************************************/
+#   define   VX1000If_DisableAccess                VX1000IF_IMPL(DISABLE_ACCESS           , VX1000IF_RET_E_NOT_OK)
+#   define   VX1000If_DisableAccessVoid            VX1000IF_IMPL_VOID(DISABLE_ACCESS_VOID)
+
+/**********************************************************************************************************************
+ *  VX1000If_IsAccessDisabled()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to check the VX1000 tool access state.
+ *  \\details     Makes the VX1000 driver check whether the VX1000 tool access is disabled or not.
+ *  \\return      0 - VX1000 tool access disabled
+ *  \\return      1 - VX1000 tool access enabled
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-835
+ *********************************************************************************************************************/
+#   define   VX1000If_IsAccessDisabled             VX1000IF_IMPL(IS_ACCESS_DISABLED       , VX1000IF_RET_E_NOT_OK)
+
+/********************** VX1000 Resource Management END ***************************************************************/
+
+/********************** VX1000 User functions and macros *************************************************************/
+
+/**********************************************************************************************************************
+ *  VX1000If_DetectFklRequests()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to prevents the application from writing to RAM.
+ *  \\details     Makes the VX1000 driver prevent the application from writing to RAM to allow a flash kernel download 
+ *               by the VX1000 and to busily wait for trigger command to jump to the flash kernel execution start address 
+ *               provided by the VX1000.
+ *  \\pre         VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-837
+ *********************************************************************************************************************/
+#   define   VX1000If_DetectFklRequests            VX1000IF_IMPL_VOID(DETECT_FKL_REQUESTS)
+
+/**********************************************************************************************************************
+ *  VX1000If_DeviceDetected()
+ *********************************************************************************************************************/
+/*! \\brief       Macro to check whether a VX1000 was already detected.
+ *  \\details     Makes the VX1000 driver check whether a VX1000 has been detected.
+ *  \\return      0 - not detected
+ *  \\return      1 - detected
+ *  \\return      VX1000IF_RET_E_NOT_OK - while VX1000If_IsVX1000DriverAccessEnabled returned FALSE
+ *  \\pre         VXWRAP_VX1000_DETECT_VX_ASYNC_START and VX1000If_InitAsyncStart must have been called. 
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \\trace       CREQ-820
+ *********************************************************************************************************************/
+#   define   VX1000If_DeviceDetected               VX1000IF_IMPL(DETECTED                 , VX1000IF_RET_E_NOT_OK)
+
+/**********************************************************************************************************************
+ *  VX1000If_DynAddrSig_UpdateAddress()
+ *********************************************************************************************************************/
+/*! \\brief       This API function is not described here. The appropriate VX1000 AppDriver Addons supplement to the 
+ *               VX1000If Technical Reference can be obtained via VXsupport@vector.com.
+ * Internal comment removed. *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *********************************************************************************************************************/ 
+#   define   VX1000If_DynAddrSig_UpdateAddress     VX1000IF_IMPL_VOID(DYNADDRSIG_UPDATEADDRESS)
+
+/**********************************************************************************************************************
+ *  GLOBAL DATA PROTOTYPES
+ *********************************************************************************************************************/
+
+#   define   VX1000IF_START_SEC_VAR_ZERO_INIT_8BIT
+#   include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_19.1 */
+
+/*! Initialization state of the module */
+extern VAR(uint8, VX1000IF_VAR_ZERO_INIT) VX1000If_State;
+
+/*! Counter for errors that are caused by API calls when :
+ *     - VX1000 Interface is in incorrect state (e.g. not initialized) 
+ *     - or if VX1000If_IsVX1000DriverAccessEnabled returned FALSE 
+ */
+extern VAR(uint8, VX1000IF_VAR_ZERO_INIT) VX1000If_ErrorCount;
+
+#   define   VX1000IF_STOP_SEC_VAR_ZERO_INIT_8BIT
+#   include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_19.1 */
+
+/**********************************************************************************************************************
+ *  GLOBAL FUNCTION PROTOTYPES
+ *********************************************************************************************************************/
+
+#   define   VX1000IF_START_SEC_CODE
+#   include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_19.1 */
+
+/**********************************************************************************************************************
+ *  VX1000If_InitMemory()
+ *********************************************************************************************************************/
+/*! \\brief       Function for *_INIT_*-variable initialization
+ *  \\details     Service to initialize module global variables at power up. This function initializes the
+ *               variables in *_INIT_* sections. Used in case they are not initialized by the startup code.
+ *  \\pre         Module is uninitialized.
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *********************************************************************************************************************/
+FUNC(void, VX1000IF_CODE) VX1000If_InitMemory(void);
+
+/**********************************************************************************************************************
+ * VX1000If_Init()
+ *********************************************************************************************************************/
+/*! \\brief       Initialization function
+ *  \\details     This function initializes the module VX1000If. It initializes all variables and sets the module state
+ *               to initialized.
+ *  \\pre         Interrupts are disabled.
+ *  \\pre         Module is uninitialized.
+ *  \\pre         VX1000If_InitMemory has been called unless VX1000If_State is initialized by start-up code.
+ *  \\context     TASK
+ *  \\reentrant   FALSE
+ *  \\synchronous TRUE
+ *  \
ote        This service does not initialize the VX1000 device driver by calling VX1000If_InitAsyncStart(). 
+ *               This must be done by the application.
+ *  \\trace       CREQ-811
+ *********************************************************************************************************************/
+FUNC(void, VX1000IF_CODE) VX1000If_Init(void);
+
+#   define   VX1000IF_STOP_SEC_CODE
+#   include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_19.1 */
+
+#  endif /* VX1000If_IsVX1000DriverAccessEnabled */
+# endif /* !VX1000IF_CFG_NO_TARGET */
+#endif /* !VX1000IF_H */
+
+/**********************************************************************************************************************
+ *  END OF FILE: VX1000If.h
+ *********************************************************************************************************************/
diff --git a/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/include/VX1000_cfg.h b/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/include/VX1000_cfg.h
new file mode 100644
index 000000000..62baf0460
--- /dev/null
+++ b/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/include/VX1000_cfg.h
@@ -0,0 +1,1150 @@
+/* ------------------------------------------------------------------------------ */
+/* VX1000_cfg.h                                                                   */
+/* Vector VX1000 Application Driver for Infineon Tricore with DAP1/2 or DigRf I/F */
+/* Release: 03_06                    Build: 596          Modification: 21.10.2017 */
+/* Vector Informatik GmbH                                                         */
+/*                                                                                */
+/* User specific configuration settings                                           */
+/* ------------------------------------------------------------------------------ */
+
+
+/* ----------------------------------------------------------------------------------------------------------------------- /
+/ Status of MISRA conformance:                                                                                             /
+/ ---------------------------                                                                                              /
+/                                                                                                                          /
+/     T H E    U S E R    I S    R E S P O N S I B L E    F O R   T H E    C O N T E N T    O F    T H I S    F I L E      /
+/                                                                                                                          /
+/------------------------------------------------------------------------------------------------------------------------ */
+
+
+#if !defined(VX1000_TARGET_TRICORE)
+#define VX1000_TARGET_TRICORE
+#endif /* !VX1000_TARGET_TRICORE */
+
+/*
+ * In series software releases, the application must ensure that
+ * VX1000If_IsVX1000DriverAccessEnabled always returns FALSE!
+ * In use cases which require measurement and calibration via the VX1000,
+ * VX1000If_IsVX1000DriverAccessEnabled must return TRUE.
+ */
+#define VX1000If_IsVX1000DriverAccessEnabled 1
+
+/* ----------------------------------------------------------------------------- */
+/* Note: VX1000_cfg.h serves multiple purposes and is included                   */
+/* several times with different predefines being set to select the wanted        */
+/* purpose. IT IS INTENTED that some lines may be repeatedly processed (namely   */
+/* the "memmap" part) while the rest (the configuration part) actually IS        */
+/* PROTECTED from double inclusion even though your static code analyser tool    */
+/* might not see this and state a warning or error about lacking protection.     */
+/* Those wrong messages can be safely ignored.                                   */
+/* So first come the alternative-memmap parts:                                   */
+
+#if defined(VX1000_BEGSECT_VXSTRUCT_H) && (!defined(VX1000_BEGSECT_VXSTRUCT_H_UNDO)) /* PRQA S 0883 */ /* willingly violating MISRA rule 19.15 because this include file contains various sections that selectively shall expand in various places upon file inclusion with different defines being set as filter */
+
+/* ----------------------------------------------------------------------------- */
+/* Optionally define the memory section were the global VX1000 data shall be     */
+/* placed. The address of the variable gVX1000 in this memory section must be    */
+/* transferred to the VxConfig or VxPlugin settings, therefore a fixed linkage   */
+/* has advantages. The used memory area must not be cached !                     */
+/* When using HSSL pods, the memory section must be covered by a trace window.   */
+/* The following lines will be placed via #include mechanism right before the    */
+/* declaration of the VX1000 structure in the header file of the driver and      */
+/* must match the tool chain that you\'re using to build the application.         */
+
+/*
+___optional_and_compiler_dependent_section_pragmas_or_defines_and_includes_for_forcing_special_linkage_in_headers
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* Some compilers offer to place objects at fixed positions without using a      */
+/* pragma. In that case, you may alternatively to the section pragma above just  */
+/* define VX1000_STRUCT_ADDR to the desired address of the variable gVX1000.     */
+/* Because this feature makes use of proprietary language extensions, leave this */
+/* undefined if your processes (e.g. MISRA) do not allow such extensions.        */
+
+/*
+#define VX1000_STRUCT_ADDR             ___optional_fixed_address_of_VX1000_DATA
+*/
+
+
+#elif defined(VX1000_BEGSECT_VXSTRUCT_C) && (!defined(VX1000_BEGSECT_VXSTRUCT_C_UNDO))
+
+/* ----------------------------------------------------------------------------- */
+/* Code lines to trigger usage of the (optional) memory section for VX1000 data. */
+/* These lines will be placed via #include mechanism right before the allocation */
+/* of the VX1000 structure in the module file of the driver and must match the   */
+/* tool chain that you\'re using to build the application.                        */
+
+/*
+___optional_and_compiler_dependent_section_pragmas_or_defines_and_includes_for_forcing_special_linkage_in_modules
+*/
+#define VX1000_START_SEC_VAR_CLEARED
+#include  "MemMap.h"
+
+
+#elif defined(VX1000_ENDSECT_VXSTRUCT_H) && (!defined(VX1000_ENDSECT_VXSTRUCT_H_UNDO))
+
+/* ----------------------------------------------------------------------------- */
+/* Code lines to close the (optional) memory section of the global VX1000 data.  */
+/* These lines will be placed via #include mechanism right after the declaration */
+/* of the VX1000 structure in the header file of the driver and must match the   */
+/* tool chain that you\'re using to build the application.                        */
+
+/*
+___optional_and_compiler_dependent_section_pragmas_or_defines_and_includes_for_restoring_previous_linkage_in_headers
+*/
+
+
+#elif defined(VX1000_ENDSECT_VXSTRUCT_C) && (!defined(VX1000_ENDSECT_VXSTRUCT_C_UNDO))
+
+/* ----------------------------------------------------------------------------- */
+/* Code lines to close the (optional) memory section of the global VX1000 data.  */
+/* These lines will be placed via #include mechanism right after the allocation  */
+/* of the VX1000 structure in the module file of the driver and must match the   */
+/* tool chain that you\'re using to build the application.                        */
+
+/*
+___optional_and_compiler_dependent_section_pragmas_or_defines_and_includes_for_restoring_previous_linkage_in_modules
+ */
+#define VX1000_STOP_SEC_VAR_CLEARED
+#include  "MemMap.h"
+
+
+#elif defined(VX1000_BEGSECT_VXMODULE_H) && (!defined(VX1000_BEGSECT_VXMODULE_H_UNDO))
+
+/* ----------------------------------------------------------------------------- */
+/* Optional Code lines that you may want to place at the beginning of the        */
+/* header file of the driver, e.g. with #pragmas to force a special linkage.     */
+
+/*
+___optional_and_compiler_dependent_section_pragmas_or_defines_and_includes_for_forcing_special_linkage_in_headers
+*/
+
+
+#elif defined(VX1000_BEGSECT_VXMODULE_C) && (!defined(VX1000_BEGSECT_VXMODULE_C_UNDO))
+
+/* ----------------------------------------------------------------------------- */
+/* Optional Code lines that you may want to place at the beginning of the        */
+/* module file of the driver, e.g. with #pragmas to force a special linkage      */
+/* or to raise the compiler\'s optimisation level for only this module.           */
+
+/*
+___optional_and_compiler_dependent_section_pragmas_or_defines_and_includes_for_forcing_special_linkage_in_modules
+*/
+
+
+#elif defined(VX1000_ENDSECT_VXMODULE_H) && (!defined(VX1000_ENDSECT_VXMODULE_H_UNDO))
+
+/* ----------------------------------------------------------------------------- */
+/* Optional Code lines that you may want to place at the end of the              */
+/* header file of the driver, e.g. with #pragmas to restore standard linkage.    */
+
+/*
+___optional_and_compiler_dependent_section_pragmas_or_defines_and_includes_for_restoring_previous_linkage_in_headers
+*/
+
+
+#elif defined(VX1000_ENDSECT_VXMODULE_C) && (!defined(VX1000_ENDSECT_VXMODULE_C_UNDO))
+
+/* ----------------------------------------------------------------------------- */
+/* Optional Code lines that you may want to place at the end of the              */
+/* module file of the driver, e.g. with #pragmas to restore standard linkage.    */
+
+/*
+___optional_and_compiler_dependent_section_pragmas_or_defines_and_includes_for_restoring_previous_linkage_in_modules
+*/
+
+
+#elif defined(VX1000_BEGSECT_EMEM_HDR_H) && (!defined(VX1000_BEGSECT_EMEM_HDR_H_UNDO))
+
+/*
+___optional_and_compiler_dependent_section_pragmas_or_defines_and_includes_for_forcing_special_linkage_in_headers
+*/
+
+
+#elif defined(VX1000_BEGSECT_EMEM_HDR_C) && (!defined(VX1000_BEGSECT_EMEM_HDR_C_UNDO))
+
+/*
+___optional_and_compiler_dependent_section_pragmas_or_defines_and_includes_for_forcing_special_linkage_in_modules
+*/
+
+
+#elif defined(VX1000_ENDSECT_EMEM_HDR_H) && (!defined(VX1000_ENDSECT_EMEM_HDR_H_UNDO))
+
+/*
+___optional_and_compiler_dependent_section_pragmas_or_defines_and_includes_for_restoring_previous_linkage_in_headers
+*/
+
+
+#elif defined(VX1000_ENDSECT_EMEM_HDR_C) && (!defined(VX1000_ENDSECT_EMEM_HDR_C_UNDO))
+
+/*
+___optional_and_compiler_dependent_section_pragmas_or_defines_and_includes_for_restoring_previous_linkage_in_modules
+*/
+
+
+
+
+
+/* ----------------------------------------------------------------------------- */
+/* Now follows the normal configuration header that auto-protects itself from    */
+/* repeated inclusion. This part contains the configuration of the various       */
+/* features. If you turn a feature off, the associated code and data will not    */
+/* be present in your application, but you may still call the associated API     */
+/* because the driver provides empty defines with that API name in that case     */
+/* so you do NOT need to "conditionalise" your code via preprocessor #ifs ...    */
+#elif !defined(VX1000_CFG_H)
+#define VX1000_CFG_H
+
+
+/* ----------------------------------------------------------------------------- */
+/* This specifies the version numbers of the configuration template that this    */
+/* file was derived from. It is used in the compatibility check between the      */
+/* configuration file, the driver header file and the driver module file.        */
+
+#define VX1000_APPDRIVER_BUILDNUMBER_H 596UL
+
+
+/* ----------------------------------------------------------------------------- */
+/* The application may maintain its own version in range 0..255 (it is not       */
+/* interpreted by the AppDriver or VX1000, just displayed in VXconsole)          */
+
+#define VX1000_APPDRIVER_CONFIGVERSION 0U
+
+
+/* ----------------------------------------------------------------------------- */
+/* If for production code the entire VX1000 functionality shall be disabled      */
+/* transparently, enable the following define. This way, the driver module will  */
+/* not produce any code or constants, will not use RAM, and the driver header    */
+/* will provide empty API macros so that the application code needs no change.   */
+
+/*
+#define VX1000_DISABLE_INSTRUMENTATION
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* Optionally define a compiler dependent expression that just evaluates to the  */
+/* value of the 2nd parameter (whose expected type is the 1st parameter) but as  */
+/* a side effect may perform a dummy access of the four remaining parameters in  */
+/* a way that prevents compiler warnings about unused or needlessly initialised  */
+/* variables inside the calling code if needed. Be aware that those parameters   */
+/* can be of any type, e.g. constants, immediates, variables or pointers with    */
+/* arbitrary qualifiers like const or volatile. If you leave this undefined the  */
+/* default definition to just "(R)" will become active which definitely does     */
+/* not produce any code to be executed but cannot prevent any warning.           */
+
+#define VX1000_DISCARD4DUMMYARGS(T, R, A1, A2, A3, A4)  ((R) + (T)(0UL & (((VX1000_UINT32)(A1) & (VX1000_UINT32)(A2)) | ((VX1000_UINT32)(A3) & (VX1000_UINT32)(A4))))) /* PRQA S 3453 */ /* Willingly violating MISRA rule 19.7 because the goal of this expression is that the compiler does NOT generate any code for it so a function call is the opposite of what is needed here */
+
+/* ----------------------------------------------------------------------------- */
+/* Optionally define a compiler dependent statement that just reads the value    */
+/* of its macro parameter without modifying it or relying on it to be of a       */
+/* specific type (it can be e.g. a constant, immediate, variable or a pointer    */
+/* with arbitrary qualifiers like const or volatile). If you leave this          */
+/* undefined the default definition to "" will become active. You may want to    */
+/* find a solution per tool chain, e.g. for 100% coverage it is good to HAVE     */
+/* code generated for it (e.g. a NOP) while for normal compilation you want no   */
+/* code that would have to be executed at runtime and for MISRA or LINT checkers */
+/* you definitely need a statement that actually touches the parameter.          */
+
+#define VX1000_DUMMYREAD(X) (void)(X); /* PRQA S 3412 */ /* Willingly violating MISRA rule 19.4 to be able to expand either to nothing (= no ; without statement) or to a correctly terminated (with ;) statement */
+
+
+#if defined(VX1000_DISABLE_INSTRUMENTATION)
+/* ----------------------------------------------------------------------------- */
+/* As some compilers fail creating completely empty object files or fail         */
+/* linking those, you may provide this define as a workaround that makes the     */
+/* driver module look "somehow non-empty" to compiler and linker.                */
+
+/*
+#define VX1000_EMPTYFILE_DUMMYDECL     ___some_dummy_constant_declaration_or_function_declaration
+*/
+
+#else /* !VX1000_DISABLE_INSTRUMENTATION */
+
+/* ----------------------------------------------------------------------------- */
+/* DAP mode can use 2 or 3 pins. Define the hardware initialisation values to    */
+/* enable the desired DAP mode and disable BYPASS (JTAG) to increase immunity    */
+/* against disturbances. Two-wire DAP mode is highly recommended, e.g.:          */
+/* VX1000_OCDS_OIFM ==   0x00000000UL selects Two-pin DAP with disabled BYPASS   */
+/* VX1000_OCDS_OCNTRL == 0x00000007UL selects Two-pin DAP with disabled BYPASS   */
+/* VX1000_OCDS_OCNTRL == 0x0000000FUL selects Three-pin DAP with disabled BYPASS */
+
+/*
+#define VX1000_OCDS_OCNTRL             ___a_32bit_constant_that_is_used_to_initialize_the_OCNTRL_register
+#define VX1000_OCDS_OIFM               ___a_32bit_constant_that_is_used_to_initialize_the_OIFM_register
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* Optionally define VX1000_ECU_IS_AURIX() to the desired boolean for speed and  */
+/* code size optimisations by tayloring the driver to support either classic     */
+/* Tricore or Tricore Aurix. If you leave this undefined, the driver             */
+/* automatically choses the right code at runtime by evaluating the JTAG ID.     */
+
+
+#define VX1000_ECU_IS_AURIX()          1U
+#define VX1000_ECU_IS_AURIXPLUS()      0U
+
+
+/* ----------------------------------------------------------------------------- */
+/* If no RSTOUT line is available, the VX1000_INIT() tries to check for software */
+/* resets, but to be able to do so, the whole gVX1000 structure as well as the   */
+/* OLDA memory have to be located in a no-clear area of the RAM. Activate the    */
+/* following define if a RSTOUT line to the VX hardware is available that        */
+/* signals SW resets. In this case, the unneeded checks and restrictions inside  */
+/* the driver will be disabled because the VX1000 can detect resets electrically */
+
+
+#define VX1000_SW_RSTOUT_AVAILABLE
+
+
+/* ----------------------------------------------------------------------------- */
+/* Optionally define the compiler dependent type for 64bit variables for OLDAv8  */
+#if 0
+typedef long unsigned long MY_UINT64_T;/* note: \'long long\' is a language extension that is not allowed by MISRA */
+#else //0
+typedef unsigned long long MY_UINT64_T;/* note: \'long long\' is a language extension that is not allowed by MISRA */
+#endif //0
+#define VX1000_UINT64 MY_UINT64_T      /* ___the_64bit_interger_type_that_is_provided_by_the_used_compiler_for_this_plattform */
+
+/* ----------------------------------------------------------------------------- */
+/* Define the target ECU identification string (for XCP GET_ID)                  */
+/* This is optional and may be used by CANape to auto-select the correct         */
+/* A2L database when connecting to an unidentified ECU. Just leave this          */
+/* undefined if you do not want to exploit this feature.                         */
+#include "swid.h"
+
+#define VX1000_ECUID_PTR               (VX1000_PTR2CU8_TO_ADDRESS(&SWID_a2lfilename[0]))
+#define VX1000_ECUID_LEN     38U          /*___the_count_of_characters_in_VX1000_ECUID_excluding_the_terminating_zero_byte*/
+
+
+
+/* ----------------------------------------------------------------------------- */
+/* To allow re-compilation of the driver code for different targets with common  */
+/* linkage of the data (e.g. to have the code replicated into the local IRAMs of */
+/* each core, or when the cores are differently equipped with instruction set    */
+/* extensions or when the cores use completely different instruction sets, like  */
+/* HC12<>XGATE, ARM<>THUMB, BookE<>VLE, Tricore<>XC800, ...), you may provide    */
+/* a string that will serve as function suffix. A second effect is that the      */
+/* code is optimized with respect to main/slave-core nature of the driver        */
+/* architecture: the objects for the slave cores\' functions will not contain     */
+/* code to detect whether they run on the main core, nor the main-core-only      */
+/* features (like mailbox etc.) Just leave this undefined if the driver shall    */
+/* be executed on the main core (or on a single-core MCU).                       */
+
+/*
+#define VX1000_COMPILED_FOR_SLAVECORES ___an_optional_unique_sequence_of_some_letters_and_digits
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* Some configuration settings cannot be checked at compile time. The driver     */
+/* therefore performs several runtime checks. Some of these checks happen in     */
+/* response to XCP requests which allows to transmit the result to the XCP       */
+/* master but other checks happen implicitly during start-up. In the latter case */
+/* there is no XCP channel to transmit the error code and therefore the driver   */
+/* offers the possibility to log these error codes into a ring buffer in RAM.    */
+/* You may optionally specify the size of that ring buffer here, where the       */
+/* default value of 0 means that there is no logging at all.                     */
+
+/*
+#define VX1000_ERRLOG_SIZE             ___optional_count_of_entries_in_the_fault_collection_buffer
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* The VX1000_CLOCK() callback is important for the correct detection of timeout */
+/* expiries, benchmarking and the time-stamping of DAQ packets.                  */
+/* The VX1000 app driver must know the resolution of the timer as returned by    */
+/* VX1000_CLOCK(), which is achieved in EITHER of two ways.                      */
+/* In some cases, undesired compiler warnings cannot be avoided if the first     */
+/* method is applied, so if you encounter inexplicable warnings, especially      */
+/* about conditions always being true/false, try the second method.              */
+
+/* 1) Define ONE of the VX1000_CLOCK_TICKS_PER_S, VX1000_CLOCK_TICKS_PER_MS or   */
+/* VX1000_CLOCK_TICKS_PER_US macros - which one depends on how fast your clock   */
+/* runs (easiest).                                                               */
+/*
+#define VX1000_CLOCK_TICKS_PER_MS      1000
+*/
+
+#define VX1000_CLOCK_TICKS_PER_US      300
+/*
+#define VX1000_CLOCK_TICKS_PER_S       ___alternative2_to_VX1000_CLOCK_TICKS_PER_MS
+*/
+
+/* 2) Define BOTH of VX1000_CLOCK_TICKS_BASE_NS and VX1000_CLOCK_TICKS_PER_BASE  */
+/* macros to declare the exact interval (in nanoseconds) and the number of ticks */
+/* your clock produces during one interval (recommended). The value of define    */
+/* VX1000_CLOCK_TICKS_BASE_NS must expand to an immediate because the pre-       */
+/* processor decides depending on its value whether the compiled code will first */
+/* divide and then multiply in timeout computations or the other way round.      */
+
+/*
+#define VX1000_CLOCK_TICKS_BASE_NS     ___alternative3_to_VX1000_CLOCK_TICKS_PER_US_OR_MS_OR_S
+#define VX1000_CLOCK_TICKS_PER_BASE    ___alternative3_to_VX1000_CLOCK_TICKS_PER_US_OR_MS_OR_S
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* If you want to synchronise/syntonise events in this ECU to events in further  */
+/* ECUs or in the PC, you have to provide two additional details about the time  */
+/* base of the driver. Just leave this undefined if you don\'t need that feature, */
+/* then the VX blindly trusts VX1000_CLOCK(), assuming full 32bit time stamps.   */
+
+/*
+#define VX1000_CLOCK_TIMER_ADDR        ___an_optional_pointer_to_the_memory_mapped_32bit_register_that_VX1000_CLOCK_timestamps_are_based_on
+#define VX1000_CLOCK_TIMER_SIZE        ___the_count_of_valid_bits_in_the_timer_hardware_register_rounded_down_to_0_or_16_or_24_or_32
+*/
+
+#define VX1000_CLOCK_TIMER_ADDR        0xF0001010
+#define VX1000_CLOCK_TIMER_SIZE        32
+
+/* ----------------------------------------------------------------------------- */
+/* Whenever a variable that doesn\'t allow for measurement via trace is to be     */
+/* measured, VX1000_OLDA must be enabled.                                        */
+
+#define VX1000_OLDA
+
+#if defined(VX1000_OLDA)
+
+/* ----------------------------------------------------------------------------- */
+/* In some cases, adding some extra code at the start of that function in charge */
+/* of the copying of measurement data and event signalisation can cause some     */
+/* very time-critical instructions to end up at more appropriate addresses in    */
+/* memory, leading to better cache efficiency and higher event rates.            */
+/* You may want to try to define VX1000_OLDA_NOPS to expand to some void code    */
+/* that will be inserted there if your event rate is too low.                    */
+
+#define VX1000_OLDA_NOPS()
+
+/* ----------------------------------------------------------------------------- */
+/* Define the memory size in bytes for the OLDA DAQ transfer tables.             */
+/* Size needs to be at least the amount of measurement data + 4 Byte for each    */
+/* memory gap. Note that "0" has special meaning "16Kb in EMEM"                  */
+/* Note that the maximum value allowed is 0xFFFCU!                               */
+
+#define VX1000_OLDA_MEMORY_SIZE     0x2800   /*___the_size_in_bytes_to_be_allocated_by_the_driver_as_copy_buffers*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* Optionally define VX1000_OLDA_MEMORY_ADDR to reuse user space for VX at that  */
+/* address. (Otherwise VX1000_OLDA_MEMORY_SIZE bytes will be allocated           */
+/* automatically inside the VX1000_DATA structure.) Note that "0" has special    */
+/* meaning "16Kb in EMEM".                                                       */
+
+/*
+#define VX1000_OLDA_MEMORY_ADDR        ___optional_address_of_a_RAM_area_that_can_be_used_exclusively_by_the_VX
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* Enable Olda overload detection.                                               */
+
+/*
+#define VX1000_OLDA_OVERLOAD_DETECTION
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* To turn on benchmarks of the event copy durations, needs 8bytes RAM per event */
+
+#define VX1000_OLDA_BENCHMARK
+
+/* ----------------------------------------------------------------------------- */
+/* VX1000_OLDA_BENCHMARK_CNT is an optional configuration parameter that allows  */
+/* you to limit the number of benchmarked events. For obvious reasons, this      */
+/* must not be bigger than the event channels total.                             */
+
+/*
+#define VX1000_OLDA_BENCHMARK_CNT __number_of_benchmarked_event_channels
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* You may want to use classic OLDA v6 format for the transfer table entries     */
+/* because it needs 20% less RAM for the transfer descriptors. The drawback is   */
+/* that it cannot enable access to all ECU memory locations as V7 would do.      */
+/* Furthermore it is not usable when coldstart/VX detection shall be available!  */
+
+/*
+#define VX1000_OLDA_FORCE_V6
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* To override the default encoding of OLDA v6 transfer table entries            */
+
+/*
+#define VX1000_OLDA_SIZE_LENGTH        ___a_value_relevant_only_for_OLDAv6_between_4_and_7
+#define VX1000_OLDA_SIZE_OFFSET        ___a_value_relevant_only_for_OLDAv6_providing_the_bit_index
+#define VX1000_OLDA_SIZE_SWAP_VALUE    ___a_value_relevant_only_for_OLDAv6_that_contains_VX1000_OLDA_SIZE_LENGTH_addressbits_at_VX1000_OLDA_SIZE_OFFSET_that_are_equal_among_all_measurements
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* Here you can enable features that may help to improve OLDA performance. The   */
+/* effect is not deterministic, so you should benchmark all versions to finally  */
+/* decide what shall be enabled or disabled. If you don\'t care for performance   */
+/* and RAM usage, just leave everything undefined.                               */
+
+#define VX1000_SUPPORT_OLDA7_BYTEDAQ
+#define VX1000_SUPPORT_OLDA7_COMPRESS
+
+
+/* ----------------------------------------------------------------------------- */
+/* The mechanism used to trigger DAQ events depends on the kind of POD used.     */
+/* Only with HSSL pods triggering via trace works reliable on TriCore, so if     */
+/* an MSSL pod is used, VX1000_SUPPRESS_TRACE_SUPPORT should be defined.         */
+/*
+#define  VX1000_SUPPRESS_TRACE_SUPPORT
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* If you\'re using a VX FW v3.7 or higher, you may want to experience OLDA v8    */
+/* because it may help to optimise resource utilisation. The drawback is that    */
+/* it cannot be used when coldstart/VX detection shall be usable. There are      */
+/* several sub-options to trim the behaviour of the driver and the VX.           */
+
+/*
+#define VX1000_OLDA_FORCE_V8
+
+#define VX1000_SUPPORT_OLDA8CMD_CALLJITA
+#define VX1000_SUPPORT_OLDA8CMD_CP64N
+#define VX1000_SUPPORT_OLDA8CMD_CP32N
+#define VX1000_SUPPORT_OLDA8CMD_CP16N
+#define VX1000_SUPPORT_OLDA8CMD_CP8N
+#define VX1000_SUPPORT_OLDA8CMD_SP8N
+#define VX1000_SUPPORT_OLDA8CMD_LEGACYVR
+*/
+
+#endif /* VX1000_OLDA */
+
+
+/* ----------------------------------------------------------------------------- */
+/* Disable or enable and configure the stimulation / bypassing feature           */
+
+/*
+#define VX1000_STIM
+*/
+
+#if defined(VX1000_STIM)
+
+/* ----------------------------------------------------------------------------- */
+/* Configure the stimulation / bypassing feature. The event number range may     */
+/* be chosen freely, the maximum range is 0..31. Each event needs 4 Bytes RAM,   */
+/* so you may want to specify a smaller range.                                   */
+
+#define VX1000_STIM_EVENT_OFFSET       0     /* ___index_of_the_first_STIM_event */
+#define VX1000_STIM_EVENT_COUNT        31    /* ___count_of_available_STIM_events*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* Enable indirect stimulation to optimize performance against memory usage.     */
+/* Needs additional memory (amount of bypass data + 4 byte per memory gap)       */
+#if defined(VX1000_OLDA)
+#define VX1000_STIM_BY_OLDA
+#endif /* VX1000_OLDA */
+
+
+/* ----------------------------------------------------------------------------- */
+/* To turn on basic benchmarking of all bypass round trip times, just define     */
+/* VX1000_STIM_BENCHMARK. This will only use little RAM and runtime resources.   */
+
+/*
+#define VX1000_STIM_BENCHMARK
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* To turn on advanced benchmarking (of one particular STIM channel) you can     */
+/* define VX1000_STIM_HISTOGRAM to the desired channel number. This debug        */
+/* feature eats one kilobyte of RAM. Leave undefined to disable the feature.     */
+
+/*
+#define VX1000_STIM_HISTOGRAM          ((VX1000_STIM_EVENT_OFFSET) +0)
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* STIM version 0 works out of the box, is supported by all FW versions and does */
+/* not need additional RAM or configuration settings. However several advanced   */
+/* features are only available in STIM version 1 (only supported by FW 1.8 and   */
+/* newer!) If you want to use the advanced features, define VX1000_STIM_FORCE_V1 */
+/* and configure the particular features below.                                  */
+
+/*
+#define VX1000_STIM_FORCE_V1
+*/
+
+#if defined (VX1000_STIM_FORCE_V1)
+/* ----------------------------------------------------------------------------- */
+/* configuration of STIM version 1 special features                              */
+
+
+/* ----------------------------------------------------------------------------- */
+/* Define the STIM behaviour after ECU resets                                    */
+
+#define VX1000_IS_BYPASS_RESUME_ALLOWED() ___an_expression_that_returns_TRUE_if_and_only_if_bypassing_shall_be_resumed_after_an_ECU_reset()
+
+
+/* ----------------------------------------------------------------------------- */
+/* Inform the VX1000 how a specific XCP event is to be handled. For each STIM    */
+/* event, the following information must be provided: What is the associated     */
+/* DAQ event (for the bypassing upload path) and which STIM type out of the      */
+/* following set (VX1000_BYPASS_TYPE_DIRECT, VX1000_BYPASS_TYPE_OLDA,            */
+/* VX1000_BYPASS_TYPE_HOOK) shall be used.                                       */
+
+#define VX1000_SET_STIM_INFO() do                                                                        \\
+  {                                                                                                      \\
+    VX1000_REGISTER_STIM_EVENT(___associated_DAQ_event_ID, ___first_STIM_event_ID, ___desired_STIM_type) \\
+    ...                                                                                                  \\
+    VX1000_REGISTER_STIM_EVENT(___associated_DAQ_event_ID, ___last_STIM_event_ID , ___desired_STIM_type) \\
+  } while (0); /* dummy loop only here for MISRA */
+
+
+
+/* ----------------------------------------------------------------------------- */
+/* Depending on the STIM type, the driver can be forced to wait for all channels */
+/* to have receive complete/valid STIM data before the application will see data */
+
+/*
+#define VX1000_BYPASS_ALL_CHANS_STIMD
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* You may override VX1000_BYPASS_ALL_CHANS_STIMD in arbitrary situations for    */
+/* any event E by defining the callback VX1000_IS_INSTANT_BYP_ALLOWED(E) to      */
+/* evaluate to / return "1" in that case (and "0" otherwise)                     */
+
+/*
+#define VX1000_IS_INSTANT_BYP_ALLOWED(E) 0
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* If the STIM type VX1000_BYPASS_TYPE_HOOK shall be used,                       */
+/* VX1000_HOOK_BASED_BYPASSING must be enabled and configured below              */
+
+/*
+#define VX1000_HOOK_BASED_BYPASSING
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* Specify where in RAM the hook based bypassing lookup table resides            */
+
+/*
+#define VX1000_BYPASS_HBB_LUT_ADDR     ___address_of_the_HBB_lookup_table
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* Specify how many entries in the hook based bypassing lookup table exist       */
+
+/*
+#define VX1000_BYPASS_HBB_LUT_ENTRIES  ___number_of_entries_in_the_HBB_lookup_table
+*/
+
+#endif /* VX1000_STIM_FORCE_V1 */
+
+#endif /* VX1000_STIM */
+
+/* ----------------------------------------------------------------------------- */
+/* Define the maximum coldstart delay from VX1000_INIT_ASYNC_START to            */
+/* VX1000_INIT_ASYNC_END in milliseconds (a value of 0 disables the delay).      */
+
+/*
+#define VX1000_COLDSTART_TIMEOUT_MS    ___the_number_of_milliseconds_to_wait_for_tool_during_coldstart
+*/
+#define VX1000_COLDSTART_TIMEOUT_MS 80
+/* ----------------------------------------------------------------------------- */
+/* Turn on benchmarking of the cold start behaviour (undef this to save memory)  */
+
+/*
+#define VX1000_COLDSTART_BENCHMARK
+*/
+#define VX1000_COLDSTART_BENCHMARK
+/* ----------------------------------------------------------------------------- */
+/* Depending on the wiring of the ECU, software reset may not be visible for the */
+/* VX and the measurement will not be restarted automatically when the ECU       */
+/* finished booting. As a workaround, the driver provides a handshake mechanism  */
+/* that allows the application to inform the VX via the VX1000_PREPARE_SOFTRESET */
+/* API right before performing the reset. The maximum allowed delay of the       */
+/* handshake must be specified here. If it is not defined, the API will be empty */
+
+/*
+#define VX1000_SOFTRESET_TIMEOUT_MS    ___the_number_of_milliseconds_to_wait_for_tool_before_a_softreset
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* VX1000 Detection                                                              */
+
+/*
+#define VX1000_DETECTION
+*/
+#define VX1000_DETECTION_TIMEOUT_US 80 /* ___the_number_of_microseconds_to_wait_for_tool_response_during_presence_check*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* If you want to use the OLDA mechanism together with a HSSL pod or your MCU    */
+/* belongs to the TMS570 family, you have to define VX1000_MEMSYNC_TRIGGER_COUNT */
+/* to a value in the range 1 to 8 (typically 1 is just fine and larger values    */
+/* are only needed if not any write from any core to any memory can be traced    */
+/* by the MCU). Leave this undefined if you\'re using a MSSL pod or if your       */
+/* VX firmware version is older than release 3.2                                 */
+
+/*
+#define VX1000_MEMSYNC_TRIGGER_COUNT   __optional_memsync_count_in_the_range_1_to_8
+*/
+
+#if defined(VX1000_MEMSYNC_TRIGGER_COUNT)
+#if (VX1000_MEMSYNC_TRIGGER_COUNT == 1)
+
+/* ----------------------------------------------------------------------------- */
+/* You may optionally define an address of memory that shall be used by the      */
+/* AppDriver to send messages to the VX via memory write trace. If you leave     */
+/* this undefined, the AppDriver will allocate and use memory inside gVX1000.    */
+
+/*
+#define VX1000_MEMSYNC_TRIGGER_PTR     ___an_optional_address_of_64_unused_bytes_that_every_core_can_write_to_and_whose_writes_are_all_traceable
+*/
+
+#elif (VX1000_MEMSYNC_TRIGGER_COUNT > 1)
+
+/* ----------------------------------------------------------------------------- */
+/* Define at least VX1000_MEMSYNC_TRIGGER_COUNT addresses of memory that will    */
+/* be used by the AppDriver to send messages to the VX via memory write trace.   */
+
+#define VX1000_MEMSYNC_TRIGGER_PTR0    ___an_address_of_64_unused_bytes_that_every_core_can_write_to_and_whose_writes_are_all_traceable
+#define VX1000_MEMSYNC_TRIGGER_PTR1    ___an_address_of_64_unused_bytes_that_one_core_can_write_to_quickly_and_whose_writes_are_traceable
+#define VX1000_MEMSYNC_TRIGGER_PTR2    ___an_address_of_64_unused_bytes_that_one_core_can_write_to_quickly_and_whose_writes_are_traceable
+#define VX1000_MEMSYNC_TRIGGER_PTR3    ___an_address_of_64_unused_bytes_that_one_core_can_write_to_quickly_and_whose_writes_are_traceable
+#define VX1000_MEMSYNC_TRIGGER_PTR4    ___an_address_of_64_unused_bytes_that_one_core_can_write_to_quickly_and_whose_writes_are_traceable
+#define VX1000_MEMSYNC_TRIGGER_PTR5    ___an_address_of_64_unused_bytes_that_one_core_can_write_to_quickly_and_whose_writes_are_traceable
+#define VX1000_MEMSYNC_TRIGGER_PTR6    ___an_address_of_64_unused_bytes_that_one_core_can_write_to_quickly_and_whose_writes_are_traceable
+#define VX1000_MEMSYNC_TRIGGER_PTR7    ___an_address_of_64_unused_bytes_that_one_core_can_write_to_quickly_and_whose_writes_are_traceable
+
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 0)
+
+
+/* ----------------------------------------------------------------------------- */
+/* Just leave VX1000_MEMSYNC_COPY_COUNT undefined unless you\'re using TMS570.    */
+
+/*
+#define VX1000_MEMSYNC_COPY_COUNT      __the_maximum_count_of_TMS570_or_QUASAR3_trace_windows_that_you_would_ever_use
+*/
+
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 0 */
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+
+
+/* ----------------------------------------------------------------------------- */
+/* Calibration of flash at runtime is possible if the MCU supports it and if     */
+/* the following defines are configured properly. The sub-feature of page        */
+/* switching allows transaction-based calibrate and to undo the entire           */
+/* calibration with a single command. Because this feature may alter also        */
+/* code being executed by the ECU, you should know well what you\'re doing.       */
+
+/*
+#define VX1000_OVERLAY
+*/
+
+
+#if defined(VX1000_OVERLAY)
+
+/* ----------------------------------------------------------------------------- */
+/* By default, the overlay is activated in VX1000_INIT() call and stays active   */
+/* all the time. If you need more control and want to switch between the overlay */
+/* pages, this can be enabled by defining VX1000_MAILBOX_OVERLAY_CONTROL         */
+
+#define VX1000_MAILBOX_OVERLAY_CONTROL
+
+
+/* ----------------------------------------------------------------------------- */
+/* By default, the overlay is configured statically by the defines in this       */
+/* header. Unless the DigRF interface is used, you can enable dynamic            */
+/* configuration of the overlay(s) based on the requests of the tool to          */
+/* gain better resource utilisation.                                             */
+
+/*
+#define VX1000_OVERLAY_VX_CONFIGURABLE
+*/
+
+#if defined(VX1000_OVERLAY_VX_CONFIGURABLE)
+
+
+/* ----------------------------------------------------------------------------- */
+/* Enable the desired overlay features depending on the ECU capabilities         */
+
+/* Can the application handle keep-awakes correctly?                             */
+#define VX1000_OVLENBL_KEEP_AWAKE
+/* Does the application want to verify the working page before page switch?      */
+#define VX1000_OVLENBL_VALIDATE_PAGESW
+/* Has the EMEM a dedicated power supply?                                        */
+#define VX1000_OVLENBL_PERSISTENT_EMEM
+/* Will the application perform a soft-reset after it detected a CAL-Wakeup?     */
+#define VX1000_OVLENBL_RST_ON_CALWAKEUP
+/* Shall the EPK address of the WP be calculated by the VX1000?                  */
+#define VX1000_OVLENBL_USE_VX_EPK_TRANS
+/* Shall the VX write the overlay registers via mailbox? This is e.g. needed     */
+/* when the VX is connected via DigRF which has only limited access rights.      */
+/* Note that this is currently only implemented for TC27x/TC29x devices.         */
+#define VX1000_OVLENBL_REGWRITE_VIA_MX
+
+#else /* !VX1000_OVERLAY_VX_CONFIGURABLE */
+
+/* ----------------------------------------------------------------------------- */
+/* A static definition of the overlay memory areas must be provided in this mode */
+/* By default, the driver assumes that the application uses a 1:1 address        */
+/* mapping to access the memory and thus the defines VX1000_OVERLAY_PHYSADDR     */
+/* and VX1000_CALRAM_PHYSADDR need only to be provided if both the MCU provides  */
+/* the feature of non-1:1 mappings and the application actually makes use of it. */
+
+#define VX1000_OVERLAY_SIZE            ___the_size_of_the_to_be_overlaid_flash_area_of_supported_granularity
+#define VX1000_OVERLAY_ADDR            ___the_uncached_address_of_the_to_be_overlaid_flash_area_of_supported_alignment
+#define VX1000_CALRAM_ADDR             ___the_uncached_address_of_the_unused_RAM_area_that_shall_overlay_the_flash
+
+
+/* ----------------------------------------------------------------------------- */
+/* Select which hardware (sub-)module in the ECU shall perform the overlay       */
+/* address mapping. These settings depend on the derivative AND on the start-up  */
+/* code AND on the application and potentially other XCP drivers. Only one       */
+/* method can be activated for a given setup. The specified overlay descriptor   */
+/* cannot be used for other purposes by the application or other drivers.        */
+
+/*
+#define VX1000_OVERLAY_DESCR_IDX       ___the_correct_index_of_the_descriptor_that_is_used_in_the_PFLASH_unit_to_map_the_overlay_area
+*/
+
+#endif /* !VX1000_OVERLAY_VX_CONFIGURABLE */
+
+/* ----------------------------------------------------------------------------- */
+/* Core synchronous page switching means that each core switches the overlay     */
+/* unit in the microcontroller for its own. In a multicore system there are      */
+/* several points in time where the page switch is performed (corresponding to   */
+/* the number of cores). Each core may switch its page outside of all tasks      */
+/* that are running on this core. This option is only possible when the          */
+/* microcontroller\'s overlay unit supports independent page switches for the     */
+/* cores. On the other hand it is a must on those multicore systems where each   */
+/* core brings an independent overlay unit that can only be programmed by the    */
+/* core itself (e.g. core-internal MMU; see VX1000_OVLENBL_HW_INIT_PER_CORE).    */
+/* The feature is enabled when VX1000_OVLENBL_CORE_SYNC_PAGESW is defined.       */
+
+/*
+#define VX1000_OVLENBL_CORE_SYNC_PAGESW
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* Synchronous calibration page switching means that the ECU is signalled by     */
+/* the VX1000 to perform a page switch. The VX1000 pre-configures the overlay    */
+/* registers and signals the ECU which overlay register sets should be           */
+/* enabled/disabled. Before the ECU performs the page switch additional          */
+/* validation checks can be performed. If the application requires a             */
+/* task- or core- synchronous page switching, the application is responsible     */
+/* for executing the page switch only in synchronised situations. If you leave   */
+/* VX1000_OVLENBL_SYNC_PAGESWITCH undefined the VX1000 will switch the page in   */
+/* the background without ECU application interaction.                           */
+
+/*
+#define VX1000_OVLENBL_SYNC_PAGESWITCH
+*/
+
+#if defined(VX1000_OVLENBL_CORE_SYNC_PAGESW) || defined(VX1000_OVLENBL_SYNC_PAGESWITCH)
+/* ----------------------------------------------------------------------------- */
+/* In multi-core (or better "multi-bus-master") environments, it may be          */
+/* desirable to make the overlay visible to only some of the bus masters while   */
+/* the remaining masters shall continue accessing the reference page. For this   */
+/* purpose you have to define a bit mask VX1000_OVL_CAL_BUS_MASTER according     */
+/* to the PFlash register definition of your MCU.                                */
+
+#define VX1000_OVL_CAL_BUS_MASTER      ___a_derivative_dependent_bitmask_of_relevant_PFLASH_busmasters
+
+
+/* ----------------------------------------------------------------------------- */
+/* If the application performs an ECU reset after page switches (e.g. as very    */
+/* rude method for synchronising multiple cores and DMA controllers) the VX must */
+/* be informed beforehand about this behaviour by enabling the following define. */
+
+/*
+#define VX1000_OVLENBL_RST_ON_SNCPAGESW
+*/
+
+#endif /* VX1000_OVLENBL_CORE_SYNC_PAGESW || VX1000_OVLENBL_SYNC_PAGESWITCH */
+
+
+#if defined(VX1000_OVLENBL_USE_VX_EPK_TRANS)
+/* ----------------------------------------------------------------------------- */
+/* Configure the parameters of some special feature.                             */
+/* (For the average use-case this may just be left undefined.)                   */
+
+#define VX1000_OVL_EPK_REFPAGE_ADDR    ___the_correct_address
+#define VX1000_OVL_EPK_LENGTH          ___the_correct_size
+
+#endif /* VX1000_OVLENBL_USE_VX_EPK_TRANS */
+
+#endif /* VX1000_OVERLAY */
+
+
+
+/* ----------------------------------------------------------------------------- */
+/* Enable the mailbox to forward some XCP commands between tool and application  */
+/* It can be used e.g. for printf, page switching, copy page or page relocation  */
+/* The sub features can be enabled or disabled individually and are only active  */
+/* if VX1000_MAILBOX is defined. The default mailbox has a reasonable size for   */
+/* the average purpose but the size may still be overridden below                */
+
+/*
+#define VX1000_MAILBOX
+*/
+/*
+#define VX1000_MAILBOX_SLOTS           ___an_optional_number_that_must_be_a_power_of_two
+#define VX1000_MAILBOX_SLOT_DWORDS     ___an_optional_number_that_must_be_greater_than_two
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* Enable this to allow the application to send formatted XCP SERV_TEXT messages */
+
+/*
+#define VX1000_MAILBOX_PRINTF
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* Enable this if a reduced printf version instead of the full one is sufficient */
+
+/*
+#define VX1000_PRINTF_MINIMAL
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* Enable these to provide a special upload or download API                      */
+
+/*
+#define VX1000_MAILBOX_PROVIDE_SPLITREAD
+#define VX1000_MAILBOX_PROVIDE_SPLITWRITE
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* XCP FKL loading support _without_ entering debug mode.                        */
+/* This is only needed for flash programming if the device cannot be driven      */
+/* externally into debug halt state, e.g.when the MCU must permanently serve     */
+/* an external watchdog. End of RAM is always a good place for this; the 32      */
+/* aligned bytes are only used by the VX during flash kernel start and may be    */
+/* used during normal operation for other purposes. The only requirement to this */
+/* physical address is that it does not overlap the FKL space.                   */
+
+/*
+#define VX1000_FKL_SUPPORT_ADDR        ___an_address_of_32_bytes_unused_RAM
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* This enables and configures the Resource Management feature.                  */
+/* This features helps to divide the resources of the micro-controller between   */
+/* the application of the ECU and the VX1000 AppDriver.                          */
+
+/*
+#define VX1000_RES_MGMT
+*/
+
+#if defined(VX1000_RES_MGMT)
+/* ----------------------------------------------------------------------------- */
+/* With this define the switches VX1000_RES_MGMT_RAM_START and                   */
+/* VX1000_RES_MGMT_RAM_SIZE are used to specify a memory-region that the VX1000  */
+/* AppDriver and the VX1000 hardware should use exclusively for measurement and  */
+/* calibration purposes (e.g. overlay, data trace, OLDA). This memory region     */
+/* shall not be accessed by the ECU application. Especially RAM checks/tests     */
+/* or memory/CRC initialisations are not permitted. As a result of this          */
+/* requirement the gVX1000 structure and the overlay EMEM headers (EMEM_HDR)     */
+/* shall not be located in this resource management memory region. If            */
+/* VX1000_OLDA_MEMORY_ADDR is explicitly defined, this memory shall not be       */
+/* located in the resource management memory region. Usually this feature is     */
+/* used to divide the emulation memory of a development device                   */
+
+/*
+#define VX1000_RES_MGMT_ENABLE_OVL_RAM
+#define VX1000_RES_MGMT_RAM_START      ___the_correct_address  -- note: had been called VX1000_RES_MGMT_OVL_RAM_START in the past
+#define VX1000_RES_MGMT_RAM_SIZE       ___the_correct_size     -- note: had been called VX1000_RES_MGMT_OVL_RAM_SIZE in the past
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* This feature is used to specify which overlay-register-items shall be used    */
+/* by the VX1000 Application System. The switches VX1000_RES_MGMT_CFG_ITEM_START */
+/* and VX1000_RES_MGMT_CFG_ITEM_LEN are used to select the register region       */
+/* (e.g. Start=0, Len=32). All other overlay-register-items are ignored during   */
+/* overlay-calculation. If nothing is specified the VX1000 will use all          */
+/* available Overlay-Registers. Normally this feature is not required and        */
+/* therefore not enabled.                                                        */
+
+/*
+#define VX1000_RES_MGMT_ENABLE_CFG_ITEM
+#define VX1000_RES_MGMT_CFG_ITEM_START ___the_correct_address
+#define VX1000_RES_MGMT_CFG_ITEM_LEN   ___the_correct_size
+*/
+
+#endif /* VX1000_RES_MGMT */
+
+
+
+/* ----------------------------------------------------------------------------- */
+/* You should include here the header(s) that provide the data types and the     */
+/* prototypes or SFR definitions that you will use as the application callbacks  */
+/* At this point, the selection of the used VX driver features is complete and   */
+/* the included header(s) may evaluate the above defines to provide only the     */
+/* desired functionality. This way, you will not run into compiler or MISRA      */
+/* warnings about uncalled functions and such.                                   */
+
+/*
+#include "___my_header_that_provides_the_needed_declarations.h"
+*/
+
+
+
+/* ----------------------------------------------------------------------------- */
+/* The driver needs a stable high resolution time base to correctly detect       */
+/* communication timeouts and optionally for time stamping the XCP packets.      */
+/* In particular, the time base is needed for the following features             */
+/*   1. DAQ over DATA TRACE with timestamps that relate to the ECU time          */
+/*   2. DAQ over JTAG is used (for Nexus class 2+)                               */
+/*   3. to validate/reject STIM_v1 packets                                       */
+/*   4. to check bypass timeouts                                                 */
+/*   5. to check coldstart delay timeouts                                        */
+/*   6. to check soft-reset notification timeouts                                */
+/* Undefine this to make the driver use internal code that reads from TriCore\'s  */
+/* STM_TIM0 register. (You still have to provide the actual timer resolution.)   */
+
+/*
+#define VX1000_CLOCK()                 (VX1000_UINT32)(___an_optional_function_or_Tricore_register_that_returns_a_freerunning_32bit_time())
+*/
+#define VX1000_CLOCK()                 (*(volatile VX1000_UINT32*)(volatile void*)((VX1000_UINT8*)0UL + (0xF0001010UL)))
+
+
+
+/* ----------------------------------------------------------------------------- */
+/* If the XCP features shall be used on more than one core, the driver needs     */
+/* an indicator whether it is running on the "main" core that is actively        */
+/* initialising a stable high resolution time base to correctly detect           */
+/* communication timeouts and optionally for time stamping the XCP packets       */
+
+/*
+//#define VX1000_RUNNING_ON_MAINCORE()   ___a_function_that_returns_true_if_and_only_if_executed_from_one_core_that_is_declared_the_main_core()
+#define VX1000_MCREG_CORE_ID           0xfe1c
+#define VX1000_MAINCORE                0x0
+#define VX1000_RUNNING_ON_MAINCORE()   (__mfcr(VX1000_MCREG_CORE_ID) == VX1000_MAINCORE)
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* Sometimes the driver needs to access data structures that need to be indexed  */
+/* by the currently active CPU core. Define VX1000_CURRENT_CORE_IDX() in such a  */
+/* way that for each core it returns a bijective index in the range [0,n), with  */
+/* n being the total number of cores.                                            */
+
+/*
+#define VX1000_CURRENT_CORE_IDX()      ___a_unique_index_in_the_range_0_to_(n-1)
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* On multicore systems, define an appropriate MUTEX mechanism to interlock      */
+/* code running on different cores. If you leave this undefined, the driver will */
+/* assume a non-preemptive single core system and not try do be thread-safe.     */
+
+/*
+#define VX1000_ENTER_SPINLOCK()        ___a_function_that_suppresses_execution_of_any_other_thread_until_VX1000_LEAVE_SPINLOCK_is_called();
+#define VX1000_LEAVE_SPINLOCK()        ___a_function_that_restores_the_suppression_state_from_before_VX1000_ENTER_SPINLOCK_was_called();
+*/
+
+
+/* ----------------------------------------------------------------------------- */
+/* When using OLDA v8, apart from relying on default routines for the copying of */
+/* measurement data into OLDA memory, you may also specify your own routine by   */
+/* defining VX1000_MEMCPY.                                                       */
+
+/*
+#define VX1000_MEMCPY(D, S, L)         ___a_function_that_efficiently_copies_L_bytes_from_S_to_D(...);
+*/
+
+
+
+/* ----------------------------------------------------------------------------- */
+/* If your compiler with your used compiler settings emits for writes to 64 bit  */
+/* variables two 32 bit store instructions instead of one single 64 bit store    */
+/* instruction, for several VX features to work properly you have to manually    */
+/* provide an assembly callback that performs a 64 bit store to the naturally    */
+/* aligned linear address in parameter 1 with the values of parameters 2 and 3   */
+/* concatenated to form the 32+32=64 bit store data, and hook that to the        */
+/* macro VX1000_STORE64. You may leave this undefined if the user data type      */
+/* VX1000_UINT64 is not provided or if the compiler creates 64 bit stores.       */
+/* Keep in mind that on heterogeneous MCUs this solution must work on ANY core.  */
+
+/*
+#define VX1000_STORE64(A, HI, LO )     ___a_macro_that_atomically_64bit_stores_the_concatenation_of_two_32bit_numbers_HI_and_LO_to_the_given_linear_address_A((A), (HI), (LO))
+#define exampleVX1000_STORE64(A,HI,LO) do { ((VX1000_ADDR_TO_PTR2VU64((A))))[0] = (((VX1000_UINT64)(HI) << 3) << 29) | (VX1000_UINT64)(LO); } while (0)  // This is just an example in C to be overruled by an assembly implementation with real 64-bit-store operation.
+*/
+
+/* ----------------------------------------------------------------------------- */
+/* If the application uses Autosar single pointer calibration via XCP, the       */
+/* VX blindly sends all up- and download via mailbox to the application and it   */
+/* is up to the application to inject the currently active address translation   */
+
+/*
+#define VX1000_SHORT_UPLOAD(D, S, L)   ___a_function_that_proprietarily_copies_L_bytes_from_S_to_D(...);
+#define VX1000_SHORT_DOWNLOAD(D, S, L) ___a_function_that_proprietarily_copies_L_bytes_from_S_to_D(...);
+*/
+
+
+#if defined(VX1000_OVERLAY)
+
+#if (!defined(VX1000_OVERLAY_DESCR_IDX)) && (!defined(VX1000_OVERLAY_VX_CONFIGURABLE))
+
+/* ----------------------------------------------------------------------------- */
+/* As you did not provide configuration of the built-in overlay handling, you    */
+/* must provide callbacks for manual handling the hardware and memory sections.  */
+/* You probably may want to reuse the API of an XCP on CAN driver but as well    */
+/* you may provide your very own implementation of all these callbacks:          */
+
+#define VX1000_INIT_CAL_PAGE()                       ___a_function_that_initialises_the_calpage_handler();
+#define VX1000_GET_CAL_PAGE(seg, mod)                ((VX1000_UINT8)___a_function_that_handles_XCP_get_calpage_command(...))
+#define VX1000_SET_CAL_PAGE(seg, pag, mod, startup)  ((VX1000_UINT8)___a_function_that_handles_XCP_set_calpage_command(...))  /* note: the 4th parameter is only needed for FW >= 1.7 */
+#define VX1000_COPY_CAL_PAGE(sseg, spag, dseg, dpag) ((VX1000_UINT8)___a_function_that_handles_XCP_copy_calpage_command(...))
+
+#endif /* !VX1000_OVERLAY_DESCR_IDX && !VX1000_OVERLAY_VX_CONFIGURABLE */
+
+
+/* ----------------------------------------------------------------------------- */
+/* If desired by the application, the driver may call hook functions in some     */
+/* situations. Just define some of the following callback defines to let your    */
+/* code be called                                                                */
+
+/*
+#define VX1000_OVL_RST_ON_CAL_WAKEUP_CB()                    ___a_void_function_with_userdefined_behaviour();
+*/
+/*
+#define VX1000_SYNCAL_VALIDATE_WP_CB(addr)                   ___an_expression_or_function_whose_return_value_influences_the_behaviour_of_the_builtin_VX1000_SET_CAL_PAGE_function(...)
+#define VX1000_SYNCAL_USRVALIDATE_WP_CB(value, mask, master) ___an_expression_or_function_whose_return_value_influences_the_behaviour_of_the_builtin_VX1000_SET_CAL_PAGE_function(...)
+*/
+#endif /* VX1000_OVERLAY */
+
+
+
+#if defined(VX1000_FKL_SUPPORT_ADDR)
+/* ----------------------------------------------------------------------------- */
+/* Hint: must be a macro or an ASM function because it must not use stack OR     */
+/* it may use stack but then VX1000_ENABLE_STANDARD_RAM_MAPPING() must ensure    */
+/* that the used stack does not overlap with the FKL space by updating A10. If   */
+/* you\'re really sure about a particular functionality being not needed for a    */
+/* use-case you must explicitly define it empty and don\'t forget comments then.  */
+
+#define VX1000_SERVE_WATCHDOG(x)           ___a_macro_that_serves_the_watchdog();
+#define VX1000_DISABLE_ALL_INTERRUPTS()    ___a_function_that_prevents_any_context_switching_to_other_tasks_or_ISRs();
+#define VX1000_STOP_OS_TIMING_PROTECTION() ___a_function_that_prevents_the_calling_process_being_killed_after_violating_its_time_budget();
+#define VX1000_STOP_OTHER_CORES()          ___a_function_that_prevents_that_other_busmasters_write_to_RAM();
+#define VX1000_ENABLE_STD_RAM_MAPPING()    ___a_function_that_disables_address_translation();
+
+#endif /* VX1000_FKL_SUPPORT_ADDR */
+
+#endif /* !VX1000_DISABLE_INSTRUMENTATION */
+
+#endif /* !VX1000_CFG_H (or any MEMMAP-part) */
+
diff --git a/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/make/makefile.mak b/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/make/makefile.mak
new file mode 100644
index 000000000..242de3534
--- /dev/null
+++ b/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/make/makefile.mak
@@ -0,0 +1,28 @@
+# \\\\file\
#
+# \\brief AUTOSAR <ComponentName>
+#
+# This file contains the implementation of AUTOSAR
+# module <ComponentName>.
+#
+# \\author <AuthorInformation> Siemens AG, 91056 Erlangen, Germany
+#
+# Copyright 2015 - 2015 Siemens AG
+# All rights exclusively reserved for Siemens AG,
+# unless expressly agreed to otherwise.#
+################################################################## DEFINITIONS#
+#################################################################
+
+
+VX1060_BASE := $(dir $(abspath $(lastword $(dir $(abspath $(lastword $(MAKEFILE_LIST)))))))
+VX1060_PATH_OUT := $(VX1060_BASE)generated
+VX1060_PATH_USE := $(VX1060_BASE)
+CC_FILES_TO_BUILD += $(wildcard $(VX1060_BASE)src/*.c)
+CPP_FILES_TO_BUILD += $(wildcard $(VX1060_BASE)src/*.cpp)
+ASM_FILES_TO_BUILD += $(wildcard $(VX1060_BASE)src/*.s)
+
+VX1060_ARCHIVED_LIB := $(wildcard $(VX1060_BASE)lib/*.a)
+VX1060_GENERATED_LIB := $(VX1060_BASE)generated/lib/VX1060.a
+VX1060_ARCHIVED_A2L := $(wildcard $(VX1060_BASE)a2l/*.a2l)
+VX1060_GENERATED_A2L := $(VX1060_BASE)generated/a2l/VX1060.a2l
+A2L_SLAVE_VX1060 = $(VX1060_GENERATED_A2L)
+CC_INCLUDE_PATH += $(VX1060_BASE)include
\\ No newline at end of file
diff --git a/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/src/VX1000.c b/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/src/VX1000.c
new file mode 100644
index 000000000..266dab95b
--- /dev/null
+++ b/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/src/VX1000.c
@@ -0,0 +1,8725 @@
+/*------------------------------------------------------------------------------- */
+/* VX1000.c                                                                       */
+/* Vector VX1000 Application Driver for Infineon Tricore with DAP1/2 or DigRf I/F */
+/* Release: 03_06                    Build: 596          Modification: 21.10.2017 */
+/* Vector Informatik GmbH                                                         */
+/*                                                                                */
+/* Don\'t modify this file, settings are defined in VX1000_cfg.h                   */
+/*------------------------------------------------------------------------------- */
+
+
+/* ----------------------------------------------------------------------------------------------------------------------- /
+/ Status of MISRA conformance:                                                                                             /
+/ ---------------------------                                                                                              /
+/  * advisory rule 19.1 "location of file inclusions"                                                                      /
+/     - violated because there exists no MISRA-conform workaround without loosing essential functionality                  /
+/     - see individual justifications of the particular violations in the code                                             /
+/                                                                                                                          /
+/  * advisory and required rules 11.3 "cast between pointers and integral types"                                           /
+/     - violated because copying data from and to arbitrary locations is the core feature of this module                   /
+/     - see individual justifications of the particular violations in the code                                             /
+/                                                                                                                          /
+/  * required rule 12.4 "condition check with side effects"                                                                /
+/     - just a phantom detection by the tool (the reported user callback is specified to have NO side effect).             /
+/     - see individual justifications of the particular violations in the code                                             /
+/                                                                                                                          /
+/  * required rule 14.2 "code without effect"                                                                              /
+/     - violated only by user callback "VX1000_DUMMYREAD" whose purpose exactly is to have no effect.                      /
+/     - see individual justifications of the particular violations in the code                                             /
+/                                                                                                                          /
+/  * required rule 16.1 "usage of variadic functions"                                                                      /
+/     - violated only if the user explicitly enables the debug print feature during development phase.                     /
+/     - see individual justifications of the particular violations in the code                                             /
+/                                                                                                                          /
+/  * required rule 19.15 "repeated file inclusion"                                                                         /
+/     - just a phantom detection by the checker tool, no real violation                                                    /
+/                                                                                                                          /
+/  * required rule 20.9 "inclusion of bad libraries"                                                                       /
+/     - violated only if the user explicitly enables the maximum debug print feature using STDIO library/header.           /
+/     - see individual justifications of the particular violations in the code                                             /
+/                                                                                                                          /
+/  * required rule 13.7 "boolean operations with invariant results"                                                        /
+/     - may violate because an operator in the operation resorts to a user-defined callback macro which may (but does not  /
+/       necessarily have to) return a result within a certain range that even at compile time is guaranteed to be constant /
+/                                                                                                                          /
+/  * required rule 14.1 "unreachable code"                                                                                 /
+/     - may violate where conditions that result from errors supposed never to occur are handled because in some cases     /
+/       the chances of those conditions to occur depend on user-defined callback macros which even at compile time are     /
+/       found to be zero                                                                                                   /
+/                                                                                                                          /
+/                                                                            (checked in PowerPC build 529)                /
+/                                                                                                                          /
+/------------------------------------------------------------------------------------------------------------------------ */
+
+
+#include "VX1000.h" /* PRQA S 0883*/ /* Actually not violating MISRA rule 19.15: this file is included only once into this module */
+
+#if defined(VX1000_TARGET_XC2000)
+#elif defined(VX1000_TARGET_POWERPC)
+#elif defined(VX1000_TARGET_SH2)
+#elif defined(VX1000_TARGET_TMS570)
+#elif defined(VX1000_TARGET_TRICORE)
+#elif defined(VX1000_TARGET_X850)
+#else /* !VX1000_TARGET_<target> */
+#define VX1000IF_CFG_NO_TARGET
+#endif /* !VX1000_TARGET_<target> */
+#if defined(VX1000IF_CFG_NO_TARGET)
+#error You must define the appropriate VX1000_TARGET_<target> in VX1000_cfg.h!
+#endif /* !VX1000IF_CFG_NO_TARGET */
+
+#if defined(VX1000_MAILBOX_PRINTF)
+#include <stdarg.h>
+#if !defined(VX1000_PRINTF_MINIMAL)
+#include <stdio.h> /* this violates MISRA rule 20.9, but the user is responsible to turn off printf in production code while the features still are very useful in debug code */
+#endif /* !VX1000_PRINTF_MINIMAL */
+#endif /* VX1000_MAILBOX_PRINTF */
+
+#define VX1000_APPDRIVER_BUILDNUMBER_C 596UL
+
+#if ((!defined(VX1000_APPDRIVER_BUILDNUMBER)) || (!defined(VX1000_APPDRIVER_BUILDNUMBER_C))) || (!defined(VX1000_APPDRIVER_BUILDNUMBER_H))
+#error AppDriver files are corrupted. Please fetch a new and consistent file set!
+#endif /* ! VX1000_APPDRIVER_BUILDNUMBERxxx */
+#if (((VX1000_APPDRIVER_BUILDNUMBER) != (VX1000_APPDRIVER_BUILDNUMBER_C)) || ((VX1000_APPDRIVER_BUILDNUMBER) != (VX1000_APPDRIVER_BUILDNUMBER_H)))
+#error Invalid mixture of incompatible AppDriver files. Please fetch a new and consistent file set!
+#endif /* VX1000_APPDRIVER_BUILDNUMBERxxx mismatch */
+
+
+#if defined(VX1000_DISABLE_INSTRUMENTATION)
+
+/* Some compilers (e.g. cosmic) fail creating completely empty object files. Allow the user to provide a workaround: */
+VX1000_EMPTYFILE_DUMMYDECL
+
+#else /* !VX1000_DISABLE_INSTRUMENTATION */
+
+
+/* include user-defined lines with optional section pragmas to force individual linkage of VX1000 code and/or data: */
+#define VX1000_BEGSECT_VXMODULE_C
+#include "VX1000_cfg.h"  /* PRQA S 0883*/ /* Willingly violating MISRA rule 19.15: this file is included multiple times because it contains multiple disjunct parts that each are filtered exactly once by preprocessor conditions */ /* PRQA S 5087*/ /* Willingly violating MISRA rule 19.1: this file is included multiple at exactly those lines where it is needed to expand to the desired lines. Inclusion/expansion of those lines at the top of this file would not make sense and lead to compile errors */
+#define VX1000_BEGSECT_VXMODULE_C_UNDO
+
+
+/* --- local prototypes --- */
+#if defined(VX1000_OLDA) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+static void VX1000_SUFFUN(vx1000_OldaInit)( void );
+#endif /* VX1000_OLDA & !VX1000_COMPILED_FOR_SLAVECORES */
+#if defined(VX1000_MAILBOX) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+static void VX1000_SUFFUN(vx1000_MailboxInit)(void);
+#endif /* VX1000_MAILBOX & !VX1000_COMPILED_FOR_SLAVECORES */
+#if defined(VX1000_RES_MGMT) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+static void VX1000_SUFFUN(vx1000_ResMgmtInit)( void );
+#endif /* VX1000_RES_MGMT & !VX1000_COMPILED_FOR_SLAVECORES */
+#if defined(VX1000_STIM)
+#if !defined(VX1000_COMPILED_FOR_SLAVECORES)
+static void VX1000_SUFFUN(vx1000_StimInit)( void );
+#endif /* !VX1000_COMPILED_FOR_SLAVECORES */
+#if defined(VX1000_STIM_BENCHMARK)
+#if !defined(VX1000_COMPILED_FOR_SLAVECORES)
+static void VX1000_SUFFUN(vx1000_StimBenchmarkInit)( void );
+#endif /* !VX1000_COMPILED_FOR_SLAVECORES */
+static void VX1000_SUFFUN(vx1000_StimBenchmarkStimEnd)( VX1000_UINT8 stim_event, VX1000_UINT8 timeout_flag );
+static void VX1000_SUFFUN(vx1000_StimBenchmarkStimCheck)( void );
+#endif /* VX1000_STIM_BENCHMARK */
+#endif /* VX1000_STIM */
+#if (defined(VX1000_OVERLAY) && (!defined(VX1000_COMPILED_FOR_SLAVECORES)))
+static void VX1000_SUFFUN(vx1000_OverlayInit)( void );
+#if defined(VX1000_MAILBOX_OVERLAY_CONTROL)
+static VX1000_UINT8 gVX1000_XCP_CalPage;
+static VX1000_UINT8 gVX1000_ECU_CalPage;
+#endif /* VX1000_MAILBOX_OVERLAY_CONTROL */
+static void VX1000_SUFFUN(vx1000_EmemHdrInit)( void );
+#if defined(VX1000_INIT_CAL_PAGE_INTERNAL)
+static void VX1000_SUFFUN(vx1000_OverlayHwInit)( void );
+#endif /* VX1000_INIT_CAL_PAGE_INTERNAL */
+#if (defined(VX1000_OVERLAY_TLB) || (defined(VX1000_OVERLAY_DESCR_IDX)) || (defined(VX1000_MPC56xCRAM_BASE_ADDR) || defined(VX1000_SH2_FCU_BASE_ADDR))) && (!defined(VX1000_OVERLAY_VX_CONFIGURABLE))
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_UINT32 size, VX1000_UINT32 target, VX1000_UINT32 source1, VX1000_UINT32 source2 );
+#endif /* (VX1000_OVERLAY_TLB | VX1000_OVERLAY_DESCR_IDX | VX1000_MPC56xCRAM_BASE_ADDR | VX1000_SH2_FCU_BASE_ADDR) & !VX1000_OVERLAY_VX_CONFIGURABLE */
+#if (defined(VX1000_MTDPP0) && defined(VX1000_MTDPP1)) && (defined(VX1000_MTDPP2) && defined(VX1000_MTDPP3))
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_UINT32 size, VX1000_UINT32 target, VX1000_UINT32 source1, VX1000_UINT32 source2 );
+#endif /* VX1000_MTDPP0 & VX1000_MTDPP1 & VX1000_MTDPP2 & VX1000_MTDPP3 */
+#endif /* VX1000_OVERLAY & !VX1000_COMPILED_FOR_SLAVECORES */
+#if (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_OVERLAY_CONTROL)) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+#if defined(VX1000_GET_CAL_PAGE_INTERNAL)
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_GetCalPage)( VX1000_UINT8 segment, VX1000_UINT8 mode );
+#endif /* VX1000_GET_CAL_PAGE_INTERNAL */
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_SetCalPage)( VX1000_UINT8 segment, VX1000_UINT8 page, VX1000_UINT8 mode, VX1000_UINT8 onStartup );
+#endif  /* VX1000_MAILBOX && VX1000_MAILBOX_OVERLAY_CONTROL && !VX1000_COMPILED_FOR_SLAVECORES */
+#if (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_OVERLAY_CONTROL)) && ((!defined(VX1000_COMPILED_FOR_SLAVECORES)) && (!defined(VX1000_OVERLAY_VX_CONFIGURABLE)))
+#if defined(VX1000_COPY_CAL_PAGE_INTERNAL)
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_CopyCalPage)( VX1000_UINT8 srcSeg, VX1000_UINT8 srcPage, VX1000_UINT8 dstSeg, VX1000_UINT8 dstPage );
+#endif /* VX1000_COPY_CAL_PAGE_INTERNAL */
+#endif  /* VX1000_MAILBOX && VX1000_MAILBOX_OVERLAY_CONTROL && !VX1000_COMPILED_FOR_SLAVECORES && !VX1000_OVERLAY_VX_CONFIGURABLE */
+#if (defined(VX1000_OVERLAY)) && (defined(VX1000_OVERLAY_VX_CONFIGURABLE)) && (defined(VX1000_OVLENBL_REGWRITE_VIA_MX)) && (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_OVERLAY_CONTROL))
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlayWriteEcuDescr)( void );
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlayReadEcuDescr)( void );
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_OvlWritEcuDescrMxHandler)(VX1000_UINT8 cmdMode, VX1000_UINT8 ovlIdx, VX1000_UINT32 ovccon );
+#endif /* VX1000_OVERLAY & VX1000_OVERLAY_VX_CONFIGURABLE & VX1000_OVLENBL_REGWRITE_VIA_MX & VX1000_MAILBOX & VX1000_MAILBOX_OVERLAY_CONTROL*/
+
+#if (defined(VX1000_MAILBOX) && (!defined(VX1000_COMPILED_FOR_SLAVECORES)))
+#if (defined(VX1000_MAILBOX_OVERLAY_CONTROL) || defined(VX1000_MAILBOX_FLASH))
+/* in current version, only accessed by one function, so made local to this function: static volatile VX1000_UINT32 gVX1000_MX_mta; */
+#endif /* VX1000_MAILBOX_OVERLAY_CONTROL || VX1000_MAILBOX_FLASH */
+#if defined(VX1000_MAILBOX_PRINTF)
+static void VX1000_SUFFUN(vx1000_MailboxPutchar)( VX1000_CHAR character );
+#endif /* VX1000_MAILBOX_PRINTF */
+#endif /* VX1000_MAILBOX & !VX1000_COMPILED_FOR_SLAVECORES */
+
+#if defined(VX1000_STIM)
+static VX1000_UINT32 VX1000_SUFFUN(vx1000_SetTimeoutUs)(VX1000_UINT32 t);
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_CheckTimeout)(VX1000_UINT32 timeout);
+#if defined(VX1000_STIM_FORCE_V1)
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassCheckCounters)(VX1000_UINT8 stim_event);
+#if defined(VX1000_STIM_BY_OLDA)
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassCheckBuffer)(VX1000_UINT8 stim_event);
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassCopyBuffer)(VX1000_UINT8 stim_event);
+#if defined(VX1000_BYPASS_ALL_CHANS_STIMD)
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassAreAllChansStimd)(void);
+#endif /* VX1000_BYPASS_ALL_CHANS_STIMD */
+#endif /* VX1000_STIM_BY_OLDA */
+#endif /* VX1000_STIM_FORCE_V1 */
+#if defined(VX1000_HOOK_BASED_BYPASSING)
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassHbbHookValid)(VX1000_UINT32 HookID);
+#endif /* VX1000_HOOK_BASED_BYPASSING */
+#endif /* VX1000_STIM */
+#if defined(VX1000_DETECTION) || defined(VX1000_TARGET_TRICORE)
+static void VX1000_SUFFUN(vx1000_DetectVxAsyncStart)(void);
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_DetectVxAsyncEnd)(void);
+#endif /* VX1000_DETECTION || VX1000_TARGET_TRICORE */
+
+#define VX1000_CALPAGE_RAM             1
+#define VX1000_CALPAGE_FLASH           0
+
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_InitAsyncStart                                                                                       */
+/* API name:      VX1000_INIT_ASYNC_START                                                                                     */
+/* Wrapper API:   VX1000If_InitAsyncStart                                                                                     */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:    This function must not be interrupted by any vx1000_* function.                                             */
+/* Termination:   May leave internal data in an inconsistent state.                                                           */
+/*                No problems on reactivation.                                                                                */
+/* Precondition1: The timer used by VX1000_CLOCK() must be up and running.                                                    */
+/* Description:   Initialises all global VX1000 data structures.                                                              */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+void VX1000_SUFFUN(vx1000_InitAsyncStart)(void)
+{
+#if defined(VX1000_TARGET_TRICORE) && (!defined(VX1000_SW_RSTOUT_AVAILABLE))
+  VX1000_UINT8 InitAsyncReStarted = 0; /* TriCore may retain memory content over resets. This flag allows to skip re-initialisation of the AppDriver after resets */
+#endif /* VX1000_TARGET_TRICORE && !VX1000_SW_RSTOUT_AVAILABLE*/
+
+#if !defined(VX1000_COMPILED_FOR_SLAVECORES)
+  /* optional todo: check HW reset state: if no hard reset, assume VX1000-data already/still being valid and skip initialisation ... */
+#if defined(VX1000_RUNNING_ON_MAINCORE)
+  if (VX1000_RUNNING_ON_MAINCORE()) /* always true on single-core MCU, otherwise needs compiler specific assembly */
+#endif /* VX1000_RUNNING_ON_MAINCORE */
+  {
+#if defined(VX1000_TARGET_TRICORE)
+    /* Tricore specific trace hardware initialisation: */
+
+#if !defined(VX1000_SW_RSTOUT_AVAILABLE)  /* TODO: this config switch shall be renamed because it actually specifies whether the RSTOUT communication between ECU and FW works or not */
+    /* Check if last Reset was a SW Reset */
+    VX1000_UINT32 scuRstatMasked;
+    if (VX1000_ECU_IS_AURIX()) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    {
+      scuRstatMasked = (VX1000_ADDR_TO_PTR2VU32(0xF0036050UL))[0] & 0x00000010UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+    else
+    {
+      scuRstatMasked = (VX1000_ADDR_TO_PTR2VU32(0xF0000550UL))[0] & 0xFFFFFFFEUL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+    if (scuRstatMasked == 0x00000010UL)
+    {
+      /* Check if the gVX1000 data structure is still valid */
+      if ((gVX1000.MagicId == (VX1000_STRUCT_MAGIC)) && (gVX1000.Version == (VX1000_STRUCT_VERSION)))
+      {
+        VX1000_UINT32 t, n;
+
+        /* Re-enable OLDA trace */
+        /* Disable OLDA write trap generation (derivative dependent) */
+        switch ((VX1000_MCREG_CBS_JTAGID) & (VX1000_JTAGID_PN_MASK)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        {
+          case VX1000_JTAGID_PN_TC172x:
+          case VX1000_JTAGID_PN_TC1798:
+            (VX1000_ADDR_TO_PTR2VU32(0xF8000520UL))[0] = 0x00000003UL; /* AudoMax trace control register OVRCON */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            break;
+          case VX1000_JTAGID_PN_TC1387:
+          case VX1000_JTAGID_PN_TC1767:
+          case VX1000_JTAGID_PN_TC178x:
+          case VX1000_JTAGID_PN_TC1797:
+            (VX1000_ADDR_TO_PTR2VU32(0xF8700804UL))[0] = 0x00000003UL; /* TriCore Memory Control Register register LMU_MEMCON */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            break;
+          case VX1000_JTAGID_PN_TC32x:
+          case VX1000_JTAGID_PN_TC33x:
+          case VX1000_JTAGID_PN_TC33xED:
+          case VX1000_JTAGID_PN_TC35x:
+          case VX1000_JTAGID_PN_TC36x:
+          case VX1000_JTAGID_PN_TC37x:
+          case VX1000_JTAGID_PN_TC37xED:
+          case VX1000_JTAGID_PN_TC38x:
+          case VX1000_JTAGID_PN_TC39x:
+            (VX1000_ADDR_TO_PTR2VU32((((VX1000_MCREG_CBS_JTAGID) & (0xF0000000UL)) == (0x10000000UL)) ? 0xF8708430UL : 0xF8700430UL))[0] |= 0x00000001UL; /* AurixPlus Bridge Control Register BRCON */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            break;
+          default:
+            (VX1000_ADDR_TO_PTR2VU32(0xF8700820UL))[0]  = 0x00000003UL; /* Aurix Memory Control Register LMU_MEMCON */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            break;
+        }
+
+        VX1000_SPECIAL_EVENT((VX1000_ECU_EVT_SW_RESET)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* macro expansion contains VX1000_ADDR_TO_PTR2XXX: cannot avoid violating MISRA rule 11.3 because in a few configurations a peripheral register at a fix HW address must be accessed via pointer to update the HW value */
+        gVX1000.ToolDetectState |= VX1000_TDS_APPRST;
+
+        /* Wait 10ms */
+        /* First create enough trace traffic to empty the tile buffer */
+        /* Give VX a chance to set the timestamp offset */
+        t = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        n = 0;
+        while (((VX1000_CLOCK()) - t) < ((VX1000_CLOCK_TICKS_PER_MS) * 10UL)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        {
+          for (n++; n < 0x1000UL; n++)  /* Generate max. 64K Trace data */
+          {
+            VX1000_TIMESTAMP() /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            VX1000_TIMESTAMP() /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            VX1000_TIMESTAMP() /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            VX1000_TIMESTAMP() /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            VX1000_TIMESTAMP() /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+        }
+        InitAsyncReStarted = 1;
+      }
+      else
+      {
+        VX1000_SPECIAL_EVENT((VX1000_ECU_EVT_SW_RESET_FAIL)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      }
+    }
+#endif /* !VX1000_SW_RSTOUT_AVAILABLE */
+#if !defined(VX1000_SW_RSTOUT_AVAILABLE)
+    if (0==InitAsyncReStarted)
+#endif /* !VX1000_SW_RSTOUT_AVAILABLE */
+#endif /* VX1000_TARGET_TRICORE */
+    {
+#if defined(VX1000_LFAST_BASEADDR)
+#if defined(VX1000_SIPI_BASEADDR)
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_SIPI_BASEADDR ) + 0x9CUL /*MCR  */))[0]  = 0x00000001UL; /* Soft-reset the SIPI module  */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* !VX1000_SIPI_BASEADDR */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x30UL /*TIER */))[0]  = 0x00000000UL; /* Disable any interrupt generation by LFAST based on Tx activities */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x34UL /*RIER */))[0]  = 0x00000000UL; /* Disable any interrupt generation by LFAST based on Rx activities */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x38UL /*RIIER*/))[0]  = 0x00000000UL; /* Disable any interrupt generation by LFAST based on master commands */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x00UL /*MCR  */))[0] |= 0x00000002UL; /* Soft-reset the LFAST module */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      VX1000_SIPI_CLK_TXN_TXP_RXN_RXP()                                                         /* Let the user perform the derivative dependent initialisation of the LFAST CLKOUT pin and the four LVDS data pins */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x14UL /*RCDCR*/))[0]  = 0x000F0000UL; /* Use maximum cycles for each clock change */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x18UL /*SLCR */))[0]  = 0x12015F02UL; /* Use moderate cycles for each power mode change */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x00UL /*MCR  */))[0] &=~0x00008000UL; /* Disable LFAST and switch to slow speed to allow changing the high speed frequency */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x3CUL /*PLLCR*/))[0] |= 0x00020000UL; /* Power off the VCO before changing settings */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if !defined(VX1000_LFAST_FORCE_LOWSPEED)
+#if defined(VX1000_LFAST_REFCLOCK_IS_10MHZ)                                                     /* FSL explicitly discourages usage of 13 or 26 MHZ, so only 10 or 20 MHz are supported */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x3CUL /*PLLCR*/))[0]  = 0x00004000UL | ((32-(VX1000_LFAST_PLLMULOFS)) << 2); /* Multiply reference by 32 for fast clock */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else  /* !VX1000_LFAST_REFCLOCK_IS_10MHZ (--> 20MHz) */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x3CUL /*PLLCR*/))[0]  = 0x00004000UL | ((16-(VX1000_LFAST_PLLMULOFS)) << 2); /* Multiply reference by 16 for fast clock */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* !VX1000_LFAST_REFCLOCK_IS_10MHZ (--> 20MHz) */
+#if defined(VX1000_LFAST_HIGHSPEED_DIV_BY_2)                                                    /* Undocumented feature: on some STM derivatives the PLL/communication is said to support slow-down from standard 320MHz to 160MHz for less bit errors */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x3CUL /*PLLCR*/))[0] |= 0x00000001UL; /* Patch input divider */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#elif defined(VX1000_LFAST_HIGHSPEED_DIV_BY_4)                                                  /* Undocumented feature: on some STM derivatives the PLL/communication is said to support slow-down from standard 320MHz to 80MHz for even less bit errors */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x3CUL /*PLLCR*/))[0] |= 0x00000003UL; /* Patch input divider */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#elif defined(VX1000_LFAST_HIGHSPEED_DIV_BY_3)                                                  /* Undocumented and discouraged feature: if 80MHz works well but is too slow but 160MHz does not work, these 106.667MHz MIGHT be a tradeoff but this odd value is not officially mentioned so try on your own risk */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x3CUL /*PLLCR*/))[0] |= 0x00000002UL; /* Patch input divider */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_LFAST_HIGHSPEED_DIV_BY_X */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x3CUL /*PLLCR*/))[0] |= 0x00010000UL; /* Power on the VCO with the new, consistent settings */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* !VX1000_LFAST_FORCE_LOWSPEED */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x40UL /*LCR  */))[0]  = 0x0000502CUL; /* Enable LVDS Tx output, pad reference, Rx termination, Rx bias */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x00UL /*MCR  */))[0] &=~0x80000000UL; /* Select slave mode (hint: dual mode is always active, so registers are writeable) */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x00UL /*MCR  */))[0] &=~0x00000008UL; /* Do not use CTS method */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x00UL /*MCR  */))[0] |= 0x00000001UL; /* Allow data transmission */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_LFAST_REFCLOCK_IS_10MHZ)
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x00UL /*MCR  */))[0] &=~0x00010000UL; /* Divide reference by 2 for slow clock */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else  /* !VX1000_LFAST_REFCLOCK_IS_10MHZ (--> 20MHz) */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x00UL /*MCR  */))[0] |= 0x00010000UL; /* Divide reference by 4 for slow clock */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* !VX1000_LFAST_REFCLOCK_IS_10MHZ (--> 20MHz) */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x00UL /*MCR  */))[0] |= 0x00008000UL; /* Re-enable LFAST */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x00UL /*MCR  */))[0] |= 0x00006000UL; /* Enable the receiver and the transmitter */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x20UL /*PICR */))[0] |= 0x00008000UL; /* Enable auto-ping */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x04UL /*SCR  */))[0] &=~0x00010000UL; /* Disable remote control of clock to allow writing the speed bits */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_LFAST_FORCE_LOWSPEED)
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x04UL /*SCR  */))[0] &=~0x00000101UL; /* Select slow clock for both Rx and Tx */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else  /* !VX1000_LFAST_FORCE_LOWSPEED */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x04UL /*SCR  */))[0] |= 0x00000101UL; /* Select fast clock for both Rx and Tx */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* !VX1000_LFAST_FORCE_LOWSPEED */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0x00UL /*MCR  */))[0] &=~0x00000010UL; /* Start handling SIPI messages */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_LFAST_BASEADDR) + 0xA0UL /*RIISR*/))[0]  = 0xFFFFFFFFUL; /* Clear any pending LFAST interrupt requests */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_SIPI_BASEADDR)
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_SIPI_BASEADDR ) + 0x9CUL /*MCR  */))[0] |= 0x00000002UL; /* Enable the SIPI module */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_SIPI_BASEADDR ) + 0x9CUL /*MCR  */))[0] |= 0x00000008UL; /* Enable SIPI target functionality */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_SIPI_BASEADDR ) + 0x9CUL /*MCR  */))[0] |= 0x00000004UL; /* Switch to INIT mode to allow changing the configuration bits */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_SIPI_BASEADDR ) + 0x40UL /*CCR2 */))[0] |= 0x00000020UL; /* Enable channel 2 */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_SIPI_BASEADDR ) + 0x9CUL /*MCR  */))[0] &=~0x00000004UL; /* Switch back to normal mode */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* !VX1000_SIPI_BASEADDR */
+#endif /* VX1000_LFAST_BASEADDR */
+
+      /* Initialise the gVX1000 data structure */
+      gVX1000.MagicId = 0UL;
+      gVX1000.EventTimestamp = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      /* note that gVX1000.EventNumber must NOT be touched here, to be sure no event is triggered */
+      gVX1000.Version = VX1000_STRUCT_VERSION; /* note: bits 8..31 are checked by old FW versions to be 0x000000 */
+      gVX1000.GetIdPtr = VX1000_ECUID_PTR; /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because this integer variable either contains a pointer to an actual object or an integral magic number for "invalid" */  /* PRQA S 0309 */ /* not violating MISRA rule 11.3 with respect to the type sizes: 32 bit are sufficient to hold either a 0:32 flat or a 10:16 paged pointer */
+      gVX1000.GetIdLen = VX1000_ECUID_LEN;
+      gVX1000.XcpMailboxPtr = VX1000_MAILBOX_PTR; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */ /* PRQA S 0309 */ /* not violating MISRA rule 11.3 with respect to the type sizes: 32 bit are sufficient to hold either a 0:32 flat or a 10:16 paged pointer */
+      gVX1000.StimCtrlPtr = VX1000_STIM_PTR; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */ /* PRQA S 0309 */ /* not violating MISRA rule 11.3 with respect to the type sizes: 32 bit are sufficient to hold either a 0:32 flat or a 10:16 paged pointer */
+      gVX1000.RamSynchField = 0UL;
+      gVX1000.ToolDetectState = 0UL;
+      gVX1000.OldaPtr = VX1000_OLDA_PTR; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */ /* PRQA S 0309 */ /* not violating MISRA rule 11.3 with respect to the type sizes: 32 bit are sufficient to hold either a 0:32 flat or a 10:16 paged pointer */
+      gVX1000.OvlPtr = VX1000_OVL_PTR; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */ /* PRQA S 0309 */ /* not violating MISRA rule 11.3 with respect to the type sizes: 32 bit are sufficient to hold either a 0:32 flat or a 10:16 paged pointer */
+      gVX1000.ResMgmtPtr = VX1000_RES_MGMT_PTR; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */ /* PRQA S 0309 */ /* not violating MISRA rule 11.3 with respect to the type sizes: 32 bit are sufficient to hold either a 0:32 flat or a 10:16 paged pointer */
+#if defined(VX1000_TARGET_TRICORE)
+      gVX1000.OldaEventNumber = 0xF00004A0UL; /* on TriCore, we support ONLY the TrigReg methods (via VX1000_MCREG_OCDS_TRIGS), not the RAM method */
+#elif defined(VX1000_OLDA_AUDMBR_REG_ADDR)
+      gVX1000.OldaEventNumber = VX1000_OLDA_AUDMBR_REG_ADDR; /* on SHx, we support conditionally the TrigReg method (via AUD_MBR) */
+#elif defined(VX1000_OLDA_DTS_BASE_ADDR)
+      gVX1000.OldaEventNumber = VX1000_OLDA_DTS_BASE_ADDR;
+#else  /* !VX1000_TARGET_TRICORE & !VX1000_OLDA_AUDMBR_REG_ADDR & !VX1000_OLDA_DTS_BASE_ADDR */
+      gVX1000.OldaEventNumber = 0UL;
+#endif /* !VX1000_TARGET_TRICORE & !VX1000_OLDA_AUDMBR_REG_ADDR & !VX1000_OLDA_DTS_BASE_ADDR */
+      gVX1000.CalPtr = 0xFFFFFFFFUL ^ gVX1000.OldaEventNumber; /* note: unused CalPtr abused for OLDA in v3.x */
+      gVX1000.ToolCtrlState = 0UL;
+      gVX1000.FileVersion = 0x79A7U; /* not used anymore starting with release 3.0, but still evaluated by old FW versions */
+      gVX1000.ErrLogAddr = VX1000_ERRLOG_ADDR; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      gVX1000.ErrLogSize = VX1000_ERRLOG_SIZE;
+      gVX1000.ErrLogIndex = 0;
+#if VX1000_ERRLOG_SIZE != 0   /* signal that the ring buffer index has not wrapped, yet: */
+      (VX1000_ADDR_TO_PTR2U16(VX1000_ERRLOG_ADDR)  )[(VX1000_ERRLOG_SIZE) - 1] = 0U; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_ERRLOG_SIZE */
+      /* "slow clock support dropped to be able to support GHz clocks ..."
+      /if ((VX1000_CLOCK_TICKS_PER_US) > 4294967UL)
+      /{
+      /  VX1000_ERRLOGGER(VX1000_ERRLOG_TM_RESO_TOO_HIGH)
+      /  gVX1000.TimerFreqHz = 0; // resolution cannot be expressed in 32 bits
+      /}
+      /else
+      */
+      {
+        gVX1000.TimerFreqkHz = VX1000_CLOCK_TICKS_PER_MS;
+      }
+      gVX1000.TimerAddr = VX1000_CLOCK_TIMER_ADDR; /* zero is interpreted as "not accessible" */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      gVX1000.TimerAddrRegion = (VX1000_CLOCK_TIMER_ADDRREGION) | ((VX1000_CLOCK_TIMER_REVERSE) << 6); /* the VX FW currently ignores this an uses always 0="memory-mapped hardware register in standard region" */
+      gVX1000.TimerSize = VX1000_CLOCK_TIMER_SIZE; /* zero is interpreted as "not accessible" */
+      gVX1000.TimerOffset = 0; /* the VX FW currently supports only 0="the LSB of the 32bit-value at TimerAddr is also the LSB of the actual count" */
+      gVX1000.TimerDirection = 0;/* the VX FW currently supports only up-counting timers */
+      gVX1000.StimDurArrayPtr = VX1000_STIM_DURARRAY_PTR;  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      gVX1000.OldaDurArrayPtr = VX1000_OLDA_DURARRAY_PTR;  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      gVX1000.FeatureFlags0 = 0UL
+#if defined(VX1000_FKL_SUPPORT_ADDR)
+                            | (VX1000_ECUFEAT_FKLINSTRUMENTED)
+#endif /* VX1000_FKL_SUPPORT_ADDR */
+#if defined(VX1000_STIM) && defined(VX1000_STIMWAIT_BENCHMARK)
+                            | (VX1000_ECUFEAT_STIMWT_DURATION)
+#endif /* VX1000_STIM && VX1000_STIMWAIT_BENCHMARK */
+#if defined(VX1000_STIM) && defined(VX1000_STIM_BENCHMARK)
+                            | (VX1000_ECUFEAT_STIMRT_DURATION)
+#endif /* VX1000_STIM && VX1000_STIM_BENCHMARK */
+#if (defined(VX1000_STIM) && defined(VX1000_STIM_BENCHMARK)) && defined(VX1000_STIM_HISTOGRAM)
+                            | (VX1000_ECUFEAT_STIMRT_HISTOGR)
+#endif /* VX1000_STIM && VX1000_STIM_BENCHMARK && VX1000_STIM_HISTOGRAM*/
+#if defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_OVERLAY_CONTROL)
+                            | (VX1000_ECUFEAT_MX_CALPAGE_GSC)
+#endif /* VX1000_MAILBOX && VX1000_MAILBOX_OVERLAY_CONTROL */
+#if defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_CAL_READ_WRITE)
+                            | (VX1000_ECUFEAT_MX_CALPAGE_RW)
+#endif /* VX1000_MAILBOX && VX1000_MAILBOX_CAL_READ_WRITE */
+#if defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_FLASH)
+                            | (VX1000_ECUFEAT_MX_FLASHSTART)
+#endif /* VX1000_MAILBOX && VX1000_MAILBOX_FLASH */
+#if defined(VX1000_ADDONS_FEATUREFLAGS0)
+                            | VX1000_ADDONS_FEATUREFLAGS0
+#endif /* VX1000_ADDONS_FEATUREFLAGS0 */
+                            ;
+      if((((0
+      || ( (sizeof(VX1000_CHAR     )) != 1))
+      || (((sizeof(VX1000_INT8     )) != 1 )
+      || ( (sizeof(VX1000_INT16    )) != 2)))
+      ||((((sizeof(VX1000_INT32    )) != 4 )
+      || ( (sizeof(VX1000_UINT8    )) != 1))
+      || (((sizeof(VX1000_UINT16   )) != 2 )
+      || ( (sizeof(VX1000_UINT32   )) != 4))))
+      ||((((sizeof(VX1000_VUFUNCP_T)) != 4 )
+      || ( (sizeof(VX1000_VVFUNCP_T)) != 4))
+#if defined(VX1000_UINT64)
+      || (((sizeof(VX1000_UINT64   )) != 8))
+#endif /* VX1000_UINT64 */
+      ))
+      {
+        gVX1000.ToolDetectState |= VX1000_TDS_ERROR;
+        VX1000_ERRLOGGER(VX1000_ERRLOG_TYPESIZE_INVAL)
+      }
+      if ( (VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.ResMgmtPtr)) != (0x40UL + VX1000_PTR2VVX_TO_ADDRESS(&gVX1000)) ) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      {
+        gVX1000.ToolDetectState |= VX1000_TDS_ERROR;
+        VX1000_ERRLOGGER(VX1000_ERRLOG_STRUCTS_PADDED)
+      }
+      gVX1000.StaticLutAddr = 0;
+      gVX1000.DynamicAddressSignalsCnt = 0;
+      gVX1000.DynamicLutAddr = 0;
+      gVX1000.MemsyncLutAddr = 0;
+#if defined(VX1000_OLDA)
+      VX1000_SUFFUN(vx1000_OldaInit)();
+#endif /* VX1000_OLDA */
+#if defined(VX1000_MAILBOX) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+      VX1000_SUFFUN(vx1000_MailboxInit)();
+#endif /* VX1000_MAILBOX & !VX1000_COMPILED_FOR_SLAVECORES */
+#if defined(VX1000_OVERLAY)
+      VX1000_SUFFUN(vx1000_OverlayInit)();
+#endif /* VX1000_OVERLAY */
+#if defined(VX1000_RES_MGMT)
+      VX1000_SUFFUN(vx1000_ResMgmtInit)();
+#endif /* VX1000_RES_MGMT */
+#if defined(VX1000_ADDONS_INIT)
+      VX1000_ADDONS_INIT();
+#endif /* VX1000_ADDONS_INIT */
+#if defined(VX1000_STIM)
+      VX1000_SUFFUN(vx1000_StimInit)();
+#if defined(VX1000_STIM_BENCHMARK)
+      VX1000_SUFFUN(vx1000_StimBenchmarkInit)();
+#endif /* VX1000_STIM_BENCHMARK */
+      gVX1000.Stim.TimeoutCtr = 0;
+      gVX1000.Stim.TimeoutCtr2 = 0;
+#endif /* VX1000_STIM */
+      if ((VX1000_IS_BYPASS_RESUME_ALLOWED()) == 0) /* PRQA S 3325 */ /* cannot avoid violating MISRA rule 14.1 because of dependency on user-defined callback not guaranteed to be evaluable at compile time */
+      { /* PRQA S 3201 */ /* cannot avoid violating MISRA rule 14.1 because of dependency on user-defined callback not guaranteed to be evaluable at compile time */
+        gVX1000.ToolDetectState |= (VX1000_UINT32)(VX1000_TDS_NO_BYP_RESUME);
+      }
+      gVX1000.MemSyncTrigPtr = VX1000_MEMSYNC_TRIGGER_PTR; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      gVX1000.Padding32      = 0UL;
+      gVX1000.MemSyncCpyPtr  = VX1000_MEMSYNC_COPY_PTR; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      {
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0 )
+        VX1000_UINT32 i;
+#if ((VX1000_MEMSYNC_COPY_COUNT) > 0 )
+        volatile VX1000_MEMSYNC_CPY_T *p2 = VX1000_ADDR_TO_PTR2VMC(gVX1000.MemSyncCpyPtr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_MEMSYNC_COPY_COUNT */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 1 )
+        volatile VX1000_UINT32 *p = VX1000_ADDR_TO_PTR2VU32(gVX1000.MemSyncTrigPtr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 1)
+        p[0] = (VX1000_UINT32)(VX1000_MEMSYNC_TRIGGER_PTR0);
+        p[1] = (VX1000_UINT32)(VX1000_MEMSYNC_TRIGGER_PTR1);
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 2)
+        p[2] = (VX1000_UINT32)(VX1000_MEMSYNC_TRIGGER_PTR2);
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 2 */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 3)
+        p[3] = (VX1000_UINT32)(VX1000_MEMSYNC_TRIGGER_PTR3);
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 3 */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 4)
+        p[4] = (VX1000_UINT32)(VX1000_MEMSYNC_TRIGGER_PTR4);
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 4 */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 5)
+        p[5] = (VX1000_UINT32)(VX1000_MEMSYNC_TRIGGER_PTR5);
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 5 */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 6)
+        p[6] = (VX1000_UINT32)(VX1000_MEMSYNC_TRIGGER_PTR6);
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 6 */
+#if (VX1000_MEMSYNC_TRIGGER_COUNT > 7)
+        p[7] = (VX1000_UINT32)(VX1000_MEMSYNC_TRIGGER_PTR7);
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 7 */
+        for (i = 0; i < (VX1000_MEMSYNC_TRIGGER_COUNT); ++i)
+        {
+#if (VX1000_MEMSYNC_TRIGGER_COUNT == 1)
+          volatile VX1000_MEMSYNC_TRIG_T *pMSTstruct = VX1000_ADDR_TO_PTR2VMT(gVX1000.MemSyncTrigPtr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else  /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+          volatile VX1000_MEMSYNC_TRIG_T *pMSTstruct = VX1000_ADDR_TO_PTR2VMT(p[i]); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+          pMSTstruct[0].Reserved1 = 0U;
+          pMSTstruct[0].Reserved0 = 0;
+          pMSTstruct[0].StructVersion = 0;
+          pMSTstruct[0].MagicId = (VX1000_UINT32)(VX1000_STRUCT_MAGIC_MEMSYNCTRIG);
+        }
+#if ((VX1000_MEMSYNC_COPY_COUNT) > 0 )
+        for (i = 0; i < (VX1000_MEMSYNC_COPY_COUNT); ++i)
+        {
+          p2[i].SyncChunkSize = 0UL;
+          p2[i].SyncWinSize = 0UL;
+          p2[i].SyncWinStart = 0UL;
+          p2[i].SyncTriggerId = 0;
+          p2[i].SyncMasterId = 0;
+          p2[i].SyncWinStatus = 0;
+          p2[i].StructVersion = 0;
+          p2[i].MagicId = (VX1000_UINT32)(VX1000_STRUCT_MAGIC_MEMSYNCCPY);
+        }
+#endif /* VX1000_MEMSYNC_COPY_COUNT */
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+      }
+
+      gVX1000.Padding8        = 0;
+      gVX1000.MemSyncTrigCnt  = (VX1000_UINT8)(VX1000_MEMSYNC_TRIGGER_COUNT);
+      gVX1000.Padding16       = 0;
+      gVX1000.MemSyncCpyCnt   = (VX1000_UINT8)(VX1000_MEMSYNC_COPY_COUNT);
+      gVX1000.ReleaseNameHead = VX1000_RELEASECODEH(VX1000_RELEASENAMEARRAY);
+      gVX1000.ReleaseNameBody = VX1000_RELEASECODEB(VX1000_RELEASENAMEARRAY);
+      gVX1000.ReleaseNameTail = VX1000_RELEASECODET(VX1000_RELEASENAMEARRAY);
+      gVX1000.BuildNumber = (VX1000_APPDRIVER_BUILDNUMBER) | (((VX1000_UINT32)(VX1000_APPDRIVER_CONFIGVERSION)) << 24);
+
+#if defined(VX1000_TARGET_TRICORE)
+      /* TriCore: Lock DAP in 2 PIN mode to improve tool communication during coldstart */
+      if (VX1000_ECU_IS_AURIX()) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      {
+        /* Register is ENDINIT protected! */
+        /* ?! VX1000_MCREG_OCDS_OIFM =  0x00000000UL; ?! */ /* Two-pin DAP (legacy) */
+        ; /* Semicolon here for MISRA */
+      }
+      else
+      {
+        /* This is only possible in 2 PIN mode with the VX1542 FPGA POD */
+        VX1000_MCREG_OCDS_OCNTRL = 0x00000007UL;  /* DJMODE = 01 Two-pin DAP with disabled BYPASS */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      }
+#endif /* VX1000_TARGET_TRICORE */
+      gVX1000.ToolDetectState |= (VX1000_UINT32)(VX1000_TDS_INIT);
+#if defined(VX1000_SFR_ADDR_FOR_MAGIG_ID)
+      gVX1000.MagicIdSfrAddr = (VX1000_UINT32)(VX1000_SFR_ADDR_FOR_MAGIG_ID);
+      ((VX1000_ADDR_TO_PTR2VU32(gVX1000.MagicIdSfrAddr)))[0] = (VX1000_UINT32)(VX1000_STRUCT_MAGIC); /* standard pointers of the used memory model not necessarily reach the SFRs, so instead of simple "VX1000_ADDR_TO_PTR2VU32" a more complex cast like "((volatile VX1000_UINT32 VX1000_DECL_PTR *)" MIGHT be required */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else  /* !VX1000_SFR_ADDR_FOR_MAGIG_ID */
+      gVX1000.MagicIdSfrAddr = 0xFFFFFFFFUL;
+#endif /* !VX1000_SFR_ADDR_FOR_MAGIG_ID */
+      gVX1000.MagicId = (VX1000_UINT32)(VX1000_STRUCT_MAGIC);
+#if defined(VX1000_DETECTION) || defined(VX1000_TARGET_TRICORE)
+      VX1000_SUFFUN(vx1000_DetectVxAsyncStart)();
+#endif /* VX1000_DETECTION || VX1000_TARGET_TRICORE */
+      VX1000_SPECIAL_EVENT(VX1000_EVENT_STRUCT_INIT) /* PRQA S 0303 */ /* cannot avoid violating MISRA rule 11.3 because in a few configurations a peripheral register at a fix HW address must be accessed via pointer to update the HW value */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */ /* PRQA S 0501 */ /* Violation of MISRA rule 12.8 because 64-bit data types are known to be not MISRA-conformant. This is just an example to be overruled by a user-defined implementation of an atomic 64-bit-store operation. */
+    }
+  }
+#if defined(VX1000_RUNNING_ON_MAINCORE)
+  else
+#endif /* VX1000_RUNNING_ON_MAINCORE */
+#endif /* !VX1000_COMPILED_FOR_SLAVECORES */
+#if defined(VX1000_RUNNING_ON_MAINCORE) || defined(VX1000_COMPILED_FOR_SLAVECORES)
+  {
+    while (gVX1000.MagicId != (VX1000_UINT32)VX1000_STRUCT_MAGIC)
+    {
+      ; /* busy wait until another core initialised VX1000_DATA */
+    }
+  }
+#endif /* VX1000_RUNNING_ON_MAINCORE | VX1000_COMPILED_FOR_SLAVECORES */
+
+  /* optional: VX1000_BreakpointInit(); /-* has to be performed per core */
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_InitAsyncEnd                                                                                         */
+/* API name:      VX1000_INIT_ASYNC_END                                                                                       */
+/* Wrapper API:   VX1000If_InitAsyncEnd                                                                                       */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:    This function must not be interrupted by any vx1000_* function.                                             */
+/* Termination:   May leave internal data in an inconsistent state.                                                           */
+/*                No problems on reactivation.                                                                                */
+/* Precondition1: vx1000_InitAsyncStart must have been called.                                                                */
+/* Description:   Waits for end of start-up handshake with VX; Synchronises instrumentation on the cores.                     */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+void VX1000_SUFFUN(vx1000_InitAsyncEnd)(void)
+{
+#if defined(VX1000_RUNNING_ON_MAINCORE) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+  if (0==VX1000_RUNNING_ON_MAINCORE())
+#endif /* VX1000_RUNNING_ON_MAINCORE & !VX1000_COMPILED_FOR_SLAVECORES */
+#if defined(VX1000_RUNNING_ON_MAINCORE) || defined(VX1000_COMPILED_FOR_SLAVECORES)
+  {
+    if ((gVX1000.ToolDetectState & (VX1000_UINT32)((VX1000_TDS_COLDSTART_DELAY_REQ) | (VX1000_TDS_COLDSTART_DELAY))) != 0)
+    {
+      while (0 == (gVX1000.ToolDetectState & (VX1000_UINT32) ((VX1000_TDS_COLDSTART_DONE) | (VX1000_TDS_COLDSTART_TIMEOUT))))
+      {
+        ; /* busy wait for the main core to complete the handshake */
+      }
+    }
+#if defined(VX1000_OVLENBL_HW_INIT_PER_CORE)
+#if defined(VX1000_OVERLAY) && (!defined(VX1000_OVERLAY_VX_CONFIGURABLE))
+#if defined(VX1000_INIT_CAL_PAGE_INTERNAL)
+    VX1000_SUFFUN(vx1000_OverlayHwInit)();
+#elif defined(VX1000_INIT_CAL_PAGE)
+    VX1000_INIT_CAL_PAGE()
+#endif /* VX1000_INIT_CAL_PAGE && !VX1000_INIT_CAL_PAGE_INTERNAL */
+#endif /* VX1000_OVERLAY && !VX1000_OVERLAY_VX_CONFIGURABLE */
+#endif /* VX1000_OVLENBL_HW_INIT_PER_CORE */
+  }
+#endif /* VX1000_RUNNING_ON_MAINCORE | VX1000_COMPILED_FOR_SLAVECORES */
+#if defined(VX1000_RUNNING_ON_MAINCORE) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+  else
+#endif /* VX1000_RUNNING_ON_MAINCORE & !VX1000_COMPILED_FOR_SLAVECORES */
+#if !defined(VX1000_COMPILED_FOR_SLAVECORES)
+#if defined(VX1000_DETECTION) || defined(VX1000_TARGET_TRICORE)
+  if (VX1000_SUFFUN(vx1000_DetectVxAsyncEnd)() != 0) /* complete the VX1000 handshake; "0" means "no VX detected" */
+  {
+    ; /* If tool detection was successful, no action. Semicolon here for MISRA */
+  }
+  else
+#endif /* VX1000_DETECTION || VX1000_TARGET_TRICORE */
+  {
+#if defined(VX1000_TARGET_TRICORE)
+    /* Lock DAP in the user selected pin mode */
+    if (VX1000_ECU_IS_AURIX()) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    {
+      /* Register is ENDINIT protected! */
+      /* ?! VX1000_MCREG_OCDS_OIFM = VX1000_OCDS_OIFM; ?! */
+      ; /* Semicolon here for MISRA */
+    }
+    else
+    {
+      VX1000_MCREG_OCDS_OCNTRL = VX1000_OCDS_OCNTRL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+#else  /* !VX1000_TARGET_TRICORE */
+    ; /* If tool detection was not successful, no action. Semicolon here for MISRA */
+#endif /* !VX1000_TARGET_TRICORE */
+  }
+#if defined(VX1000_RUNNING_ON_MAINCORE)
+  if (VX1000_RUNNING_ON_MAINCORE() != 0)
+#endif /* VX1000_RUNNING_ON_MAINCORE */
+  {
+#if defined(VX1000_OVERLAY) && (!defined(VX1000_OVERLAY_VX_CONFIGURABLE))
+#if defined(VX1000_INIT_CAL_PAGE_INTERNAL)
+    VX1000_SUFFUN(vx1000_OverlayHwInit)();
+#elif defined(VX1000_INIT_CAL_PAGE)
+    VX1000_INIT_CAL_PAGE()
+#endif /* VX1000_INIT_CAL_PAGE && !VX1000_INIT_CAL_PAGE_INTERNAL */
+#endif /* VX1000_OVERLAY && !VX1000_OVERLAY_VX_CONFIGURABLE */
+  }
+#endif /* !VX1000_COMPILED_FOR_SLAVECORES */
+}
+
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_Init                                                                                                 */
+/* API name:      VX1000_INIT                                                                                                 */
+/* Wrapper API:   VX1000If_Init                                                                                               */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:    This function must not be interrupted by any vx1000_* function.                                             */
+/* Termination:   May leave internal data in an inconsistent state.                                                           */
+/*                No problems on reactivation.                                                                                */
+/* Precondition1: The timer used by VX1000_CLOCK() must be up and running.                                                    */
+/* Description:   Initialises all global VX1000 data structures and performs the VX startup handshaking.                      */
+/* Devel state:   Deprecated (replaced by vx1000_InitAsyncStart)                                                              */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Should not be used in new designs */
+/* Only for compatibility in existing projects */
+void VX1000_SUFFUN(vx1000_Init)(void)
+{
+  VX1000_INIT_ASYNC_START()
+  VX1000_INIT_ASYNC_END()
+}
+
+
+/*------------------------------------------------------------------------------- */
+/* Pre-restart handshake                                                          */
+#if defined(VX1000_SOFTRESET_TIMEOUT_MS)
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_PrepareSoftreset                                                                                     */
+/* API name:      VX1000_PREPARE_SOFTRESET (expression) / VX1000_PREPARE_SOFTRESET_VOID (statement)                           */
+/* Wrapper API:   VX1000If_PrepareSoftreset (expression) / VX1000If_PrepareSoftresetVoid (statement)                          */
+/* Return value:  0: reset procedure confirmed by tool / 1: handshake failed (measurement won\'t be resumed after the reset)   */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_InitAsyncEnd() must have been called.                                                                */
+/* Description:   Informs the VX1000 base module about a planned software reset.                                              */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_PrepareSoftreset)(void)
+{
+  VX1000_UINT32 t0, dt;
+  VX1000_UINT8 retVal = 0; /* 0="accepted", 1="initiated", 2="acknowledged", 3="handled", 4="confirmed", {5,6}="timeout" */
+
+  if ((gVX1000.ToolCtrlState & (VX1000_TCS_PRESENT)) != 0)  /* Handshake is only needed when a VX is connected */
+  {
+    gVX1000.EventTimestamp = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    t0 = gVX1000.EventTimestamp;
+    dt = (VX1000_SOFTRESET_TIMEOUT_MS) * (VX1000_CLOCK_TICKS_PER_MS);
+#if (VX1000_CLOCK_TIMER_SIZE < 32) && (VX1000_CLOCK_TIMER_SIZE != 0)
+    if ( dt > ((1UL << (VX1000_CLOCK_TIMER_SIZE)) - 1) )
+    {
+      dt = (1UL << (VX1000_CLOCK_TIMER_SIZE)) - 1;
+      VX1000_ERRLOGGER(VX1000_ERRLOG_TM_DTSR_TOO_LONG)
+    }
+#endif /* VX1000_CLOCK_TIMER_SIZE */
+
+    /* trigger a special event */
+    VX1000_SPECIAL_EVENT(VX1000_ECU_EVT_SW_RESET_PREP) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */ /* PRQA S 0501 */ /* Violation of MISRA rule 12.8 because 64-bit data types are known to be not MISRA-conformant. This is just an example to be overruled by a user-defined implementation of an atomic 64-bit-store operation. */
+    retVal = 1;
+
+    /* wait with timeout until the VX1000 acknowledges the special event by setting VX1000_TCS_SOFTRESET_PREP */
+    while (retVal == 1)
+    {
+      if ((gVX1000.ToolCtrlState & (VX1000_UINT32)(VX1000_TCS_SOFTRESET_PREP)) != 0)
+      {
+        /* retVal = 2; */
+        gVX1000.MagicId = 0;   /* destroy the MagicId */
+        retVal = 3;
+
+        /* wait with timeout until the VX1000 also confirmed that it saw the destroyed MagicId by resetting VX1000_TCS_SOFTRESET_PREP */
+        while (retVal == 3)
+        {
+          if (0==(gVX1000.ToolCtrlState & (VX1000_UINT32)(VX1000_TCS_SOFTRESET_PREP)))
+          {
+            retVal = 4;
+          }
+          else if ((gVX1000.EventTimestamp - t0) >= dt)
+          {
+            retVal = 5; /* means "timeout" */
+          }
+          else
+          {
+            ; /* empty else is only here for MISRA */
+          }
+          gVX1000.EventTimestamp = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        } /* while() */
+      }
+      else if ((gVX1000.EventTimestamp - t0) >= dt)
+      {
+        retVal = 6; /* means "timeout" or "rejected" */
+      }
+      else
+      {
+        ; /* empty else is only here for MISRA */
+      }
+      gVX1000.EventTimestamp = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    } /* while() */
+    if (retVal == 4) /* reduce the return values to a simplified, boolean meaning */
+    {
+      retVal = 0;
+    }
+    else
+    {
+      retVal = 1;
+    }
+  }
+  return retVal;
+}
+#endif /* VX1000_SOFTRESET_TIMEOUT_MS */
+
+/*------------------------------------------------------------------------------- */
+/* Tool detection                                                                 */
+
+#if defined(VX1000_DETECTION) || defined(VX1000_TARGET_TRICORE) /* on TriCore, this function is always present because it is needed in DAP init decision */
+
+#if defined(VX1000_COLDSTART_CALIBRATION) /* obsolete feature */
+/*todo: add check for existence && NZ of the defines and then move everything into the consistency check section in the header*/
+#if (VX1000_OLDA_MEMORY_SIZE) < (((VX1000_COLDSTART_FLASH_SIZE) / (VX1000_COLDSTART_CHS_BLOCK_SIZE)) + 4) * 4
+#error "VX1000_MEMORY_SIZE too small for FLASH checksum array"
+#endif /* VX1000_OLDA_MEMORY_SIZE < ... */
+#if ((VX1000_COLDSTART_FLASH_SIZE) % (VX1000_COLDSTART_CHS_BLOCK_SIZE)) != 0
+#error "VX1000_COLDSTART_FLASH_SIZE % VX1000_COLDSTART_CHS_BLOCK_SIZE != 0"
+#endif /* VX1000_COLDSTART_FLASH_SIZE % VX1000_COLDSTART_CHS_BLOCK_SIZE */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_CalcFlashChecksum                                                                                    */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:    TODO visza                                                                                                  */
+/* Termination:   TODO visza                                                                                                  */
+/* Precondition1: TODO visza                                                                                                  */
+/* Description:   TODO visza                                                                                                  */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* todo: add the used global variables to the end of this module plus to the header plus add VX1000_COLDSTART_CHECKSUM_MAGIC */
+static void VX1000_SUFFUN(vx1000_CalcFlashChecksum)( void ); /* todo: move up to prototype section */
+static void VX1000_SUFFUN(vx1000_CalcFlashChecksum)( void )
+{
+  VX1000_UINT32 adr = (VX1000_UINT32)(VX1000_COLDSTART_FLASH_ADDR);
+  VX1000_UINT32 i, *p;
+
+  p = VX1000_ADDR_TO_PTR2U32(gVX1000.Olda.MemoryAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  p[0] = (VX1000_UINT32)(VX1000_COLDSTART_CHS_MAGIC);
+  p[1] = (VX1000_UINT32)(VX1000_COLDSTART_FLASH_ADDR);
+  p[2] = (VX1000_UINT32)(VX1000_COLDSTART_FLASH_SIZE);
+  p[3] = (VX1000_UINT32)(VX1000_COLDSTART_CHS_BLOCK_SIZE);
+
+  p = VX1000_ADDR_TO_PTR2U32(gVX1000.Olda.MemoryAddr + 4*4); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  for (i = 0; i < ((VX1000_COLDSTART_FLASH_SIZE) / (VX1000_COLDSTART_CHS_BLOCK_SIZE)); i++)
+  {
+    VX1000_UINT32 sum32 = 0;
+    VX1000_UINT32 k, *data = VX1000_ADDR_TO_PTR2U32(adr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    for (k = 0; k <= (VX1000_COLDSTART_CHS_BLOCK_SIZE); k += 4UL * 8UL)
+    {
+      sum32 += data[0] + data[1] + data[2] + data[3] + data[4] + data[5] + data[6] + data[7];
+      data = &data[8];
+    }
+    p[i] = sum32;
+    adr += VX1000_COLDSTART_CHS_BLOCK_SIZE;
+  }
+}
+#endif /* VX1000_COLDSTART_CALIBRATION */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_DetectVxAsyncStart                                                                                   */
+/* API name:      None (only used internally)                                                                                 */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: The timer used by VX1000_CLOCK() must be up and running.                                                    */
+/* Description:   Detect, whether a VX1000 is connected; if yes, initiate tool handshake.                                     */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static void VX1000_SUFFUN(vx1000_DetectVxAsyncStart)( void )
+{
+#if !defined(VX1000_COMPILED_FOR_SLAVECORES)
+#if defined(VX1000_TARGET_TRICORE)
+  VX1000_UINT32 tricoreToolCtrlState = 0UL; /* dummy initialisation to avoid compiler/MISRA warnings (value is always overwritten before usage) */
+  VX1000_DUMMYREAD(tricoreToolCtrlState)    /* dummy usage to avoid compiler/MISRA warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+#endif /* VX1000_TARGET_TRICORE */
+#if defined(VX1000_DETECT_XCP)
+  /* Check whether there is a XCP on CAN connected and disable VX OLDA in that case */
+  /* (Otherwise the probably-shared memory for the display tables would be overwritten by VX coldstart setup!)*/
+  if ((xcp.SessionStatus & (SS_CONNECTED)) != 0)
+  {
+    gVX1000.Olda.MagicId = 0; /* XCP connected: Disable OLDA */
+  }
+  else
+  {
+    gVX1000.Olda.MagicId = VX1000_OLDA_MAGIC; /* VX is alone: Re-enable OLDA */
+    /* todo: the VX will not start using olda now by itself -> we have to request this somehow */
+  }
+#endif /* VX1000_DETECT_XCP */
+
+  /* Check if 1st call after reset (&& on multi-core systems, whether we run on the main core) */
+  if ((0==(gVX1000.ToolDetectState & ((VX1000_UINT32)VX1000_TDS_DETECT))) /* PRQA S 3415*/ /* Actually not violating MISRA rule 12.4 because VX1000_RUNNING_ON_MAINCORE() by definition cannot have any desired side effect */
+#if defined(VX1000_RUNNING_ON_MAINCORE)
+  &&  (VX1000_RUNNING_ON_MAINCORE()) /* TODO: when not running on the main core, return gVX1000.ToolDetectState only if VX1000_DATA looks "already initialised"! */
+#endif /* VX1000_RUNNING_ON_MAINCORE */
+  )
+  {
+#if ((VX1000_CLOCK_TICKS_BASE_NS) < 100000UL) /* was: "#if ((VX1000_CLOCK_TICKS_PER_US) > 10)", but CLOCK_TICKS may be a function! */
+    VX1000_UINT32 dt = (VX1000_DETECTION_TIMEOUT_US) * (VX1000_CLOCK_TICKS_PER_US);
+#else /* VX1000_CLOCK_TICKS_BASE_NS */
+    VX1000_UINT32 dt = ((VX1000_DETECTION_TIMEOUT_US) * (VX1000_CLOCK_TICKS_PER_MS)) / 1000UL;
+#endif /* VX1000_CLOCK_TICKS_BASE_NS */
+#if (VX1000_CLOCK_TIMER_SIZE < 32) && (VX1000_CLOCK_TIMER_SIZE != 0)
+    if ( dt > ((1UL << (VX1000_CLOCK_TIMER_SIZE)) - 1) )
+    {
+      dt = (1UL << (VX1000_CLOCK_TIMER_SIZE)) - 1;
+      VX1000_ERRLOGGER(VX1000_ERRLOG_TM_DTDT_TOO_LONG)
+    }
+#endif /* VX1000_CLOCK_TIMER_SIZE */
+    gVX1000.EventTimestamp = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    gVX1000.ToolDetectState |= (VX1000_UINT32)VX1000_TDS_DETECT;
+    gVX1000_DETECT_StartTime = gVX1000.EventTimestamp;
+
+#if defined(VX1000_COLDSTART_BENCHMARK) && defined(VX1000_OLDA)
+    gVX1000_DETECT_StartTimeAsyncEnd = 0;
+    gVX1000_DETECT_ToolDetectTime = 0;
+    gVX1000_DETECT_ChecksumDoneTime = 0;
+    gVX1000_DETECT_EndTime = 0;
+    gVX1000_DETECT_EndTimeAsyncStart = 0;
+#endif /* VX1000_COLDSTART_BENCHMARK && VX1000_OLDA */
+
+    /* Wait some time for tool presence indication, when ECU was reset, the tool may need some time to react */
+    /* Check timeout VX1000_DETECTION_TIMEOUT_US */
+    do
+    {
+#if defined(VX1000_TARGET_TRICORE)
+      /* Thanks to TriCore\'s DAP interface, VX1000_DETECTION_TIMEOUT_US may be as small as 1 us */
+      /* (VX can access the TRIG register even if it can\'t access memory (gVX1000.ToolCtrlState/DetectState), yet) */
+      if (VX1000_ECU_IS_AURIX()) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      {
+        /* Phase I: Check tool presence (NIOS -> ECU: bitvector mode with Aurix indices; ECU -> NIOS: Aurix magic number mode) */
+        switch ((VX1000_MCREG_CBS_JTAGID) & (VX1000_JTAGID_PN_MASK)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        {
+          case VX1000_JTAGID_PN_TC21x:
+          case VX1000_JTAGID_PN_TC22x:
+          case VX1000_JTAGID_PN_TC23x:
+          case VX1000_JTAGID_PN_TC32x:
+          case VX1000_JTAGID_PN_TC33x:
+          case VX1000_JTAGID_PN_TC33xED:
+          case VX1000_JTAGID_PN_TC35x:
+          case VX1000_JTAGID_PN_TC36x:
+          case VX1000_JTAGID_PN_TC37x:
+          case VX1000_JTAGID_PN_TC37xED:
+          case VX1000_JTAGID_PN_TC38x:
+          case VX1000_JTAGID_PN_TC39x:
+            tricoreToolCtrlState = VX1000_MCREG_OCDS_TRIG5; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            break;
+          default:
+            tricoreToolCtrlState = VX1000_MCREG_OCDS_TRIG20; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            break;
+        }
+        /* Convert Aurix non-standard request bit indices to standard bit indices */
+        tricoreToolCtrlState = (((tricoreToolCtrlState) & 0x00000003UL) | ((tricoreToolCtrlState << 4U) & 0x00000040UL)) | ((tricoreToolCtrlState << 3U) & 0x00000080UL);
+      }
+      else
+      {
+        /* Phase I: Check tool presence (NIOS -> ECU: TriCore magic number mode; ECU -> NIOS: TriCore magic number mode) */
+        tricoreToolCtrlState = VX1000_MCREG_OCDS_TRIG; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        if ((tricoreToolCtrlState & 0x30636556UL) != 0x30636556UL) /* distinguish random VX1000_EVENT()s noise from requests with high reliability */
+        {
+          tricoreToolCtrlState = 0UL; /* the magic base pattern was not included, so clear all phantom requests */
+        }
+        /* Convert TriCore non-standard request bit indices to standard bit indices */
+        tricoreToolCtrlState = ((tricoreToolCtrlState >> 24U) & 0x00000003UL) | ((tricoreToolCtrlState >> 20U) & 0x000000C0UL);
+      }
+      if ((tricoreToolCtrlState & ((VX1000_TCS_PRESENT) | (VX1000_TCS_COLDSTART_DELAY))) != 0) /* Check tool presence */
+#else  /* !VX1000_TARGET_TRICORE */
+      /* The following delays were measured in the NIOS until VX1000_TCS_PRESENT was written to */
+      /* ToolCtrlState after a reset had been detected: */
+      /*  * PowerPC: 1.5 ms at 1 MHz Nexus Clock */
+      /*  * RH850:   todo */
+      /*  * SH2:     todo */
+      /*  * TMS570:  todo */
+      /*  * V850:    todo */
+      /*  * XC2000:  todo */
+      if ((gVX1000.ToolCtrlState & ((VX1000_TCS_PRESENT) | (VX1000_TCS_COLDSTART_DELAY))) != 0) /* Check tool presence */
+#endif /* !VX1000_TARGET_TRICORE */
+      {
+#if defined(VX1000_OVLENBL_KEEP_AWAKE)
+#if defined(VX1000_TARGET_TRICORE)
+        /* CBS_OSTATE.OJC[3..1]  0x001 for No_Powerfail, 0x011 for Powerfail */
+        if ((tricoreToolCtrlState & (VX1000_TCS_CAL_WAKEUP)) != 0)
+#else  /* !VX1000_TARGET_TRICORE */
+        if (VX1000_CAL_WAKEUP_REQUESTED())
+#endif /* !VX1000_TARGET_TRICORE */
+        {
+#if defined(VX1000_OVLENBL_RST_ON_CALWAKEUP)
+          VX1000_OVL_RST_ON_CAL_WAKEUP_CB()
+#endif /* VX1000_OVLENBL_RST_ON_CALWAKEUP */
+          /* Decrement the presenceCounter so that cal_wakeup_active returns 1 when called next time */
+          gVX1000.Ovl.ecuLastPresenceCounter--;
+        }
+#endif /* VX1000_OVLENBL_KEEP_AWAKE */
+
+        /* Acknowledge tool detect */
+        gVX1000.ToolDetectState |= (VX1000_UINT32)(VX1000_TDS_DETECTED);
+#if defined(VX1000_TARGET_TRICORE)
+        if (VX1000_ECU_IS_AURIX()) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        {
+          /* Also acknowledge tool detect in Aurix TRIGS register */
+          switch ((VX1000_MCREG_CBS_JTAGID) & (VX1000_JTAGID_PN_MASK)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          {
+            case VX1000_JTAGID_PN_TC21x:
+            case VX1000_JTAGID_PN_TC22x:
+            case VX1000_JTAGID_PN_TC23x:
+            case VX1000_JTAGID_PN_TC32x:
+            case VX1000_JTAGID_PN_TC33x:
+            case VX1000_JTAGID_PN_TC33xED:
+            case VX1000_JTAGID_PN_TC35x:
+            case VX1000_JTAGID_PN_TC36x:
+            case VX1000_JTAGID_PN_TC37x:
+            case VX1000_JTAGID_PN_TC37xED:
+            case VX1000_JTAGID_PN_TC38x:
+            case VX1000_JTAGID_PN_TC39x:
+              VX1000_MCREG_OCDS_TRIGS = ((10UL) + (VX1000_AURIX_TRIG_REG_OFS_V3)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+              break;
+            default:
+              VX1000_MCREG_OCDS_TRIGS = ((10UL) + (VX1000_AURIX_TRIG_REG_OFS)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+              break;
+          }
+        }
+        else
+        {
+          /* Also acknowledge tool detect in TriCore TRIG registers */
+          VX1000_MCREG_OCDS_TRIGC = 0xFFFFFFFFUL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          VX1000_MCREG_OCDS_TRIGS = 0x00005555UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+        if ((tricoreToolCtrlState & (VX1000_TCS_COLDSTART_DELAY)) != 0)
+#else  /* !VX1000_TARGET_TRICORE */
+        if ((gVX1000.ToolCtrlState & (VX1000_TCS_COLDSTART_DELAY)) != 0)
+#endif /* !VX1000_TARGET_TRICORE */
+        {
+          gVX1000.ToolDetectState |= (VX1000_UINT32)(VX1000_TDS_COLDSTART_DELAY_REQ);
+        }
+#if defined(VX1000_COLDSTART_BENCHMARK) && defined(VX1000_OLDA)
+        gVX1000_DETECT_ToolDetectTime = gVX1000.EventTimestamp;
+#endif /* VX1000_COLDSTART_BENCHMARK && VX1000_OLDA */
+
+        break; /* note: this "early-out"-break can be removed safely if constant runtime is preferred (or for MISRA) */
+      } /* Tool present */
+      gVX1000.EventTimestamp = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    } while ((gVX1000.EventTimestamp - gVX1000_DETECT_StartTime) < dt);
+    gVX1000.ToolDetectState |= (VX1000_UINT32)VX1000_TDS_DETECT_DONE;
+#if defined(VX1000_COLDSTART_BENCHMARK) && defined(VX1000_OLDA)
+    gVX1000_DETECT_EndTimeAsyncStart = VX1000_CLOCK();  /* here, gVX1000.EventTimestamp may be outdated (break\'s path) */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_COLDSTART_BENCHMARK && VX1000_OLDA */
+  } /* 1st call */
+  else /* warmstart connect for all targets handled by the FW in standard bitvector mode (not by nios magic numbers for TriCore) */
+  {
+    /* Just Check whether the VX is connected now and update the state accordingly */
+    if ((gVX1000.ToolCtrlState & ((VX1000_UINT32)(VX1000_TCS_PRESENT))) != 0)
+    {
+      gVX1000.ToolDetectState |= (VX1000_UINT32)(VX1000_TDS_DETECTED); /* VX1000 connected */
+    }
+    else
+    {
+      gVX1000.ToolDetectState &= (VX1000_UINT32)~(VX1000_TDS_DETECTED); /* not connected */
+    }
+  }
+#endif /* !VX1000_COMPILED_FOR_SLAVECORES */
+}
+
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_DetectVxAsyncEnd                                                                                     */
+/* API name:      None (only used internally)                                                                                 */
+/* Return value:  VX1000_TDS_DETECTED if detected; 0 otherwise.                                                               */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_DetectVxAsyncStart must have been called.                                                            */
+/* Description:   Update connection status and stall for remaining delay if required by tool (for downloading the             */
+/*                coldstart measurement setup).                                                                               */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_DetectVxAsyncEnd)( void )
+{
+#if defined(VX1000_RUNNING_ON_MAINCORE) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+  if (0==(VX1000_RUNNING_ON_MAINCORE()))
+#endif /* VX1000_RUNNING_ON_MAINCORE & !VX1000_COMPILED_FOR_SLAVECORES */
+#if defined(VX1000_RUNNING_ON_MAINCORE) || defined(VX1000_COMPILED_FOR_SLAVECORES)
+  {
+    if ((gVX1000.ToolDetectState & (VX1000_UINT32)((VX1000_TDS_COLDSTART_DELAY_REQ) | (VX1000_TDS_COLDSTART_DELAY))) != 0)
+    {
+      while (0 == (gVX1000.ToolDetectState & (VX1000_UINT32) ((VX1000_TDS_COLDSTART_DONE) | (VX1000_TDS_COLDSTART_TIMEOUT))))
+      {
+        ; /* busy wait for the main core to complete the handshake */
+      }
+    }
+  }
+#endif  /* VX1000_RUNNING_ON_MAINCORE | VX1000_COMPILED_FOR_SLAVECORES */
+#if defined(VX1000_RUNNING_ON_MAINCORE) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+  else
+#endif /* VX1000_RUNNING_ON_MAINCORE & !VX1000_COMPILED_FOR_SLAVECORES */
+#if !defined(VX1000_COMPILED_FOR_SLAVECORES)
+  if ((gVX1000.ToolDetectState & (VX1000_UINT32)(VX1000_TDS_COLDSTART_DELAY_REQ)) != 0)
+  {
+    VX1000_UINT32 dt = (VX1000_COLDSTART_TIMEOUT_MS) * (VX1000_CLOCK_TICKS_PER_MS);
+#if (VX1000_CLOCK_TIMER_SIZE < 32) && (VX1000_CLOCK_TIMER_SIZE != 0)
+    if ( dt > ((1UL << (VX1000_CLOCK_TIMER_SIZE)) - 1) )
+    {
+      dt = (1UL << (VX1000_CLOCK_TIMER_SIZE)) - 1;
+      VX1000_ERRLOGGER(VX1000_ERRLOG_TM_DTCS_TOO_LONG)
+    }
+#endif /* VX1000_CLOCK_TIMER_SIZE */
+    gVX1000.EventTimestamp = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+
+#if defined(VX1000_COLDSTART_BENCHMARK) && defined(VX1000_OLDA)
+    gVX1000_DETECT_StartTimeAsyncEnd = gVX1000.EventTimestamp;
+#endif /* VX1000_COLDSTART_BENCHMARK && VX1000_OLDA */
+
+    /* removed: gVX1000.ToolDetectState &= ~(VX1000_UINT32)VX1000_TDS_COLDSTART_DELAY_REQ; */
+    gVX1000.ToolDetectState |= (VX1000_UINT32)VX1000_TDS_COLDSTART_DELAY;
+
+    /* Calculate checksums over the calibration areas and store in Olda memory */
+    /* VX1000 may use this to optimize calibration download */
+#if defined(VX1000_COLDSTART_CALIBRATION)
+    gVX1000.ToolDetectState |= (VX1000_UINT32)VX1000_TDS_COLDSTART_CHS_BUSY;
+    VX1000_SUFFUN(vx1000_CalcFlashChecksum)();
+    gVX1000.ToolDetectState |= (VX1000_UINT32)VX1000_TDS_COLDSTART_CHS_DONE;
+#if defined(VX1000_COLDSTART_BENCHMARK) && defined(VX1000_OLDA)
+    gVX1000_DETECT_ChecksumDoneTime = VX1000_CLOCK();  /* here, gVX1000.EventTimestamp is outdated */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_COLDSTART_BENCHMARK && VX1000_OLDA */
+#endif /* VX1000_COLDSTART_CALIBRATION */
+
+    /* Phase III: Check/wait for tool requests (FW -> ECU: standard bitvector mode; ECU -> FW: standard bitvector mode) */
+    for (gVX1000.ToolDetectState &= (VX1000_UINT32)~((VX1000_TDS_COLDSTART_DONE) | (VX1000_TDS_COLDSTART_TIMEOUT));
+    0 == (gVX1000.ToolDetectState & (VX1000_UINT32) ((VX1000_TDS_COLDSTART_DONE) | (VX1000_TDS_COLDSTART_TIMEOUT)));)
+    {
+      if ((gVX1000.ToolCtrlState & ((VX1000_UINT32)(VX1000_TCS_COLDSTART_DONE))) != 0)
+      {
+        /* Init acknowledge */
+#if (defined(VX1000_OVERLAY)) && (defined(VX1000_OVERLAY_VX_CONFIGURABLE)) && (defined(VX1000_OVLENBL_REGWRITE_VIA_MX)) && (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_OVERLAY_CONTROL))
+        VX1000_SUFFUN(vx1000_OverlayWriteEcuDescr)();
+#endif /* VX1000_OVERLAY & VX1000_OVERLAY_VX_CONFIGURABLE & VX1000_OVLENBL_REGWRITE_VIA_MX & VX1000_MAILBOX & VX1000_MAILBOX_OVERLAY_CONTROL*/
+        if ((gVX1000.ToolCtrlState & ((VX1000_UINT32)(VX1000_TCS_SWITCH_TO_WP))) != 0)
+        {
+#if (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_OVERLAY_CONTROL))
+          if (VX1000_WRP_SET_CAL_PAGE(0, VX1000_CALPAGE_RAM, (VX1000_CAL_ECU) | (VX1000_CAL_XCP), 1) != 0)
+#endif /* VX1000_MAILBOX & VX1000_MAILBOX_OVERLAY_CONTROL */
+          {
+            gVX1000.ToolDetectState |= (VX1000_UINT32)(VX1000_TDS_ERROR);
+          }
+        }
+#if defined(VX1000_OVERLAY_DESCR_IDX) && defined(VX1000_TARGET_TRICORE)
+        else
+        {
+          (void)VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_OVERLAY_SIZE, VX1000_OVERLAY_ADDR, 1, VX1000_CALRAM_PHYSADDR);
+        }
+#endif /* VX1000_OVERLAY_DESCR_IDX && VX1000_TARGET_TRICORE */
+        gVX1000.ToolDetectState |= (VX1000_UINT32)(VX1000_TDS_COLDSTART_DONE);
+      }
+      else if ((gVX1000.EventTimestamp - gVX1000_DETECT_StartTime) >= dt)
+      {
+        /* Timeout acknowledge */
+        gVX1000.ToolDetectState |= (VX1000_UINT32)(VX1000_TDS_COLDSTART_TIMEOUT);
+      }
+      else
+      {
+        ; /* empty else only here for MISRA */
+      }
+      gVX1000.EventTimestamp = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    } /* for(;;) */
+
+#if defined(VX1000_COLDSTART_BENCHMARK) && defined(VX1000_OLDA)
+    gVX1000_DETECT_EndTime = VX1000_CLOCK();  /* here, gVX1000.EventTimestamp may be outdated (break\'s path) */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_COLDSTART_BENCHMARK && VX1000_OLDA */
+  }
+#if defined(VX1000_RUNNING_ON_MAINCORE)
+  else
+  {
+    ; /* this dummy else case is here only for MISRA */
+  }
+#endif /* VX1000_RUNNING_ON_MAINCORE */
+#endif /* !VX1000_COMPILED_FOR_SLAVECORES */
+
+  return (VX1000_UINT8)(gVX1000.ToolDetectState & (VX1000_UINT32)(VX1000_TDS_DETECTED));
+}
+#endif /* VX1000_DETECTION | VX1000_TARGET_TRICORE */
+
+
+
+/*------------------------------------------------------------------------------- */
+/* Breakpoint triggered actions                                                   */
+
+/* optional: breakpoint externals and implementation */
+
+
+
+#if defined(VX1000_OLDA)
+#if defined(VX1000_OLDA_FORCE_V8)
+#define VX1000_EVENTLIST_DAT400        /* empty */
+#define VX1000_TRSFRLIST_DAT400        /* empty */
+#if (((VX1000_OLDA_EVENT_COUNT) & 0x200) == 0x200)
+#define VX1000_EVENTLIST_DAT200        VX1000_EVENTLIST_DAT400 VX1000_EVENTLIST_INIT200((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x400))
+#define VX1000_TRSFRLIST_DAT200        VX1000_TRSFRLIST_DAT400 VX1000_TRSFRLIST_INIT200((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x400))
+#else  /* !(VX1000_OLDA_EVENT_COUNT & 0x200) */
+#define VX1000_EVENTLIST_DAT200        VX1000_EVENTLIST_DAT400
+#define VX1000_TRSFRLIST_DAT200        VX1000_TRSFRLIST_DAT400
+#endif /* !(VX1000_OLDA_EVENT_COUNT & 0x200) */
+#if (((VX1000_OLDA_EVENT_COUNT) & 0x100) == 0x100)
+#define VX1000_EVENTLIST_DAT100        VX1000_EVENTLIST_DAT200 VX1000_EVENTLIST_INIT100((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x200))
+#define VX1000_TRSFRLIST_DAT100        VX1000_TRSFRLIST_DAT200 VX1000_TRSFRLIST_INIT100((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x200))
+#else  /* !(VX1000_OLDA_EVENT_COUNT & 0x100) */
+#define VX1000_EVENTLIST_DAT100        VX1000_EVENTLIST_DAT200
+#define VX1000_TRSFRLIST_DAT100        VX1000_TRSFRLIST_DAT200
+#endif /* !(VX1000_OLDA_EVENT_COUNT & 0x100) */
+#if (((VX1000_OLDA_EVENT_COUNT) & 0x080) == 0x080)
+#define VX1000_EVENTLIST_DAT080        VX1000_EVENTLIST_DAT100 VX1000_EVENTLIST_INIT080((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x100))
+#define VX1000_TRSFRLIST_DAT080        VX1000_TRSFRLIST_DAT100 VX1000_TRSFRLIST_INIT080((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x100))
+#else  /* !(VX1000_OLDA_EVENT_COUNT & 0x080) */
+#define VX1000_EVENTLIST_DAT080        VX1000_EVENTLIST_DAT100
+#define VX1000_TRSFRLIST_DAT080        VX1000_TRSFRLIST_DAT100
+#endif /* !(VX1000_OLDA_EVENT_COUNT & 0x080) */
+#if (((VX1000_OLDA_EVENT_COUNT) & 0x040) == 0x040)
+#define VX1000_EVENTLIST_DAT040        VX1000_EVENTLIST_DAT080 VX1000_EVENTLIST_INIT040((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x080))
+#define VX1000_TRSFRLIST_DAT040        VX1000_TRSFRLIST_DAT080 VX1000_TRSFRLIST_INIT040((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x080))
+#else  /* !(VX1000_OLDA_EVENT_COUNT & 0x040) */
+#define VX1000_EVENTLIST_DAT040        VX1000_EVENTLIST_DAT080
+#define VX1000_TRSFRLIST_DAT040        VX1000_TRSFRLIST_DAT080
+#endif /* !(VX1000_OLDA_EVENT_COUNT & 0x040) */
+#if (((VX1000_OLDA_EVENT_COUNT) & 0x020) == 0x020)
+#define VX1000_EVENTLIST_DAT020        VX1000_EVENTLIST_DAT040 VX1000_EVENTLIST_INIT020((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x040))
+#define VX1000_TRSFRLIST_DAT020        VX1000_TRSFRLIST_DAT040 VX1000_TRSFRLIST_INIT020((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x040))
+#else  /* !(VX1000_OLDA_EVENT_COUNT & 0x020) */
+#define VX1000_EVENTLIST_DAT020        VX1000_EVENTLIST_DAT040
+#define VX1000_TRSFRLIST_DAT020        VX1000_TRSFRLIST_DAT040
+#endif /* !(VX1000_OLDA_EVENT_COUNT & 0x020) */
+#if (((VX1000_OLDA_EVENT_COUNT) & 0x010) == 0x010)
+#define VX1000_EVENTLIST_DAT010        VX1000_EVENTLIST_DAT020 VX1000_EVENTLIST_INIT010((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x020))
+#define VX1000_TRSFRLIST_DAT010        VX1000_TRSFRLIST_DAT020 VX1000_TRSFRLIST_INIT010((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x020))
+#else  /* !(VX1000_OLDA_EVENT_COUNT & 0x010) */
+#define VX1000_EVENTLIST_DAT010        VX1000_EVENTLIST_DAT020
+#define VX1000_TRSFRLIST_DAT010        VX1000_TRSFRLIST_DAT020
+#endif /* !(VX1000_OLDA_EVENT_COUNT & 0x010) */
+#if (((VX1000_OLDA_EVENT_COUNT) & 0x008) == 0x008)
+#define VX1000_EVENTLIST_DAT008        VX1000_EVENTLIST_DAT010 VX1000_EVENTLIST_INIT008((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x010))
+#define VX1000_TRSFRLIST_DAT008        VX1000_TRSFRLIST_DAT010 VX1000_TRSFRLIST_INIT008((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x010))
+#else  /* !(VX1000_OLDA_EVENT_COUNT & 0x008) */
+#define VX1000_EVENTLIST_DAT008        VX1000_EVENTLIST_DAT010
+#define VX1000_TRSFRLIST_DAT008        VX1000_TRSFRLIST_DAT010
+#endif /* !(VX1000_OLDA_EVENT_COUNT & 0x008) */
+#if (((VX1000_OLDA_EVENT_COUNT) & 0x004) == 0x004)
+#define VX1000_EVENTLIST_DAT004        VX1000_EVENTLIST_DAT008 VX1000_EVENTLIST_INIT004((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x008))
+#define VX1000_TRSFRLIST_DAT004        VX1000_TRSFRLIST_DAT008 VX1000_TRSFRLIST_INIT004((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x008))
+#else  /* !(VX1000_OLDA_EVENT_COUNT & 0x004) */
+#define VX1000_EVENTLIST_DAT004        VX1000_EVENTLIST_DAT008
+#define VX1000_TRSFRLIST_DAT004        VX1000_TRSFRLIST_DAT008
+#endif /* !(VX1000_OLDA_EVENT_COUNT & 0x004) */
+#if (((VX1000_OLDA_EVENT_COUNT) & 0x002) == 0x002)
+#define VX1000_EVENTLIST_DAT002        VX1000_EVENTLIST_DAT004 VX1000_EVENTLIST_INIT002((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x004))
+#define VX1000_TRSFRLIST_DAT002        VX1000_TRSFRLIST_DAT004 VX1000_TRSFRLIST_INIT002((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x004))
+#else  /* !(VX1000_OLDA_EVENT_COUNT & 0x002) */
+#define VX1000_EVENTLIST_DAT002        VX1000_EVENTLIST_DAT004
+#define VX1000_TRSFRLIST_DAT002        VX1000_TRSFRLIST_DAT004
+#endif /* !(VX1000_OLDA_EVENT_COUNT & 0x002) */
+#if (((VX1000_OLDA_EVENT_COUNT) & 0x001) == 0x001)
+#define VX1000_EVENTLIST_DAT001        VX1000_EVENTLIST_DAT002 VX1000_EVENTLIST_INIT001((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x002))
+#define VX1000_TRSFRLIST_DAT001        VX1000_TRSFRLIST_DAT002 VX1000_TRSFRLIST_INIT001((VX1000_OLDA_EVENT_COUNT) & (0x10000-0x002))
+#else  /* !(VX1000_OLDA_EVENT_COUNT & 0x001) */
+#define VX1000_EVENTLIST_DAT001        VX1000_EVENTLIST_DAT002
+#define VX1000_TRSFRLIST_DAT001        VX1000_TRSFRLIST_DAT002
+#endif /* !(VX1000_OLDA_EVENT_COUNT & 0x001) */
+#define VX1000_EVENTLIST_DAT           VX1000_EVENTLIST_INIT(0x000) VX1000_EVENTLIST_DAT001
+#define VX1000_TRSFRLIST_DAT           VX1000_TRSFRLISTSPC_INIT(0x000) VX1000_TRSFRLIST_DAT001
+#endif /* VX1000_OLDA_FORCE_V8 */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OldaInit                                                                                             */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Reset all Olda-related VX1000 structure data.                                                               */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static void VX1000_SUFFUN(vx1000_OldaInit)( void )
+{
+#if defined(VX1000_OLDA_FORCE_V8)
+  static const VX1000_UINT32 vx1000TransferListInit[((VX1000_EVENTDESCR_SPCSIZ) + ((VX1000_OLDA_EVENT_COUNT) * (VX1000_EVENTDESCR_DAQSIZ)))] = { VX1000_TRSFRLIST_DAT };/* PRQA S 0303 */ /* PRQA S 0306 */ /* macro expansion contains VX1000_ADDR_TO_PTR2XXX: cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are provided as integer types by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX requires a typecast */
+  static const VX1000_UINT32 vx1000EventListInit[4 * (1 + (VX1000_OLDA_EVENT_COUNT))] = { VX1000_EVENTLIST_DAT };
+#endif /* VX1000_OLDA_FORCE_V8 */
+  gVX1000.Olda.Version = VX1000_OLDA_VERSION;
+  gVX1000.Olda.Running = 0;
+#if !defined(VX1000_OLDA_MEMORY_ADDR)
+  gVX1000.Olda.MemoryAddr = VX1000_PTR2VUWS_TO_ADDRESS(&gVX1000.Olda.Data[0]); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */ /* PRQA S 0309 */ /* not violating MISRA rule 11.3 with respect to the type sizes: 32 bit are sufficient to hold either a 0:32 flat or a 10:16 paged pointer */
+#else /* VX1000_OLDA_MEMORY_ADDR */
+  gVX1000.Olda.MemoryAddr = VX1000_OLDA_MEMORY_ADDR;
+#endif /* VX1000_OLDA_MEMORY_ADDR */
+  gVX1000.Olda.MemorySize = VX1000_OLDA_MEMORY_SIZE;
+  gVX1000.Olda.EventCount = 0;
+  gVX1000.Olda.EventList = 0;
+  gVX1000.Olda.TransferList = 0;
+  gVX1000.Olda.SizeLengthNOffset = (VX1000_OLDA_SIZE_OFFSET) | ((VX1000_OLDA_SIZE_LENGTH) << 5);
+  gVX1000.Olda.SizeSwapValue = VX1000_OLDA_SIZE_SWAP_VALUE;
+  gVX1000.Olda.OldaFeatures = (((((((((((((((0U
+                            | (VX1000_FEAT_OLDA_STIM))
+                            | (VX1000_FEAT_OLDA_HBB))
+                            | (VX1000_FEAT_OLDA_MULTIBUFFER))
+                            | (VX1000_FEAT_OLDA_V5_DYNSIZE))
+                            | (VX1000_FEAT_OLDA_V7_ASMDAQBOOKE))
+                            | (VX1000_FEAT_OLDA_V7_ASMDAQVLE))
+                            | (VX1000_FEAT_OLDA_V7_COMPRESS))
+                            | (VX1000_FEAT_OLDA_V7_BYTEDAQ)) | (VX1000_FEAT_OLDA_V7_MEMSY_SEL))
+                            | (VX1000_FEAT_OLDA_BENCHMARK))
+                            | (VX1000_FEAT_OLDA_OVERLOADDETECT))
+                            | (VX1000_FEAT_OLDA_512EVENTS))
+                            | (VX1000_FEAT_OLDA_UNUSED_FLAG11))
+                            | (VX1000_FEAT_OLDA_UNUSED_FLAG12))
+                            | (VX1000_FEAT_OLDA_UNUSED_FLAG13))
+#if !defined(VX1000_TARGET_TRICORE)
+                            | (VX1000_FEAT_OLDA_TRIGGER)
+                            ;
+#else  /* VX1000_TARGET_TRICORE */
+                            ;
+  if (VX1000_ECU_IS_AURIX()) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  {
+    switch ((VX1000_MCREG_CBS_JTAGID) & (VX1000_JTAGID_PN_MASK)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    {
+      case VX1000_JTAGID_PN_TC21x:
+      case VX1000_JTAGID_PN_TC22x:
+      case VX1000_JTAGID_PN_TC23x:
+      case VX1000_JTAGID_PN_TC32x:
+      case VX1000_JTAGID_PN_TC33x:
+      case VX1000_JTAGID_PN_TC33xED:
+      case VX1000_JTAGID_PN_TC35x:
+      case VX1000_JTAGID_PN_TC36x:
+      case VX1000_JTAGID_PN_TC37x:
+      case VX1000_JTAGID_PN_TC37xED:
+      case VX1000_JTAGID_PN_TC38x:
+      case VX1000_JTAGID_PN_TC39x:
+        gVX1000.Olda.OldaFeatures |= (VX1000_FEAT_OLDA_TRIGGER_TYPE3);
+        break;
+      default:
+        gVX1000.Olda.OldaFeatures |= (VX1000_FEAT_OLDA_TRIGGER_TYPE2);
+        break;
+    }
+  }
+  else
+  {
+    gVX1000.Olda.OldaFeatures |= (VX1000_FEAT_OLDA_TRIGGER_TYPE1);
+  }
+#endif /* VX1000_TARGET_TRICORE */
+  gVX1000.Olda.OldaFeatures2 = ((((((((((0U
+                             | (VX1000_FEAT_OLDA_V8CMD_USRCPY))
+                             | (VX1000_FEAT_OLDA_V8CMD_SP8N))
+                             | (VX1000_FEAT_OLDA_V8CMD_CP8N))
+                             | (VX1000_FEAT_OLDA_V8CMD_CP16N))
+                             | (VX1000_FEAT_OLDA_V8CMD_CP32N))
+                             | (VX1000_FEAT_OLDA_V8CMD_CP64N))
+                             | (VX1000_FEAT_OLDA_V8CMD_LEGACYVR))
+                             | (VX1000_FEAT_OLDA_V8CMD_WAIT))
+                             | (VX1000_FEAT_OLDA_V8CMD_CALLJITA))
+                             | (VX1000_FEAT_OLDA_V8CMD_SUBEVT))
+                             ;
+  gVX1000.Olda.OldaBenchmarkCnt = VX1000_OLDA_BENCHMARK_CNT;
+  gVX1000.Olda.Res2 = 0UL;
+
+#if defined(VX1000_OLDA_BENCHMARK) && (VX1000_OLDA_BENCHMARK_CNT > 0)
+  {
+    VX1000_UINT32 i;
+    for (i = 0; i < (VX1000_OLDA_BENCHMARK_CNT); i++) { gVX1000_OLDA_Duration[i] = 0; }
+  }
+#endif /* VX1000_OLDA_BENCHMARK && VX1000_OLDA_BENCHMARK_CNT */
+
+  if ( (VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.Olda.MemoryAddr)) != (0x4UL + VX1000_PTR2VO_TO_ADDRESS(&gVX1000.Olda)) ) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  {
+    gVX1000.ToolDetectState |= VX1000_TDS_ERROR;
+    VX1000_ERRLOGGER(VX1000_ERRLOG_STRUCTS_PADDED)
+  }
+
+  gVX1000.Olda.MagicId = VX1000_OLDA_MAGIC;
+#if defined(VX1000_OLDA_FORCE_V8)
+  gVX1000.Olda.TransferList = VX1000_PTR2CU32_TO_ADDRESS(vx1000TransferListInit); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  gVX1000.Olda.EventList = VX1000_PTR2CU32_TO_ADDRESS(vx1000EventListInit); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  gVX1000.Olda.EventCount = 1 + (VX1000_OLDA_EVENT_COUNT);
+  gVX1000.Olda.Running = 1; /* set Running to 1 (must: specialEvents are handled by olda / possible: VX supports dynamic reprogramming the descriptors while measurement is running) */
+#endif /* VX1000_OLDA_FORCE_V8 */
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OldaEvent                                                                                            */
+/* API name:      VX1000_EVENT (user) / VX1000_OLDA_EVENT (internal only)                                                     */
+/* Wrapper API:   VX1000If_Event                                                                                              */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    eventNumber E [0,gVX1000.Olda.EventCount)                                                                   */
+/*                Validity ensured by internal silent abort.                                                                  */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_OldaInit() must have been called.                                                                    */
+/* Precondition2: The MMU must be programmed such that the source memory and the destination memory are visible.              */
+/* Precondition3: The MPU must be programmed such that the source memory is readable and the destination memory is writeable. */
+/* Description:   Processes all transfer descriptors assigned to parameter1, copies DAQ data to the olda buffer.              */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE)
+/* force the optimisation level to >0/DEBUG because in O0 the parameters are passed on the stack and the assembly code would crash */
+/* Note: this pragma is only available on the HighTec branch --> only activate the feature when VLE is used */
+#pragma GCC push_options
+#pragma GCC optimize ("O3")
+#endif /* VX1000_SUPPORT_OLDA7_ASMGNUVLE */
+#if defined(VX1000_OLDA_FORCE_V8)
+void VX1000_SUFFUN(vx1000_OldaEvent)( VX1000_UINT16 eventNumber, VX1000_UINT32 extendedParameter )
+#else /* !VX1000_OLDA_FORCE_V8 */
+void VX1000_SUFFUN(vx1000_OldaEvent)( VX1000_UINT16 eventNumber )
+#endif /* !VX1000_OLDA_FORCE_V8 */
+{
+  VX1000_OLDA_EVENT_T *pEventList = VX1000_ADDR_TO_PTR2OE(gVX1000.Olda.EventList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  VX1000_UINT32 *pTransferList = (VX1000_ADDR_TO_PTR2U32(gVX1000.Olda.TransferList)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_OLDA_BENCHMARK)
+  VX1000_UINT32 byteTransferCount = 0;
+#endif /* VX1000_OLDA_BENCHMARK */
+#if defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8)
+  VX1000_UINT8 useOldaVersion = 8;
+#endif /* VX1000_SUPPORT_OLDA8CMD_LEGACYVR && VX1000_OLDA_FORCE_V8 */
+  VX1000_UINT32 t0, sz, dstAddr, srcAddr;
+#if (defined(VX1000_OLDA_FORCE_V8) || defined(VX1000_OLDA_FORCE_V7))
+  volatile VX1000_UINT32 *dst32 = VX1000_ADDR_TO_PTR2VU32(0), *src32 = VX1000_ADDR_TO_PTR2VU32(0); /* dummy initialisations to prevent MISRA from complaining about (dummy)reading uninitialised variables */
+#endif /* (VX1000_OLDA_FORCE_V8 || VX1000_OLDA_FORCE_V7) */
+#if (defined(VX1000_OLDA_FORCE_V8) || (defined(VX1000_SUPPORT_OLDA7_BYTEDAQ) && defined(VX1000_OLDA_FORCE_V7)))
+  volatile VX1000_UINT8  *dst8 = VX1000_ADDR_TO_PTR2VU8(0), *src8 = VX1000_ADDR_TO_PTR2VU8(0); /* dummy initialisations to prevent MISRA from complaining about (dummy)reading uninitialised variables */
+#endif /* (VX1000_OLDA_FORCE_V8 || (VX1000_SUPPORT_OLDA7_BYTEDAQ && VX1000_OLDA_FORCE_V7) */
+  VX1000_UINT32 k = 0;
+  VX1000_OLDA_EVENT_T *event;
+  VX1000_UINT16 descriptorCount, descriptorIndex;
+#if defined(VX1000_SUPPORT_OLDA7_BYTEDAQ) && (defined(VX1000_OLDA_FORCE_V7) || (defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8)))
+  VX1000_UINT8 useByteMode = 0;
+#endif /* VX1000_SUPPORT_OLDA7_BYTEDAQ && (VX1000_OLDA_FORCE_V7 || (VX1000_SUPPORT_OLDA8CMD_LEGACYVR && VX1000_OLDA_FORCE_V8) */
+#if defined(VX1000_OLDA_FORCE_V7) || defined(VX1000_OLDA_FORCE_V8)
+  VX1000_UINT32 sizeList = 0;
+#if defined(VX1000_OLDA_FORCE_V7) || defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR)
+  VX1000_UINT8 sizeListIndex;
+#endif /* VX1000_OLDA_FORCE_V7 || VX1000_SUPPORT_OLDA8CMD_LEGACYVR */
+#endif /* VX1000_OLDA_FORCE_V7 || VX1000_OLDA_FORCE_V8 */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+  VX1000_UINT32 evsync;
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 1)
+  volatile VX1000_UINT32 *memSyncTrigPtr = VX1000_ADDR_TO_PTR2VU32(gVX1000.MemSyncTrigPtr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  VX1000_UINT8 evprop = VX1000_CURRENT_CORE_IDX();
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+
+  VX1000_OLDA_NOPS()
+
+#if defined(VX1000_OLDA_FORCE_V7) || defined(VX1000_OLDA_FORCE_V8)
+  VX1000_DUMMYREAD(sizeList)   /* dummy usage to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+#endif /* VX1000_OLDA_FORCE_V7 || VX1000_OLDA_FORCE_V8 */
+
+  VX1000_DUMMYREAD(k)   /* dummy usage to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+
+#if (defined(VX1000_OLDA_FORCE_V8) || (defined(VX1000_SUPPORT_OLDA7_BYTEDAQ) && defined(VX1000_OLDA_FORCE_V7)))
+  VX1000_DUMMYREAD(src8)   /* dummy usage to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(dst8)   /* dummy usage to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+#endif /* (VX1000_OLDA_FORCE_V8 || (VX1000_SUPPORT_OLDA7_BYTEDAQ && VX1000_OLDA_FORCE_V7)) */
+#if (defined(VX1000_OLDA_FORCE_V8) || defined(VX1000_OLDA_FORCE_V7))
+  VX1000_DUMMYREAD(src32)   /* dummy usage to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(dst32)   /* dummy usage to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+#endif /* (VX1000_OLDA_FORCE_V8 || VX1000_OLDA_FORCE_V7) */
+
+
+  /* Take the timestamp first to have maximum precision.  */
+  /* This timestamp will be needed for data trace as well */
+  t0 = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 1)
+  if (evprop >= (VX1000_MEMSYNC_TRIGGER_COUNT)) /* PRQA S 3356 */ /* PRQA S 3359 */ /* cannot avoid violating MISRA rule 13.7 because this logical operation/control expression is actually an assertion that by design must always evaluate to FALSE  */
+  { /* PRQA S 3201 */ /* cannot avoid violating MISRA rule 14.1 because this block contains code to handle an error supposed never to occur */
+    evprop = 0;
+    VX1000_ERRLOGGER(VX1000_ERRLOG_TOO_MANY_CORES)
+  }
+  evsync = memSyncTrigPtr[evprop];
+#else /* VX1000_MEMSYNC_TRIGGER_COUNT <= 1 */
+  evsync = gVX1000.MemSyncTrigPtr;
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT <= 1 */
+  evsync = (evsync + 0x0C) & ~7UL;   /* seek MemSync_1 but fall back to MemSync_0 if odd */
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 0 */
+
+#if !defined(VX1000_OLDA_FORCE_V8)
+  gVX1000.EventTimestamp = t0;
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+  {
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE) || defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE)
+    {
+      register VX1000_UINT32 tAddr = VX1000_PTR2U32_TO_ADDRESS(&gVX1000.EventTimestamp);
+      register VX1000_UINT32 tData = t0;
+      register VX1000_UINT32 tScratch = 0; /* dummy initialisation to force unique register allocation of the compiler */
+      register VX1000_UINT32 tPtr = evsync;
+      __asm__ volatile
+      (
+        "\
  or       %0, 30, 30"
+        "\
  or       30, %1, %1"
+        "\
  or       %1, 31, 31"
+        "\
  or       31, %2, %2"
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE)
+        "\
  e_stmw   30, 0(%3)"
+#elif defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE)
+        "\
  stmw     30, 0(%3)"
+#endif /* VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+        "\
  or       31, %1, %1"
+        "\
  or       30, %0, %0"
+        "\
" :
+        "=""r"(tScratch),     /* %0 */
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+        "=""r"(tData),        /* %1 */
+        "=""r"(tAddr),        /* %2 */
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+        "=""r"(tAddr),        /* %1 */
+        "=""r"(tData),        /* %2 */
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+        "=""r"(tPtr)          /* %3 */
+        :
+        "0"(tScratch),     /* %0 */
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+        "1"(tData),        /* %1 */
+        "2"(tAddr),        /* %2 */
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+        "1"(tAddr),        /* %1 */
+        "2"(tData),        /* %2 */
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+        "3"(tPtr)          /* %3 */
+        : "30", "31"
+      );
+      tScratch++; tData++; tAddr++; tPtr++; /* dummy usage to avoid compiler mis-optimisation */
+      tScratch++; tData++; tAddr++; tPtr++; /* dummy usage to avoid compiler mis-optimisation */
+    }
+#else /* !VX1000_SUPPORT_OLDA7_ASMGNUVLE && !VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+    VX1000_STORE64(evsync, (VX1000_UINT32)&gVX1000.EventTimestamp, t0); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_ARM_DSB)
+    VX1000_ARM_DSB()
+#endif /* VX1000_ARM_DSB */
+#endif /* !VX1000_SUPPORT_OLDA7_ASMGNUVLE && !VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+  }
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+#endif /* !VX1000_OLDA_FORCE_V8 */
+
+  if ((gVX1000.Olda.Running == 1) && (gVX1000.Olda.MagicId == VX1000_OLDA_MAGIC))
+  {
+    /* OLDA is running */
+    if (eventNumber < gVX1000.Olda.EventCount)
+    {
+      /* the eventNumber is valid */
+      event = &(pEventList[eventNumber]);
+
+#if defined(VX1000_OLDA_BENCHMARK)
+#if VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT
+      if (eventNumber < (VX1000_OLDA_BENCHMARK_CNT)) /* OLDA event numbers are in the range 0..VX1000_OLDA_EVENT_COUNT-1 */
+#endif /* VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT */
+      {
+#if !defined(VX1000_OLDA_FORCE_V8)
+        if (event->TransferCount == 0)
+        {
+          gVX1000_OLDA_Duration[eventNumber] = 0; /* clear statistic of inactive events */
+        }
+        else
+#endif /* !VX1000_OLDA_FORCE_V8 */
+        {
+          gVX1000_OLDA_TransferSize[eventNumber]  = 0; /* reset benchmark upon start of active event */
+          gVX1000_OLDA_TransferCount[eventNumber] = event->TransferCount; /* ? */
+        }
+      }
+#endif /* VX1000_OLDA_BENCHMARK */
+
+#if defined(VX1000_OLDA_FORCE_V8)
+      descriptorCount = 0xFFFFU; /* all events are valid; pre-charge dummy count (events are finished by DONE command) but allow switch to legacy OLDA at runtime */
+#else  /* !VX1000_OLDA_FORCE_V8 */
+      descriptorCount = event->TransferCount;
+      if (descriptorCount != 0)
+#endif /* !VX1000_OLDA_FORCE_V8 */
+      {
+        /* eventNumber is active, there\'s data to be copied (or at least an event to be triggered) */
+
+        /* Take an individual copy of the timestamp for each event, gVX1000.EventTimestamp mustn\'t have changed meanwhile */
+        event->EventTimestamp = t0;
+#if defined(VX1000_OLDA_OVERLOAD_DETECTION)
+        event->EventCounter++; /* Pre: increase the Event-Counter to detect Overruns */
+#endif /* VX1000_OLDA_OVERLOAD_DETECTION */
+
+        /* Copy data to an intermediate location */
+        descriptorIndex = event->TransferIndex;
+        dstAddr = event->TransferDest;
+#if defined(VX1000_OLDA_FORCE_V8) && defined(VX1000_SUPPORT_OLDA_MULTIBUFFER)
+        dstAddr += (((event->EventCounter >> 1) & (VX1000_OLDA_BUFFERINDEX_MASK)) * event->TransferCount);
+#if defined(VX1000_OLDA_OVERLOAD_DETECTION)
+        /* todo: if ((event->EventCounter ^ event->EventCounterAck) & VX1000_OLDA_BUFFERINDEX_MASK) is zero, the VX has not freed yet the next buffer -> decrement EvenCounter, increment OverrunCounter, leave function */
+#endif /* VX1000_OLDA_OVERLOAD_DETECTION */
+#endif /* VX1000_OLDA_FORCE_V8 && VX1000_SUPPORT_OLDA_MULTIBUFFER */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0) && (defined(VX1000_OLDA_FORCE_V7) || (defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8)))
+        if (0==pTransferList[descriptorIndex])  /* a first invalid size(-List) entry in memsync mode indicates that the descriptors of this event are to be handled in standard olda mode */
+        {
+          evsync = 0;
+          ++descriptorIndex;
+        }
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT & VX1000_OLDA_FORCE_V7 */
+#if (defined(VX1000_OLDA_FORCE_V7) || (defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8))) && defined(VX1000_SUPPORT_OLDA7_BYTEDAQ)
+        if (0==pTransferList[descriptorIndex])  /* a first invalid size(-List) entry indicates that the descriptors of this event are encoded in byte-mode */
+        {
+          ++descriptorIndex;
+          useByteMode = 1;
+          sizeList = 0UL;         /* force initial loading of the sizeList upon next opportunity */
+        }
+#endif /* VX1000_OLDA_FORCE_V7 && VX1000_SUPPORT_OLDA7_BYTEDAQ */
+        while (descriptorCount > 0)
+        {
+          VX1000_UINT32 descriptor = pTransferList[descriptorIndex];
+          descriptorCount--;
+          descriptorIndex++;
+#if defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8)
+          if (useOldaVersion == 7)
+          {
+#endif /* VX1000_SUPPORT_OLDA8CMD_LEGACYVR && VX1000_OLDA_FORCE_V8 */
+#if !defined(VX1000_OLDA_FORCE_V8) || (defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8))
+#if defined(VX1000_OLDA_FORCE_V7) || (defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8))
+#if defined(VX1000_SUPPORT_OLDA7_BYTEDAQ)
+            if (useByteMode != 0)
+            {
+              /* TransferList entry consists of up to 4 transfer sizes (8Bit), followed by up to 4 pure transfer address entries (32Bit) */
+              if (0==sizeList)
+              {
+                sizeList = descriptor;
+                descriptor = pTransferList[descriptorIndex];
+                ++descriptorIndex;
+              }
+              sz = (VX1000_UINT8)(sizeList & 0x000000FFUL); /* copy 0..255 bytes (this differs from normal DAQ which uses words) */
+              sizeList >>= 8U;
+#if defined(VX1000_OLDA_BENCHMARK)
+              byteTransferCount += sz;
+#endif /* VX1000_OLDA_BENCHMARK */
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE)  /* hint: (sz is in the range 0..255; data-type is BYTE) */
+              {
+                /* NOTE: we have to force/use long versions of the VLE instructions because in O3, the compiler allocates also registers 8..23 that cannot be accessed by all short instructions! */
+                /* NOTE: dst8 either must not be modified OR we may return the post-copy-destination but have to skip the advancement in the C-part then --> use the second variant */
+                /* NOTE: src8 may be destroyed but we must tell the compiler so */
+                /* NOTE: sz may be destroyed but we should tell the compiler so */
+                register VX1000_UINT32 tBytes = (VX1000_UINT32)sz;
+                register VX1000_UINT32 tSource = descriptor;
+                register VX1000_UINT32 tDest = dstAddr;
+                register VX1000_UINT32 tScratch1=0; /* dummy initialisation to force unique register allocation of the compiler */
+                register VX1000_UINT32 tScratch2=1; /* dummy initialisation to force unique register allocation of the compiler */
+                __asm__ volatile
+                (
+                  "\
  e_cmpi   0, %2, 0"
+                  "\
  mfspr    %0, 9"       /* save CTR (because the compiler does not know that we use it) */
+                  "\
  e_add16i %4, %4, -1"
+                  "\
  beq      9f"
+                  "\
  e_add16i %3, %3, -1"
+                  "\
  mtspr    9, %2"       /* initialise HW-iterator */
+                  "\
8:"
+                  "\
  e_lbzu   %1, 1(%3)"
+                  "\
  e_stbu   %1, 1(%4)"
+                  "\
  bdnz     8b"
+                  "\
9:"
+                  "\
  e_add16i %4, %4, 1"   /* post-increment the destination pointer */
+                  "\
  mtspr    9, %0"       /* restore CTR */
+                  "\
" ::
+                  /*"=" -- does not compile*/"r"(tScratch1),    /* %0 */
+                  /*"=" -- does not compile*/"r"(tScratch2),    /* %1 */
+                  /*"+" -- does not compile*/"r"(tBytes),       /* %2 */
+                  /*"+" -- does not compile*/"r"(tSource),      /* %3 */
+                  /*"+" -- does not compile*/"r"(tDest)         /* %4 */
+                );
+                dstAddr = tDest;
+              }
+#elif defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE)
+              {
+                /* NOTE: cannot be compiled with -O0 because without optimisation, the compiler wants to pass parameters on stack while the code is written for -O1/-O2/-O3/-Os which use registers for passing */
+                register VX1000_UINT32 tBytes = (VX1000_UINT32)sz;
+                register VX1000_UINT32 tSource = descriptor;
+                register VX1000_UINT32 tDest = dstAddr;
+                register VX1000_UINT32 tScratch1=0; /* dummy initialisation to force unique register allocation of the compiler */
+                register VX1000_UINT32 tScratch2=1; /* dummy initialisation to force unique register allocation of the compiler */
+                __asm__ volatile
+                (
+                  "\
  or.     %2, %2, %2"
+                  "\
  mfspr   %0, 9"       /* save CTR (because the compiler does not know that we use it) */
+                  "\
  addi    %4, %4, -1"
+                  "\
  beq     9f"
+                  "\
  addi    %3, %3, -1"
+                  "\
  mtspr   9, %2"       /* initialise HW-iterator */
+                  "\
8:"
+                  "\
  lbzu    %1, 1(%3)"
+                  "\
  stbu    %1, 1(%4)"
+                  "\
  bdnz    8b"
+                  "\
9:"
+                  "\
  addi    %4, %4, 1"   /* post-increment the destination pointer */
+                  "\
  mtspr   9, %0"       /* restore CTR */
+                  "\
" :
+                  "=""r"(tScratch1),        /* %0 */
+                  "=""r"(tScratch2),        /* %1 */
+                  "=""r"(tBytes),           /* %2 */
+                  "=""r"(tSource),          /* %3 */
+                  "=""r"(tDest)             /* %4 */
+                  :
+                  "0"(tScratch1),           /* %0 */
+                  "1"(tScratch2),           /* %1 */
+                  "2"(tBytes),              /* %2 */
+                  "3"(tSource),             /* %3 */
+                  "4"(tDest)                /* %4 */
+                  : "0"
+                );
+                tScratch1++; tScratch2++; tBytes++; tSource++; /* dummy usage to avoid compiler mis-optimisation */
+                tScratch1++; tScratch2++; tBytes++; tSource++; /* dummy usage to avoid compiler mis-optimisation */
+                dstAddr = tDest;
+              }
+#else /* !VX1000_SUPPORT_OLDA7_ASMGNUVLE && !VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+              src8 = VX1000_ADDR_TO_PTR2VU8(descriptor); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+              dst8 = VX1000_ADDR_TO_PTR2VU8(dstAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+              for (k = 0; k < sz; ++k) { dst8[k] = src8[k]; }
+              dstAddr += (VX1000_UINT32)sz;
+#endif /* !VX1000_SUPPORT_OLDA7_ASMGNUVLE && !VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+            }
+            else
+#endif /* VX1000_SUPPORT_OLDA7_BYTEDAQ */
+            {
+              sz = ((VX1000_UINT8)(descriptor & 0x00000003UL));
+              if ( 0==sz )
+              {
+                /* TransferList entry consists of up to 5 transfer sizes [31..2] and size list identifier [1..0]==0 */
+                sizeList = descriptor >> 2;
+                descriptorCount++; /* undo decrement of remaining transfers because size list entry isn\'t a transfer */
+                for (sizeListIndex = 0; (sizeListIndex < 5) && (descriptorCount > 0); sizeListIndex++)
+                {
+                  sz = (VX1000_UINT8)(sizeList & 0x3FUL);
+                  sizeList >>= 6U;
+                  descriptorCount--;
+                  descriptor = pTransferList[descriptorIndex];
+                  srcAddr = descriptor;
+                  descriptorIndex++;
+#if defined(VX1000_OLDA_BENCHMARK)
+                  byteTransferCount += sz << 2; /* Size of all transfers in DWORDs */
+#endif /* VX1000_OLDA_BENCHMARK */
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE) /* hint: (sz is in the range 0..63; data-type is DWORD) */
+                  {
+                    register VX1000_UINT32 tWords = (VX1000_UINT32)sz;
+                    register VX1000_UINT32 tSource = srcAddr;
+                    register VX1000_UINT32 tDest = dstAddr;
+                    register VX1000_UINT32 tScratch1=0; /* dummy initialisation to force unique register allocation of the compiler */
+                    register VX1000_UINT32 tScratch2=1; /* dummy initialisation to force unique register allocation of the compiler */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+                    if (evsync != 0)
+                    {
+#if !defined(VX1000_CLASSIMEMSY) /* !FW < 2016-07-20: set VX1000_CLASSIMEMSY; for later FW leave undefined! */
+                      register VX1000_UINT32 tBuf = dstAddr;
+                      dstAddr += sz << 2;
+#endif /* !VX1000_CLASSIMEMSY */
+                      tDest = VX1000_ADDR_TO_PTR2U32(evsync); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                      __asm__ volatile
+                      (
+                        "\
  e_cmpi   0, %2, 2"
+                        "\
  mfspr    %0, 9"      /* save CTR (because the compiler does not know that we use it) */
+                        "\
  beq      9f"
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+                        "\
  or       %1, 31, 31"
+#if !defined(VX1000_CLASSIMEMSY)
+                        "\
  e_add16i 31, %5, -4"
+                        "\
  e_add16i %3, %3, -4"
+#else  /* VX1000_CLASSIMEMSY */
+                        "\
  e_add16i 31, %3, -4"
+#endif /* VX1000_CLASSIMEMSY */
+                        "\
  or       %3, 30, 30"
+                        "\
  mtspr    9, %2"      /* initialise HW-iterator */
+                        "\
8:"
+#if !defined(VX1000_CLASSIMEMSY)
+                        "\
  e_add16i 31, r31, 4"
+                        "\
  e_lwzu   30, 4(%3)"
+#else  /* VX1000_CLASSIMEMSY */
+                        "\
  e_lwzu   30, 4(31)"
+#endif /* VX1000_CLASSIMEMSY */
+                        "\
  e_stmw   30, 0(%4)"
+                        "\
  bdnz     8b"
+                        "\
  or       30, %3, %3"
+                        "\
  or       31, %1, %1"
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+                        "\
  or       %1, 30, 30"
+#if !defined(VX1000_CLASSIMEMSY)
+                        "\
  e_add16i 30, %5, -4"
+                        "\
  e_add16i %3, %3, -4"
+#else  /* VX1000_CLASSIMEMSY */
+                        "\
  e_add16i 30, %3, -4"
+#endif /* VX1000_CLASSIMEMSY */
+                        "\
  or       %3, 31, 31"
+                        "\
  mtspr    9, %2"      /* initialise HW-iterator */
+                        "\
8:"
+#if !defined(VX1000_CLASSIMEMSY)
+                        "\
  e_add16i 30, r30, 4"
+                        "\
  e_lwzu   31, 4(%3)"
+#else  /* VX1000_CLASSIMEMSY */
+                        "\
  e_lwzu   31, 4(30)"
+#endif /* VX1000_CLASSIMEMSY */
+                        "\
  e_stmw   30, 0(%4)"
+                        "\
  bdnz     8b"
+                        "\
  or       31, %3, %3"
+                        "\
  or       30, %1, %1"
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+                        "\
9:"
+                        "\
  mtspr    9, %0"      /* restore CTR */
+                        "\
" :
+                        "=""r"(tScratch1),        /* %0 */
+                        "=""r"(tScratch2),        /* %1 */
+                        "=""r"(tWords),           /* %2 */
+                        "=""r"(tSource),          /* %3 */
+                        "=""r"(tDest)             /* %4 */
+#if !defined(VX1000_CLASSIMEMSY)
+                       ,"=""r"(tBuf)              /* %5 */
+#endif /* !VX1000_CLASSIMEMSY */
+                        :
+                        "0"(tScratch1),           /* %0 */
+                        "1"(tScratch2),           /* %1 */
+                        "2"(tWords),              /* %2 */
+                        "3"(tSource),             /* %3 */
+                        "4"(tDest)                /* %4 */
+#if !defined(VX1000_CLASSIMEMSY)
+                       ,"5"(tBuf)                 /* %5 */
+#endif /* !VX1000_CLASSIMEMSY */
+                        : "30", "31"
+                      );
+                      tScratch1++; tScratch2++; tWords++; tSource++; tDest++; /* dummy usage to avoid compiler mis-optimisation */
+                      tScratch1++; tScratch2++; tWords++; tSource++; tDest++; /* dummy usage to avoid compiler mis-optimisation */
+                    }
+                    else
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+                    {
+                      register VX1000_UINT32 tScratch3=2; /* dummy initialisation to force unique register allocation of the compiler */
+                      register VX1000_UINT32 tScratch4=3; /* dummy initialisation to force unique register allocation of the compiler */
+                      register VX1000_UINT32 tScratch5=4; /* dummy initialisation to force unique register allocation of the compiler */
+                      __asm__ volatile
+                      (
+                        "\
  e_andi.  %1, %5, 1"
+                        "\
  e_add16i %7, %7, -4"
+                        "\
  e_add16i %6, %6, -4"
+                        "\
  beq      1f"
+                        "\
  e_lwzu   %1, 4(%6)"
+                        "\
  e_stwu   %1, 4(%7)"
+                        "\
1:"
+                        "\
  e_andi.  %2, %5, 2"
+                        "\
  beq      2f"
+                        "\
  e_lwz    %1, 4(%6)"
+                        "\
  e_lwzu   %2, 8(%6)"
+                        "\
  e_stw    %1, 4(%7)"
+                        "\
  e_stwu   %2, 8(%7)"
+                        "\
2:"
+                        "\
  e_srwi.  %5, %5, 2"
+                        "\
  mfspr    %0, 9"      /* save CTR (because the compiler does not know that we use it) */
+                        "\
  beq      9f"
+                        "\
  mtspr    9, %5"      /* initialise HW-iterator */
+                        "\
8:"
+                        "\
  e_lwz    %1,  4(%6)"
+                        "\
  e_lwz    %2,  8(%6)"
+                        "\
  e_lwz    %3, 12(%6)"
+                        "\
  e_lwzu   %4, 16(%6)"
+                        "\
  e_stw    %1,  4(%7)"
+                        "\
  e_stw    %2,  8(%7)"
+                        "\
  e_stw    %3, 12(%7)"
+                        "\
  e_stwu   %4, 16(%7)"
+                        "\
  bdnz     8b"
+                        "\
9:"
+                        "\
  e_add16i %7, %7, 4"  /* post-increment the destination pointer */
+                        "\
  mtspr    9, %0"      /* restore CTR */
+                        "\
" ::
+                        /*"=" -- does not compile*/"r"(tScratch1),    /* %0 */
+                        /*"=" -- does not compile*/"r"(tScratch2),    /* %1 */
+                        /*"=" -- does not compile*/"r"(tScratch3),    /* %2 */
+                        /*"=" -- does not compile*/"r"(tScratch4),    /* %3 */
+                        /*"=" -- does not compile*/"r"(tScratch5),    /* %4 */
+                        /*"+" -- does not compile*/"r"(tWords),       /* %5 */
+                        /*"+" -- does not compile*/"r"(tSource),      /* %6 */
+                        /*"+" -- does not compile*/"r"(tDest)         /* %7 */
+                      );
+                    }
+                  }
+#elif defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE)
+                  {
+                    register VX1000_UINT32 tWords = (VX1000_UINT32)sz;
+                    register VX1000_UINT32 tSource = srcAddr;
+                    register VX1000_UINT32 tDest = dstAddr;
+                    register VX1000_UINT32 tScratch1=0; /* dummy initialisation to force unique register allocation of the compiler */
+                    register VX1000_UINT32 tScratch2=1; /* dummy initialisation to force unique register allocation of the compiler */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+                    if (evsync != 0)
+                    {
+#if !defined(VX1000_CLASSIMEMSY)
+                      register VX1000_UINT32 tBuf = dstAddr;
+                      dstAddr += sz << 2;
+#endif /* !VX1000_CLASSIMEMSY */
+                      tDest = (VX1000_UINT32 /* * */)evsync;
+                      __asm__ volatile
+                      (
+                        "\
  or.      %2, %2, %2"
+                        "\
  mfspr    %0, 9"      /* save CTR (because the compiler does not know that we use it) */
+                        "\
  beq      9f"
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+                        "\
  or       %1, 31, 31"
+#if !defined(VX1000_CLASSIMEMSY)
+                        "\
  addi     31, %5, -4"
+                        "\
  addi     %3, %3, -4"
+#else  /* VX1000_CLASSIMEMSY */
+                        "\
  addi     31, %3, -4"
+#endif /* VX1000_CLASSIMEMSY */
+                        "\
  or       %3, 30, 30"
+                        "\
  mtspr    9, %2"      /* initialise HW-iterator */
+                        "\
8:"
+#if !defined(VX1000_CLASSIMEMSY)
+                        "\
  addi     31, 31, 4"
+                        "\
  lwzu     30, 4(%3)"
+#else  /* VX1000_CLASSIMEMSY */
+                        "\
  lwzu     30, 4(31)"
+#endif /* VX1000_CLASSIMEMSY */
+                        "\
  stmw     30, 0(%4)"
+                        "\
  bdnz     8b"
+                        "\
  or       30, %3, %3"
+                        "\
  or       31, %1, %1"
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+                        "\
  or       %1, 30, 30"
+#if !defined(VX1000_CLASSIMEMSY)
+                        "\
  addi     30, %5, -4"
+                        "\
  addi     %3, %3, -4"
+#else  /* VX1000_CLASSIMEMSY */
+                        "\
  addi     30, %3, -4"
+#endif /* VX1000_CLASSIMEMSY */
+                        "\
  or       %3, 31, 31"
+                        "\
  mtspr    9, %2"      /* initialise HW-iterator */
+                        "\
8:"
+#if !defined(VX1000_CLASSIMEMSY)
+                        "\
  addi     30, 30, 4"
+                        "\
  lwzu     31, 4(%3)"
+#else  /* VX1000_CLASSIMEMSY */
+                        "\
  lwzu     31, 4(30)"
+#endif /* VX1000_CLASSIMEMSY */
+                        "\
  stmw     30, 0(%4)"
+                        "\
  bdnz     8b"
+                        "\
  or       31, %3, %3"
+                        "\
  or       30, %1, %1"
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+                        "\
9:"
+                        "\
  mtspr    9, %0"      /* restore CTR */
+                        "\
" :
+                        "=""r"(tScratch1),        /* %0 */
+                        "=""r"(tScratch2),        /* %1 */
+                        "=""r"(tWords),           /* %2 */
+                        "=""r"(tSource),          /* %3 */
+                        "=""r"(tDest)             /* %4 */
+#if !defined(VX1000_CLASSIMEMSY)
+                       ,"=""r"(tBuf)              /* %5 */
+#endif /* !VX1000_CLASSIMEMSY */
+                        :
+                        "0"(tScratch1),           /* %0 */
+                        "1"(tScratch2),           /* %1 */
+                        "2"(tWords),              /* %2 */
+                        "3"(tSource),             /* %3 */
+                        "4"(tDest)                /* %4 */
+#if !defined(VX1000_CLASSIMEMSY)
+                       ,"5"(tBuf)                 /* %5 */
+#endif /* !VX1000_CLASSIMEMSY */
+                        : "30", "31"
+                      );
+                      tScratch1++; tScratch2++; tWords++; tSource++; tDest++; /* dummy usage to avoid compiler mis-optimisation */
+                      tScratch1++; tScratch2++; tWords++; tSource++; tDest++; /* dummy usage to avoid compiler mis-optimisation */
+                    }
+                    else
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+                    {
+                      __asm__ volatile
+                      (
+                        "\
  or.      %2, %2, %2"
+                        "\
  mfspr    %0, 9"      /* save CTR (because the compiler does not know that we use it) */
+                        "\
  addi     %4, %4, -4"
+                        "\
  beq      9f"
+                        "\
  addi     %3, %3, -4"
+                        "\
  mtspr    9, %2"      /* initialise HW-iterator */
+                        "\
8:"
+                        "\
 lwz %1, 4(%3)\
 addi %3, %3, 4" /* the original line "\
  lwzu     %1, 4(%3)" may produce "invalid register operand when updating" errors for some compiler settings */
+                        "\
  stwu     %1, 4(%4)"
+                        "\
  bdnz     8b"
+                        "\
9:"
+                        "\
  addi     %4, %4, 4"  /* post-increment the destination pointer */
+                        "\
  mtspr    9, %0"      /* restore CTR */
+                        "\
" ::
+                        /*"=" -- does not compile*/"r"(tScratch1),    /* %0 */
+                        /*"=" -- does not compile*/"r"(tScratch2),    /* %1 */
+                        /*"+" -- does not compile*/"r"(tWords),       /* %2 */
+                        /*"+" -- does not compile*/"r"(tSource),      /* %3 */
+                        /*"+" -- does not compile*/"r"(tDest)         /* %4 */
+                      );
+                      dstAddr = tDest;
+                    }
+                  }
+#else /* !VX1000_SUPPORT_OLDA7_ASMGNUVLE && !VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+                  if (evsync != 0)
+                  {
+                    while (sz != 0)
+                    {
+#if !defined(VX1000_CLASSIMEMSY)
+                      VX1000_STORE64(evsync, dstAddr, VX1000_ADDR_TO_PTR2U32(srcAddr)[0]); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                      dstAddr += 4UL;
+#else  /* VX1000_CLASSIMEMSY */
+                      VX1000_STORE64(evsync, srcAddr, VX1000_ADDR_TO_PTR2U32(srcAddr)[0]); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_CLASSIMEMSY */
+#if defined(VX1000_ARM_DSB)
+                      VX1000_ARM_DSB()
+#endif /* VX1000_ARM_DSB */
+                      srcAddr += 4UL;
+                      sz--;
+                    } /* while sz */
+                  }
+                  else
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+                  {
+                    src32 = VX1000_ADDR_TO_PTR2VU32(srcAddr);  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    dst32 = VX1000_ADDR_TO_PTR2VU32(dstAddr);  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    for (k = 0; k < sz; ++k) { dst32[k] = src32[k]; }
+                    dstAddr += (sz << 2);
+                  }
+#endif /* !VX1000_SUPPORT_OLDA7_ASMGNUVLE && !VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+                }
+              }
+              else
+              {
+#if defined(VX1000_OLDA_BENCHMARK)
+                byteTransferCount += sz << 2; /* Size of all transfers in DWORDs */
+#endif /* VX1000_OLDA_BENCHMARK */
+                /* TransferList entry consists of source address [31..2] and transfer size [1..0] counted in 32-bit-words */
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE) /* hint: (sz is in the range 1,2,3; data-type is DWORD) */
+                {
+                  register VX1000_UINT32 tWords = sz;
+                  register VX1000_UINT32 tSource = descriptor;
+                  register VX1000_UINT32 tDest = dstAddr;
+                  register VX1000_UINT32 tScratch1=0;  /* dummy initialisation needed only to avoid compiler warnings */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+                  if (evsync != 0)
+                  {
+#if !defined(VX1000_CLASSIMEMSY)
+                    register VX1000_UINT32 tBuf = dstAddr;
+                    dstAddr += (sz << 2);
+#endif /* !VX1000_CLASSIMEMSY */
+                    tDest = VX1000_ADDR_TO_PTR2U32(evsync); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    __asm__ volatile
+                    (
+                      "\
  e_cmpi   0, %1, 1"
+                      "\
  xor      %2, %1, %2"
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+                      "\
  or       %0, 31, 31"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  e_add16i 31, %4, -4"
+                      "\
  e_add16i %2, %2, -4"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  e_add16i 31, %2, -4"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  or       %2, 30, 30"
+                      "\
  beq      9f"
+                      "\
  e_cmpi   0, %3, 2"
+                      "\
  beq      8f"
+                      "\
7:"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  e_add16i 31, 31, 4"
+                      "\
  e_lwzu   30, 4(%2)"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  e_lwzu   30, 4(31)"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  e_stmw   30, 0(%3)"
+                      "\
8:"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  e_add16i 31, 31, 4"
+                      "\
  e_lwzu   30, 4(%2)"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  e_lwzu   30, 4(31)"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  e_stmw   30, 0(%3)"
+                      "\
9:"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  e_add16i 31, 31, 4"
+                      "\
  e_lwzu   30, 4(%2)"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  e_lwzu   30, 4(31)"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  e_stmw   30, 0(%3)"
+                      "\
  or       30, %2, %2"
+                      "\
  or       31, %0, %0"
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+                      "\
  or       %0, 30, 30"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  e_add16i 30, %4, -4"
+                      "\
  e_add16i %2, %2, -4"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  e_add16i 30, %2, -4"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  or       %2, 31, 31"
+                      "\
  beq      9f"
+                      "\
  e_cmpi   0, %3, 2"
+                      "\
  beq      8f"
+                      "\
7:"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  e_add16i 30, 30, 4"
+                      "\
  e_lwzu   31, 4(%2)"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  e_lwzu   31, 4(30)"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  e_stmw   30, 0(%3)"
+                      "\
8:"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  e_add16i 30, 30, 4"
+                      "\
  e_lwzu   31, 4(%2)"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  e_lwzu   31, 4(30)"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  e_stmw   30, 0(%3)"
+                      "\
9:"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  e_add16i 30, 30, 4"
+                      "\
  e_lwzu   31, 4(%2)"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  e_lwzu   31, 4(30)"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  e_stmw   30, 0(%3)"
+                      "\
  or       31, %2, %2"
+                      "\
  or       30, %0, %0"
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+                      "\
" :
+                      "=""r"(tScratch1),        /* %0 */
+                      "=""r"(tWords),           /* %1 */
+                      "=""r"(tSource),          /* %2 */
+                      "=""r"(tDest)             /* %3 */
+#if !defined(VX1000_CLASSIMEMSY)
+                     ,"=""r"(tBuf)              /* %4 */
+#endif /* !VX1000_CLASSIMEMSY */
+                      :
+                      "0"(tScratch1),           /* %0 */
+                      "1"(tWords),              /* %1 */
+                      "2"(tSource),             /* %2 */
+                      "3"(tDest)                /* %3 */
+#if !defined(VX1000_CLASSIMEMSY)
+                     ,"4"(tBuf)                 /* %4 */
+#endif /* !VX1000_CLASSIMEMSY */
+                      : "30", "31"
+                    );
+                    tScratch1++; tWords++; tSource++; tDest++; /* dummy usage to avoid compiler mis-optimisation */
+                    tScratch1++; tWords++; tSource++; tDest++; /* dummy usage to avoid compiler mis-optimisation */
+                  }
+                  else
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+                  {
+                    __asm__ volatile
+                    (
+                      "\
  e_cmpi   0, %1, 1"
+                      "\
  xor      %2, %1, %2"
+                      "\
  e_add16i %3, %3, -4"
+                      "\
  e_add16i %2, %2, -4"
+                      "\
  beq      9f"
+                      "\
  e_cmpi   0, %1, 2"
+                      "\
  beq      8f"
+                      "\
7:"
+                      "\
  e_lwzu   %0, 4(%2)"
+                      "\
  e_stwu   %0, 4(%3)"
+                      "\
8:"
+                      "\
  e_lwzu   %0, 4(%2)"
+                      "\
  e_stwu   %0, 4(%3)"
+                      "\
9:"
+                      "\
  e_lwzu   %0, 4(%2)"
+                      "\
  e_stwu   %0, 4(%3)"
+                      "\
  e_add16i %3, %3, 4"  /* post-increment the destination pointer */
+                      "\
" ::
+                      /*"=" -- does not compile*/"r"(tScratch1),    /* %0 */
+                      /*"+" -- does not compile*/"r"(tWords),       /* %1 */
+                      /*"+" -- does not compile*/"r"(tSource),      /* %2 */
+                      /*"+" -- does not compile*/"r"(tDest)         /* %3 */
+                    );
+                    dstAddr = tDest;
+                  }
+                }
+#elif defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE)
+                {
+                  register VX1000_UINT32 tWords = sz;
+                  register VX1000_UINT32 tSource = descriptor;
+                  register VX1000_UINT32 tDest = dstAddr;
+                  register VX1000_UINT32 tScratch1 = 0; /* dummy initialisation to force unique register allocation of the compiler */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+                  if (evsync != 0)
+                  {
+#if !defined(VX1000_CLASSIMEMSY)
+                    register VX1000_UINT32 tBuf = dstAddr;
+                    dstAddr += (sz << 2);
+#endif /* !VX1000_CLASSIMEMSY */
+                    tDest = evsync;
+                    __asm__ volatile
+                    (
+                      "\
  cmpi   0, %1, 1"
+                      "\
  xor    %2, %1, %2"
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+                      "\
  or     %0, 31, 31"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  addi   31, %4, -4"
+                      "\
  addi   %2, %2, -4"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  addi   31, %2, -4"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  or     %2, 30, 30"
+                      "\
  beq    9f"
+                      "\
  cmpi   0, %3, 2"
+                      "\
  beq    8f"
+                      "\
7:"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  addi   31, 31, 4"
+                      "\
  lwzu   30, 4(%2)"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  lwzu   30, 4(31)"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  stmw   30, 0(%3)"
+                      "\
8:"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  addi   31, 31, 4"
+                      "\
  lwzu   30, 4(%2)"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  lwzu   30, 4(31)"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  stmw   30, 0(%3)"
+                      "\
9:"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  addi   31, 31, 4"
+                      "\
  lwzu   30, 4(%2)"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  lwzu   30, 4(31)"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  stmw   30, 0(%3)"
+                      "\
  or     30, %2, %2"
+                      "\
  or     31, %0, %0"
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+                      "\
  or     %0, 30, 30"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  addi   30, %4, -4"
+                      "\
  addi   %2, %2, -4"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  addi   30, %2, -4"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  or     %2, 31, 31"
+                      "\
  beq    9f"
+                      "\
  cmpi   0, %3, 2"
+                      "\
  beq    8f"
+                      "\
7:"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  addi   30, 30, 4"
+                      "\
  lwzu   31, 4(%2)"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  lwzu   31, 4(30)"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  stmw   30, 0(%3)"
+                      "\
8:"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  addi   30, 30, 4"
+                      "\
  lwzu   31, 4(%2)"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  lwzu   31, 4(30)"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  stmw   30, 0(%3)"
+                      "\
9:"
+#if !defined(VX1000_CLASSIMEMSY)
+                      "\
  addi   30, 30, 4"
+                      "\
  lwzu   31, 4(%2)"
+#else  /* VX1000_CLASSIMEMSY */
+                      "\
  lwzu   31, 4(30)"
+#endif /* VX1000_CLASSIMEMSY */
+                      "\
  stmw   30, 0(%3)"
+                      "\
  or     31, %2, %2"
+                      "\
  or     30, %0, %0"
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+                      "\
" :
+                      "=""r"(tScratch1),        /* %0 */
+                      "=""r"(tWords),           /* %1 */
+                      "=""r"(tSource),          /* %2 */
+                      "=""r"(tDest)             /* %3 */
+#if !defined(VX1000_CLASSIMEMSY)
+                     ,"=""r"(tBuf)              /* %4 */
+#endif /* !VX1000_CLASSIMEMSY */
+                      :
+                      "0"(tScratch1),           /* %0 */
+                      "1"(tWords),              /* %1 */
+                      "2"(tSource),             /* %2 */
+                      "3"(tDest)                /* %3 */
+#if !defined(VX1000_CLASSIMEMSY)
+                     ,"4"(tBuf)                 /* %4 */
+#endif /* !VX1000_CLASSIMEMSY */
+                      : "30", "31"
+                    );
+                    tScratch1++; tWords++; tSource++; tDest++; /* dummy usage to avoid compiler mis-optimisation */
+                    tScratch1++; tWords++; tSource++; tDest++; /* dummy usage to avoid compiler mis-optimisation */
+                  }
+                  else
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+                  {
+                    __asm__ volatile
+                    (
+                      "\
  cmpi   0, %1, 1"
+                      "\
  xor    %2, %1, %2"
+                      "\
  addi   %3, %3, -4"
+                      "\
  addi   %2, %2, -4"
+                      "\
  beq    9f"
+                      "\
  cmpi   0, %1, 2"
+                      "\
  beq    8f"
+                      "\
7:"
+                      "\
  lwzu   %0, 4(%2)"
+                      "\
  stwu   %0, 4(%3)"
+                      "\
8:"
+                      "\
  lwzu   %0, 4(%2)"
+                      "\
  stwu   %0, 4(%3)"
+                      "\
9:"
+                      "\
  lwzu   %0, 4(%2)"
+                      "\
  stwu   %0, 4(%3)"
+                      "\
  addi   %3, %3, 4"  /* post-increment the destination pointer */
+                      "\
" :
+                      "=""r"(tScratch1),        /* %0 */
+                      "=""r"(tWords),           /* %1 */
+                      "=""r"(tSource),          /* %2 */
+                      "=""r"(tDest)             /* %3 */
+                      :
+                      "0"(tScratch1),           /* %0 */
+                      "1"(tWords),              /* %1 */
+                      "2"(tSource),             /* %2 */
+                      "3"(tDest)                /* %3 */
+                      : "0"
+                    );
+                    dstAddr = tDest;
+                    tScratch1++; tWords++; tSource++; /* dummy usage to avoid compiler mis-optimisation */
+                    tScratch1++; tWords++; tSource++; /* dummy usage to avoid compiler mis-optimisation */
+                  }
+                }
+#else /* !VX1000_SUPPORT_OLDA7_ASMGNUVLE && !VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+                srcAddr = (descriptor ^ sz);
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+                if (evsync != 0)
+                {
+                  while (sz != 0)
+                  {
+#if !defined(VX1000_CLASSIMEMSY)
+                    VX1000_STORE64(evsync, dstAddr, VX1000_ADDR_TO_PTR2U32(srcAddr)[0]); /* PRQA S 0303 */ /* PRQA S 0306 */ /* VX1000_ADDR_TO_PTR2XXX: cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    dstAddr += 4UL;
+#else  /* VX1000_CLASSIMEMSY */
+                    VX1000_STORE64(evsync, srcAddr, VX1000_ADDR_TO_PTR2U32(srcAddr)[0]); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_CLASSIMEMSY */
+                    VX1000_ARM_DSB()
+                    srcAddr += 4UL;
+                    sz--;
+                  } /* while sz */
+                }
+                else
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+                {
+                  src32 = VX1000_ADDR_TO_PTR2VU32(srcAddr);  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                  dst32 = VX1000_ADDR_TO_PTR2VU32(dstAddr);  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                  for (k = 0; k < sz; ++k) { dst32[k] = src32[k]; }
+                  dstAddr += (sz << 2);
+                }
+#endif /* !VX1000_SUPPORT_OLDA7_ASMGNUVLE && !VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+              }
+            }
+#if defined(VX1000_OLDA_FORCE_V8)
+#if defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR)
+            if (0U==descriptorCount)
+            {
+              descriptorCount = 0xFFFFU;  /* upon end of legacy mode, re-charge dummy count before switching back to v8 (there, events are finished explicitly by DONE command) */
+              useOldaVersion = 8;
+              descriptor = pTransferList[descriptorIndex];
+              descriptorIndex++;
+            }
+#endif /* VX1000_SUPPORT_OLDA8CMD_LEGACYVR */
+          }
+#endif /* VX1000_OLDA_FORCE_V8 */
+#endif /* VX1000_OLDA_FORCE_V7 || (VX1000_OLDA_FORCE_V8 && VX1000_SUPPORT_OLDA8CMD_LEGACYVR) */
+#if (!defined(VX1000_OLDA_FORCE_V7)) || (defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8))
+#if defined(VX1000_OLDA_FORCE_V8)
+          if (useOldaVersion == 6)
+          {
+#endif /* VX1000_OLDA_FORCE_V8 */
+            sz = (VX1000_UINT8)(descriptor >> (VX1000_OLDA_SIZE_OFFSET)) & ((1<<(VX1000_OLDA_SIZE_LENGTH))-1);
+            srcAddr = ( descriptor & (~(VX1000_OLDA_SIZE_MASK)) ) | (VX1000_OLDA_SIZE_REPLACEMENT);
+#if defined(VX1000_OLDA_BENCHMARK)
+            byteTransferCount += sz << (VX1000_WORDSIZESHIFT);
+#endif /* VX1000_OLDA_BENCHMARK */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+            if (evsync != 0)
+            {
+              while (sz != 0)
+              {
+#if !defined(VX1000_CLASSIMEMSY)
+                VX1000_STORE64(evsync, dstAddr, VX1000_ADDR_TO_PTR2U32(srcAddr)[0]); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                dstAddr += 4UL;
+#else  /* VX1000_CLASSIMEMSY */
+                VX1000_STORE64(evsync, srcAddr, VX1000_ADDR_TO_PTR2U32(srcAddr)[0]); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_CLASSIMEMSY */
+                VX1000_ARM_DSB()
+                srcAddr += 4UL;
+                sz--;
+              } /* while sz */
+            }
+            else
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+            {
+              /* note: XC2000 counts in 16bit words, all other targets in 32bit dWords */
+              volatile VX1000_UINTWS *srcW = VX1000_ADDR_TO_PTR2VUWS(srcAddr);  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+              volatile VX1000_UINTWS *dstW = VX1000_ADDR_TO_PTR2VUWS(dstAddr);  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+              for (k = 0; k < sz; ++k) { dstW[k] = srcW[k]; }
+              dstAddr += (sz << VX1000_WORDSIZESHIFT);
+            }
+#endif /* !VX1000_OLDA_FORCE_V7 */
+#endif /* !VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8)
+            if (0U==descriptorCount)
+            {
+              descriptorCount = 0xFFFFU;  /* upon end of legacy mode, re-charge dummy count before switching back to v8 (there, events are finished explicitly by DONE command) */
+              useOldaVersion = 8;
+              descriptor = pTransferList[descriptorIndex];
+              descriptorIndex++;
+            }
+          }
+          if (useOldaVersion == 8)
+          {
+#endif /* VX1000_SUPPORT_OLDA8CMD_LEGACYVR && VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_OLDA_FORCE_V8)
+            switch ((VX1000_UINT8)(descriptor & 0x000000FFUL))
+            {
+#if defined(VX1000_SUPPORT_OLDA8CMD_SP8N)
+              case 0:
+                for (sizeList = descriptor & 0x0000FF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+                {
+                  sz = ((pTransferList[descriptorIndex] >> 24) & 0x000000FFUL);
+                  ++descriptorIndex;
+                  dstAddr += sz;
+                }
+                break;
+#endif   /* VX1000_SUPPORT_OLDA8CMD_SP8N */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CP8N)
+              case 1:
+                {
+                  /*volatile VX1000_UINT8 *src8;*/
+                  srcAddr = descriptor;
+                  for (sizeList = descriptor & 0x0000FF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+                  {
+                    sz = ((pTransferList[descriptorIndex] >> 24) & 0x000000FFUL);
+                    srcAddr = (srcAddr & 0xFF000000UL) | (pTransferList[descriptorIndex] & 0x00FFFFFFUL);
+                    ++descriptorIndex;
+#if defined(VX1000_OLDA_BENCHMARK)
+                    byteTransferCount += sz << 0; /* Size of all transfers in BYTEs */
+#endif /* VX1000_OLDA_BENCHMARK */
+                    src8 = VX1000_ADDR_TO_PTR2VU8(srcAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    dst8 = VX1000_ADDR_TO_PTR2VU8(dstAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    for (k = 0; k < sz; ++k) { dst8[k] = src8[k]; }
+                    dstAddr += sz;
+                  }
+                break;
+                }
+#endif   /* VX1000_SUPPORT_OLDA8CMD_CP8N */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CP16N)
+              case 2:
+                {
+                  srcAddr = descriptor;
+                  for (sizeList = descriptor & 0x0000FF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+                  {
+                    sz = ((pTransferList[descriptorIndex] >> 24) & 0x000000FFUL);
+                    srcAddr = (srcAddr & 0xFF000000UL) | (pTransferList[descriptorIndex] & 0x00FFFFFEUL);
+                    ++descriptorIndex;
+#if defined(VX1000_OLDA_BENCHMARK)
+                    byteTransferCount += sz << 1; /* Size of all transfers in BYTEs */
+#endif /* VX1000_OLDA_BENCHMARK */
+                    {
+                      volatile VX1000_UINT16 *src16 = VX1000_ADDR_TO_PTR2VU16(srcAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                      volatile VX1000_UINT16 *dst16 = VX1000_ADDR_TO_PTR2VU16(dstAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                      for (k = 0; k < sz; ++k) { dst16[k] = src16[k]; }
+                    }
+                    dstAddr += (sz << 1);
+                  }
+                  break;
+                }
+#endif   /* VX1000_SUPPORT_OLDA8CMD_CP16N */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CP32N)
+              case 3:
+                {
+                  /*volatile VX1000_UINT32 *src32, *dst32;*/
+                  srcAddr = descriptor;
+                  for (sizeList = descriptor & 0x0000FF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+                  {
+                    sz = ((pTransferList[descriptorIndex] >> 24) & 0x000000FFUL);
+                    srcAddr = (srcAddr & 0xFF000000UL) | (pTransferList[descriptorIndex] & 0x00FFFFFCUL);
+                    ++descriptorIndex;
+#if defined(VX1000_OLDA_BENCHMARK)
+                    byteTransferCount += sz << 2; /* Size of all transfers in BYTEs */
+#endif /* VX1000_OLDA_BENCHMARK */
+                    src32 = VX1000_ADDR_TO_PTR2VU32(srcAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    dst32 = VX1000_ADDR_TO_PTR2VU32(dstAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    for (k = 0; k < sz; ++k) { dst32[k] = src32[k]; }
+                    dstAddr += (sz << 2);
+                  }
+                  break;
+                }
+#endif   /* VX1000_SUPPORT_OLDA8CMD_CP32N */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CP64N)
+              case 4:
+                {
+                  volatile VX1000_UINT64  *src64, *dst64;
+                  srcAddr = descriptor;
+                  for (sizeList = descriptor & 0x0000FF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+                  {
+                    sz = ((pTransferList[descriptorIndex] >> 24) & 0x000000FFUL);
+                    srcAddr = (srcAddr & 0xFF000000UL) | (pTransferList[descriptorIndex] & 0x00FFFFF8UL);
+                    ++descriptorIndex;
+#if defined(VX1000_OLDA_BENCHMARK)
+                    byteTransferCount += sz << 3; /* Size of all transfers in BYTEs */
+#endif /* VX1000_OLDA_BENCHMARK */
+                    src64 = VX1000_ADDR_TO_PTR2VU64(srcAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    dst64 = VX1000_ADDR_TO_PTR2VU64(dstAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    for (k = 0; k < sz; ++k) { dst64[k] = src64[k]; }
+                    dstAddr += (sz << 3);
+                  }
+                  break;
+                }
+#endif   /* VX1000_SUPPORT_OLDA8CMD_CP64N */
+              case 5: /* VX1000_SUPPORT_OLDA8CMD_DONE */
+                descriptorCount = 0;
+                break;
+#if defined(VX1000_SUPPORT_OLDA8CMD_SUBEVT)
+              case 6:
+                /* Trigger a sub-event so the VX1000 starts to fetch the existing data while the ECU in parallel prepares the remaining data */
+#if defined(VX1000_OLDA_OVERLOAD_DETECTION)
+                event->EventCounter += (descriptor >> 16) & 0x00000001UL; /* For the final event, increase the Event-Counter to detect Overruns */
+#endif /* VX1000_OLDA_OVERLOAD_DETECTION */
+                /* note that sub-events are NEVER used together with memsync-events so we do not need to support this combination here */
+#if defined(VX1000_TARGET_TRICORE)
+                if (VX1000_ECU_IS_AURIX()) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                {
+                  VX1000_MCREG_OCDS_TRIGS = ((descriptor >> 8) & 0x000000FFUL); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                }
+                else
+                {
+                  VX1000_MCREG_OCDS_TRIGS = (VX1000_UINT32)(1UL << ((descriptor >> 8) & 0x000000FFUL)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                }
+#elif defined(VX1000_OLDA_AUDMBR_REG_ADDR)
+                (VX1000_ADDR_TO_PTR2VU16(VX1000_OLDA_AUDMBR_REG_ADDR))[0] = ((descriptor >> 8) & 0x000000FFUL); /* PRQA S 0303 */ /* Cannot avoid violating MISRA rule 11.3 because manipulating the memory-mapped IO at the given address is a core feature of this module */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#elif defined(VX1000_OLDA_DTS_BASE_ADDR)
+                VX1000_ADD_MPC_TRIGS((descriptor >> 8) & 0x000000FFUL); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else  /* !VX1000_TARGET_TRICORE & !VX1000_OLDA_AUDMBR_REG_ADDR & !VX1000_OLDA_DTS_BASE_ADDR */
+                VX1000_ATOMIC_XOR32X2((/*(VX1000_UINT32)*/&gVX1000.OldaEventNumber), (VX1000_UINT32)(1UL << ((descriptor >> 8) & 0x000000FFUL)));
+#endif /* !VX1000_TARGET_TRICORE & !VX1000_OLDA_AUDMBR_REG_ADDR & !VX1000_OLDA_DTS_BASE_ADDR */
+                break;
+#endif   /* VX1000_SUPPORT_OLDA8CMD_SUBEVT */
+              /* case 7 is used exclusively by STIM */
+              case 8: /* VX1000_SUPPORT_OLDA8CMD_SPEC32N */
+                /* hint: bits 0x00400000UL an 0x00200000UL are still available for generic modifiers */
+                for (sizeList = descriptor & 0x0000FF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+                {
+                  VX1000_UINT32 alternDstAddr = dstAddr, inc = 4UL;
+                  if ((descriptor & 0x00800000UL) != 0UL) /* Store elsewhere instead of classic storage into OLDA buffer */
+                  {
+                    inc = 0UL;
+                    alternDstAddr = pTransferList[descriptorIndex];
+                    ++descriptorIndex;
+                  }
+                  switch ((descriptor >> 16) & 0x1FU)
+                  {
+                    case 0x00: VX1000_ADDR_TO_PTR2VU32(alternDstAddr)[0]  = pTransferList[descriptorIndex]; ++descriptorIndex;                                         break;   /* 32bit-constant from tool - overwrite *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x01: VX1000_ADDR_TO_PTR2VU32(alternDstAddr)[0] |= pTransferList[descriptorIndex]; ++descriptorIndex;                                         break;   /* 32bit-constant from tool - set bits  *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x02: VX1000_ADDR_TO_PTR2VU32(alternDstAddr)[0] &= pTransferList[descriptorIndex]; ++descriptorIndex;                                         break;   /* 32bit-constant from tool - clear bits *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x03: VX1000_ADDR_TO_PTR2VU32(alternDstAddr)[0] ^= pTransferList[descriptorIndex]; ++descriptorIndex;                                         break;   /* 32bit-constant from tool - toggle bits *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x04: VX1000_ADDR_TO_PTR2VU16(alternDstAddr)[0]  = (VX1000_UINT16)(0xFFFFUL & pTransferList[descriptorIndex]); ++descriptorIndex; inc >>= 1;  break;   /* 16bit-constant from tool - overwrite *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x05: VX1000_ADDR_TO_PTR2VU16(alternDstAddr)[0] |= (VX1000_UINT16)(0xFFFFUL & pTransferList[descriptorIndex]); ++descriptorIndex; inc >>= 1;  break;   /* 16bit-constant from tool - set bits  *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x06: VX1000_ADDR_TO_PTR2VU16(alternDstAddr)[0] &= (VX1000_UINT16)(0xFFFFUL & pTransferList[descriptorIndex]); ++descriptorIndex; inc >>= 1;  break;   /* 16bit-constant from tool - clear bits *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x07: VX1000_ADDR_TO_PTR2VU16(alternDstAddr)[0] ^= (VX1000_UINT16)(0xFFFFUL & pTransferList[descriptorIndex]); ++descriptorIndex; inc >>= 1;  break;   /* 16bit-constant from tool - toggle bits *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x08: VX1000_ADDR_TO_PTR2VU8( alternDstAddr)[0]  = (VX1000_UINT8)(0xFFUL & (descriptor >> 24)); inc >>= 2;                                    break;   /* 8bit-constant from tool - overwrite *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x09: VX1000_ADDR_TO_PTR2VU8( alternDstAddr)[0] |= (VX1000_UINT8)(0xFFUL & (descriptor >> 24)); inc >>= 2;                                    break;   /* 8bit-constant from tool - set bits  *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x0A: VX1000_ADDR_TO_PTR2VU8( alternDstAddr)[0] &= (VX1000_UINT8)(0xFFUL & (descriptor >> 24)); inc >>= 2;                                    break;   /* 8bit-constant from tool - clear bits *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x0B: VX1000_ADDR_TO_PTR2VU8( alternDstAddr)[0] ^= (VX1000_UINT8)(0xFFUL & (descriptor >> 24)); inc >>= 2;                                    break;   /* 8bit-constant from tool - toggle bits *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x0C: VX1000_ADDR_TO_PTR2VU8( alternDstAddr)[0] += (VX1000_UINT8)(0xFFUL & (descriptor >> 24)); inc >>= 2;                                    break;   /* 8bit-constant from tool - add *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x0D: VX1000_ADDR_TO_PTR2VU16(alternDstAddr)[0] += (VX1000_UINT16)(0xFFFFUL & (descriptor >> 24)); inc >>= 1;                                 break;   /* Add16 signed 8bit-constant from tool *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x0E: VX1000_ADDR_TO_PTR2VU32(alternDstAddr)[0] += ((descriptor >> 24) & 0x7FUL) - ((descriptor >> 24) & 0x80UL);                             break;   /* Add32 signed 8bit-constant from tool */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x0F: VX1000_ADDR_TO_PTR2VU32(alternDstAddr)[0] += pTransferList[descriptorIndex]; ++descriptorIndex;                                         break;   /* Add 32bit-constant from tool *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x10: VX1000_ADDR_TO_PTR2VU32(alternDstAddr)[0]  = extendedParameter;                                                                         break;   /* 32bit-constant from application *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_TARGET_TRICORE)
+                    case 0x11: VX1000_ADDR_TO_PTR2VU32(alternDstAddr)[0] = VX1000_ADDR_TO_PTR2VU32(alternDstAddr)[0]  = t0;                                            break;   /* 32bit-timestamp of call to VX1000_EVENT() */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else  /* !VX1000_TARGET_TRICORE */
+                    case 0x11: VX1000_ADDR_TO_PTR2VU32(alternDstAddr)[0] = t0;                                                                                         break;   /* 32bit-timestamp of call to VX1000_EVENT() */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* !VX1000_TARGET_TRICORE */
+                    case 0x12: VX1000_ADDR_TO_PTR2VU16(alternDstAddr)[0] = (VX1000_UINT16)(0xFFFFUL & extendedParameter); inc >>= 1;                                   break;   /* 16bit-constant from application */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_TARGET_TRICORE)
+                    case 0x13: VX1000_ADDR_TO_PTR2VU16(alternDstAddr)[0] = VX1000_ADDR_TO_PTR2VU16(alternDstAddr)[0] = (VX1000_UINT16)(0xFFFFUL & t0); inc >>= 1;      break;   /* 16bit-timestamp */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else  /* !VX1000_TARGET_TRICORE */
+                    case 0x13: VX1000_ADDR_TO_PTR2VU16(alternDstAddr)[0] = (VX1000_UINT16)(0xFFFFUL & t0); inc >>= 1;                                                  break;   /* 16bit-timestamp */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* !VX1000_TARGET_TRICORE */
+                    case 0x14: VX1000_ADDR_TO_PTR2VU8( alternDstAddr)[0] = (VX1000_UINT8)(0xFFUL & extendedParameter); inc >>= 2;                                      break;   /* 8bit-constant from application */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_TARGET_TRICORE)
+                    case 0x15: VX1000_ADDR_TO_PTR2VU8( alternDstAddr)[0] = VX1000_ADDR_TO_PTR2VU8(alternDstAddr)[0] = (VX1000_UINT8)(0xFFUL & t0); inc >>= 2;          break;   /* 8bit-timestamp */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else  /* !VX1000_TARGET_TRICORE */
+                    case 0x15: VX1000_ADDR_TO_PTR2VU8( alternDstAddr)[0] = (VX1000_UINT8)(0xFFUL & t0); inc >>= 2;                                                     break;   /* 8bit-timestamp */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* !VX1000_TARGET_TRICORE */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0 )
+                    case 0x16: if (evsync != 0) { VX1000_STORE64(evsync, alternDstAddr, pTransferList[descriptorIndex+1]); } ++descriptorIndex; inc = 0;               break;   /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x17: if (evsync != 0) { VX1000_STORE64(evsync, alternDstAddr, extendedParameter); } inc = 0;                                                 break;   /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x18: if (evsync != 0) { VX1000_STORE64(evsync, alternDstAddr, t0); } inc = 0;                                                                break;   /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    case 0x19: if (evsync != 0) { VX1000_STORE64(evsync, alternDstAddr, VX1000_CLOCK()); } inc = 0;                                                    break;   /* current 32bit-timestamp for internal profiling of different OLDA sequences */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+                    case 0x1A: VX1000_ADDR_TO_PTR2VU32(alternDstAddr)[0] = VX1000_CLOCK(); /* no special VX1000_TARGET_TRICORE-handling needed here */                 break;   /* current 32bit-timestamp for internal profiling of different OLDA sequences *//* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    default:   VX1000_ERRLOGGER(VX1000_ERRLOG_OLDA_UNIMPLSUB)                                                                                          break;
+                  }
+#if defined(VX1000_OLDA_BENCHMARK)
+                  byteTransferCount += inc; /* Size of all transfers in BYTEs */
+#endif /* VX1000_OLDA_BENCHMARK */
+                  dstAddr += inc;
+                }
+                break;
+              case 9: /* VX1000_SUPPORT_OLDA8CMD_JUMP */
+                switch ((descriptor >> 8) & 0xFFU)
+                {
+                  case 0x00U: descriptorIndex += (VX1000_UINT16)(((descriptor >> 16) & 0x7FFFUL) - ((descriptor >> 16) & 0x8000UL));                                   break; /* relative jump (+/-) to another descriptor */
+                  default:    VX1000_ERRLOGGER(VX1000_ERRLOG_OLDA_UNIMPLSUB)                                                                                           break;
+                }
+                break;
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0 ) /* #if defined(VX1000_SUPPORT_OLDA8CMD_SYNC32N) */
+              case 10:
+                srcAddr = descriptor;
+                for (sizeList = descriptor & 0x0000FF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+                {
+                  sz = ((pTransferList[descriptorIndex] >> 24) & 0x000000FFUL);
+                  srcAddr = (srcAddr & 0xFF000000UL) | (pTransferList[descriptorIndex] & 0x00FFFFFCUL);
+                  ++descriptorIndex;
+#if defined(VX1000_OLDA_BENCHMARK)
+                  byteTransferCount += sz << 2; /* Size of all transfers in BYTEs */
+#endif /* VX1000_OLDA_BENCHMARK */
+                  if (evsync != 0)
+                  {
+                    volatile VX1000_UINT32 *src = VX1000_ADDR_TO_PTR2VU32(srcAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    for (k = 0; k < sz; ++k)
+                    {
+#if !defined(VX1000_CLASSIMEMSY)
+                      VX1000_STORE64(evsync, dstAddr + (k << 2), src[k]); VX1000_ARM_DSB() /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else  /* VX1000_CLASSIMEMSY */
+                      VX1000_STORE64(evsync, srcAddr + (k << 2), src[k]); VX1000_ARM_DSB() /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_CLASSIMEMSY */
+                    }
+#if !defined(VX1000_CLASSIMEMSY)
+                    dstAddr += (sz << 2);
+#endif /* !VX1000_CLASSIMEMSY */
+                  }
+                }
+                break;
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */ /* #endif // VX1000_SUPPORT_OLDA8CMD_SYNC32N */
+#if defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR)
+              case 11:
+                useOldaVersion = (VX1000_UINT8)((descriptor & 0x00000F00UL) >> 8); /* interpret the rest of the descriptors as an older olda version */
+                descriptorCount = (VX1000_UINT16)(descriptor >> 16); /* the legacy olda version will have to handle n descriptors */
+                break;
+#endif /* VX1000_SUPPORT_OLDA8CMD_LEGACYVR */
+#if defined(VX1000_MEMCPY)
+              case 12: /* VX1000_OLDA8CMD_USRCPY */
+                {
+                  VX1000_UINT8 flags = (VX1000_UINT8)(0xFUL & (descriptor >> 20));
+                  srcAddr = descriptor;
+                  for (sizeList = descriptor & 0x000FFF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+                  {
+                    sz = ((pTransferList[descriptorIndex] >> 24) & 0x000000FFUL);
+                    srcAddr = (srcAddr & 0xFF000000UL) | (pTransferList[descriptorIndex] & 0x00FFFFFFUL);
+                    if ((flags & 0x1) != 0) { srcAddr = VX1000_ADDR_TO_PTR2VU32(srcAddr)[0]; } /* indirection */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                    ++descriptorIndex;
+#if defined(VX1000_OLDA_BENCHMARK)
+                    byteTransferCount += sz << 0; /* Size of all transfers in BYTEs */
+#endif /* VX1000_OLDA_BENCHMARK */
+                    VX1000_MEMCPY(VX1000_ADDR_TO_PTR2U8(dstAddr), VX1000_ADDR_TO_PTR2U8(srcAddr), sz << 0); /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because this callback function may be declared either with or without memory qualifiers by the user */
+                    dstAddr += sz;
+                  }
+                }
+                break;
+#endif /* VX1000_MEMCPY */
+              case 13:
+                switch ((descriptor & 0x00000F00UL) >> 8)
+                {
+                  case 0x0: VX1000_ENTER_SPINLOCK()                            break;
+                  case 0x1: VX1000_LEAVE_SPINLOCK()                            break;
+                  default:  VX1000_ERRLOGGER(VX1000_ERRLOG_OLDA_UNIMPLSUB)     break;
+                }
+                break;
+              /* cases 14..19 are used exclusively by STIM */
+#if defined(VX1000_ADDONS_DASDAQ_OLDACMD)
+              case 20:
+                VX1000_ADDONS_DASDAQ_OLDACMD(eventNumber, &descriptorIndex, &sizeList, &descriptor, &dstAddr);
+                break;
+#endif /* VX1000_ADDONS_DASDAQ_OLDACMD */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CALLJITA)
+              case 21:
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+                descriptorIndex += (VX1000_UINT16)((VX1000_ADDR_TO_PTR2OCB(pTransferList[descriptorIndex]))(dstAddr, t0, evsync)); /* PRQA S 0305 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else  /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+                descriptorIndex += (VX1000_UINT16)((VX1000_ADDR_TO_PTR2OCB(pTransferList[descriptorIndex]))(dstAddr, t0, 0UL)); /* PRQA S 0305 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+                break;
+#endif /* VX1000_SUPPORT_OLDA8CMD_CALLJITA */
+              /* case 22 used exclusively by STIM */
+              default:
+                VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,(sizeList), 0/*(src32)*/, 0/*(dst32)*/, 0/*(sz)*/, 0))  /* dummy accesses to prevent compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+                VX1000_ERRLOGGER(VX1000_ERRLOG_OLDA_UNIMPLCMD)
+                break;
+            }
+#endif /* VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8)
+          }
+#endif /* VX1000_SUPPORT_OLDA8CMD_LEGACYVR && VX1000_OLDA_FORCE_V8 */
+        } /* while descriptorCount*/
+#if !defined(VX1000_OLDA_FORCE_V8)
+#if defined(VX1000_OLDA_OVERLOAD_DETECTION)
+        event->EventCounter++; /* Increase the Event-Counter to detect Overruns */
+#endif /* VX1000_OLDA_OVERLOAD_DETECTION */
+
+        /* Trigger the VX1000 to copy the data */
+#if defined(VX1000_SUPPRESS_TRACE_SUPPORT) || defined(VX1000_TARGET_TRICORE)
+#if defined(VX1000_OLDA_AUDMBR_REG_ADDR)
+        if (eventNumber < 15) /* prevent triggering false special or DAQ events */
+#else  /* !VX1000_OLDA_AUDMBR_REG_ADDR */
+        if (eventNumber < 31) /* prevent triggering false special or DAQ events */
+#endif /* !VX1000_OLDA_AUDMBR_REG_ADDR */
+        {
+#if defined(VX1000_TARGET_XC2000)
+          gVX1000.OldaEventNumber ^= (VX1000_UINT32)(1UL << eventNumber);
+          gVX1000.CalPtr          ^= (VX1000_UINT32)(1UL << eventNumber);
+#elif defined(VX1000_TARGET_TRICORE)
+          if (VX1000_ECU_IS_AURIX()) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          {
+            VX1000_MCREG_OCDS_TRIGS = (eventNumber); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          else
+          {
+            VX1000_MCREG_OCDS_TRIGS = (1UL << eventNumber); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+#elif defined(VX1000_OLDA_AUDMBR_REG_ADDR)
+          (VX1000_ADDR_TO_PTR2VU16(VX1000_OLDA_AUDMBR_REG_ADDR))[0] = (1U << eventNumber); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#elif defined(VX1000_OLDA_DTS_BASE_ADDR)
+          VX1000_ADD_MPC_TRIGS(eventNumber); /* PRQA S 0303 */ /* PRQA S 0306 */ /* macro expansion contains VX1000_ADDR_TO_PTR2XXX: cannot avoid violating MISRA rule 11.3 because the fix HW address of the peripheral (it\'s not an "allocated object") is an integer while we need a pointer to access its value */
+#else  /* !VX1000_TARGET_XC2000 & !VX1000_TARGET_TRICORE & !VX1000_OLDA_AUDMBR_REG_ADDR & !VX1000_OLDA_DTS_BASE_ADDR */
+          VX1000_ATOMIC_XOR32X2((/*(VX1000_UINT32)*/&gVX1000.OldaEventNumber), (VX1000_UINT32)(1UL << eventNumber));
+#endif /* !VX1000_TARGET_XC2000 & !VX1000_TARGET_TRICORE & !VX1000_OLDA_AUDMBR_REG_ADDR & !VX1000_OLDA_DTS_BASE_ADDR */
+        }
+#endif /* VX1000_SUPPRESS_TRACE_SUPPORT || VX1000_TARGET_TRICORE */
+#endif /* !VX1000_OLDA_FORCE_V8 */
+#if defined(VX1000_OLDA_BENCHMARK)
+/* #if VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT */ /* This check has been removed in order to avoid a MISRA warning */
+        if (eventNumber < (VX1000_OLDA_BENCHMARK_CNT)) /* trace event numbers may be in the range 0..511 ! */
+/* #endif */ /* VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT */
+        {
+          gVX1000_OLDA_Duration[eventNumber] = (VX1000_CLOCK()) - t0; /* Timing measurement */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+#endif /* VX1000_OLDA_BENCHMARK */
+      } /* if descriptorCount */
+    } /* if eventNumber */
+  } /* if OLDA */
+#if (!defined(VX1000_OLDA_FORCE_V8)) || (defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8))
+#if defined(VX1000_SUPPORT_OLDA8CMD_LEGACYVR) && defined(VX1000_OLDA_FORCE_V8)
+  if (useOldaVersion < 8)
+#endif /* VX1000_SUPPORT_OLDA8CMD_LEGACYVR && VX1000_OLDA_FORCE_V8 */
+  {
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+    if (evsync != 0)
+    {
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE) || defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE)
+      {
+        register VX1000_UINT32 tData = t0;
+        register VX1000_UINT32 tAddr = VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp);
+        register VX1000_UINT32 tEventNumber = eventNumber;
+        register VX1000_UINT32 tPtr = evsync;
+        register VX1000_UINT32 tScratch = 0; /* dummy initialisation to force unique register allocation of the compiler */
+        __asm__ volatile
+        (
+          "\
  or       %0, 30, 30"
+          "\
  or       30, %1, %1"
+          "\
  or       %1, 31, 31"
+          "\
  or       31, %2, %2"
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE)
+          "\
  e_stmw   30, 0(%3)"
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+          "\
  e_add16i 31, 31, -4"
+          "\
  or       30, %4, %4"
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+          "\
  e_add16i 30, 30, -4"
+          "\
  or       31, %4, %4"
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+          "\
  e_stmw   30, 0(%3)"
+#elif defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE)
+          "\
  stmw     30, 0(%3)"
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+          "\
  addi     31, 31, -4"
+          "\
  or       30, %4, %4"
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+          "\
  addi     30, 30, -4"
+          "\
  or       31, %4, %4"
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+          "\
  stmw     30, 0(%3)"
+#endif /* VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+          "\
  or       31, %1, %1"
+          "\
  or       30, %0, %0"
+          "\
" :
+          "=""r"(tScratch),     /* %0 */
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+          "=""r"(tData),        /* %1 */
+          "=""r"(tAddr),        /* %2 */
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+          "=""r"(tAddr),        /* %1 */
+          "=""r"(tData),        /* %2 */
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+          "=""r"(tPtr),         /* %3 */
+          "=""r"(tEventNumber)  /* %4 */
+          :
+          "0"(tScratch),        /* %0 */
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+          "1"(tData),           /* %1 */
+          "2"(tAddr),           /* %2 */
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+          "1"(tAddr),           /* %1 */
+          "2"(tData),           /* %2 */
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+          "3"(tPtr),            /* %3 */
+          "4"(tEventNumber)     /* %4 */
+          : "30", "31"
+        );
+        tScratch++; tData++; tAddr++; tPtr++; tEventNumber++;/* dummy usage to avoid compiler mis-optimisation */
+        tScratch++; tData++; tAddr++; tPtr++; tEventNumber++;/* dummy usage to avoid compiler mis-optimisation */
+      }
+#else /* !VX1000_SUPPORT_OLDA7_ASMxxx */
+      VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp), t0); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_TARGET_TRICORE)
+      VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp), t0); /* on TriCore we have to write this four   */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp), t0); /* times to ensure that both time and      */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp), t0); /* address are not run over by eventNumber */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_TARGET_TRICORE */
+      VX1000_ARM_DSB()
+      VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventNumber), eventNumber); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      VX1000_ARM_DSB()
+#endif /* !VX1000_SUPPORT_OLDA7_ASMxxx */
+    }
+#else /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+    /* change request 2016-04-22 visgn: the events shall ALWAYS be triggered via memSync, so trigger normal trace event ONLY if memSync is completely disabled */
+#if !defined(VX1000_SUPPRESS_TRACE_SUPPORT)
+#if defined(VX1000_TARGET_TRICORE)
+    gVX1000.EventTimestamp = t0;       /* Increase probability that timestamp reaches VX before eventNumber does because TriCore has multiple parallel trace FIFOs */
+#endif /* VX1000_TARGET_TRICORE */
+    gVX1000.EventNumber = eventNumber; /* Had been removed due to EM00034754 but was re-added due to EM00035042; as interims workaround for FW 1.8 it is configurable now via VX1000_SUPPRESS_TRACE_SUPPORT -- On V850/RH850, mailbox polling is so slow that this must be disabled */
+    VX1000_ARM_DSB()
+#endif /* !VX1000_SUPPRESS_TRACE_SUPPORT */
+#endif /* !VX1000_MEMSYNC_TRIGGER_COUNT */
+  }
+#endif /* !VX1000_OLDA_FORCE_V8 | VX1000_SUPPORT_OLDA8CMD_LEGACYVR */
+#if defined(VX1000_OLDA_BENCHMARK)
+  if (eventNumber < (VX1000_OLDA_BENCHMARK_CNT))
+  {
+#if defined(VX1000_OLDA_FORCE_V8)
+    gVX1000_OLDA_TransferSize[eventNumber] += byteTransferCount; /* size of all transfers in bytes */
+#elif defined(VX1000_TARGET_XC2000) && (!defined(VX1000_OLDA_FORCE_V7))
+    gVX1000_OLDA_TransferSize[eventNumber] += byteTransferCount >> 1; /* size of all transfers in words */
+#else  /* VX1000_OLDA_FORCE_V7 */
+    gVX1000_OLDA_TransferSize[eventNumber] += (byteTransferCount + 2UL) >> 2; /* rounded size of all transfers in DWORDs */
+#endif  /* VX1000_OLDA_FORCE_V7 */
+  }
+#endif /* VX1000_OLDA_BENCHMARK */
+  return;
+}
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE)
+/* restore the optimisation level to the user-selected value (only available on the HighTec branch --> only activate when VLE is used) */
+#pragma GCC pop_options
+#endif /* VX1000_SUPPORT_OLDA7_ASMGNUVLE */
+
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0) && (!defined(VX1000_OLDA_FORCE_V8))
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OldaSpecialEvent                                                                                     */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    eventNumber E [0,2^32)                                                                                      */
+/*                Validity automatically ensured by data type.                                                                */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_Init() must have been called.                                                                        */
+/* Precondition2: The MMU must be programmed such that the source memory and the destination memory are visible.              */
+/* Precondition3: The MPU must be programmed such that the source memory is readable and the destination memory is writeable. */
+/* Description:   Trigger a special event to transmit 32bit eventNumber to the tool.                                          */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE)
+/* force the optimisation level to >0/DEBUG because in O0 the parameters are passed on the stack and the assembly code would crash */
+/* Note: this pragma is only available on the HighTec branch --> only activate the feature when VLE is used */
+#pragma GCC push_options
+#pragma GCC optimize ("O3")
+#endif /* VX1000_SUPPORT_OLDA7_ASMGNUVLE */
+void VX1000_SUFFUN(vx1000_OldaSpecialEvent)( VX1000_UINT32 eventNumber )
+{
+  VX1000_UINT32 evsync;
+  {
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 1)
+    volatile VX1000_UINT32 *memSyncTrigPtr = VX1000_ADDR_TO_PTR2VU32(gVX1000.MemSyncTrigPtr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    VX1000_UINT8 evprop = VX1000_CURRENT_CORE_IDX();
+    if (evprop >= (VX1000_MEMSYNC_TRIGGER_COUNT)) /* PRQA S 3356 */ /* PRQA S 3359 */ /* cannot avoid violating MISRA rule 13.7 because this logical operation/control expression is actually an assertion that by design must always evaluate to FALSE  */
+    { /* PRQA S 3201 */ /* cannot avoid violating MISRA rule 14.1 because this block contains code to handle an error supposed never to occur */
+      evprop = 0;
+      VX1000_ERRLOGGER(VX1000_ERRLOG_TOO_MANY_CORES)
+    }
+    evsync = memSyncTrigPtr[evprop];
+#else /* VX1000_MEMSYNC_TRIGGER_COUNT <= 1 */
+    evsync = gVX1000.MemSyncTrigPtr;
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT <= 1 */
+    evsync = (evsync + 0x0C) & ~7UL;   /* seek MemSync_1 but fall back to MemSync_0 if odd */
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE) || defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE)
+    {
+      register VX1000_UINT32 tData = (VX1000_UINT32)VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      register VX1000_UINT32 tAddr = VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      register VX1000_UINT32 tEventNumber = eventNumber;
+      register VX1000_UINT32 tPtr = evsync;
+      register VX1000_UINT32 tScratch = 0; /* dummy initialisation to force unique register allocation of the compiler */
+      __asm__ volatile
+      (
+        "\
  or       %0, 30, 30"
+        "\
  or       30, %1, %1"
+        "\
  or       %1, 31, 31"
+        "\
  or       31, %2, %2"
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE)
+        "\
  e_stmw   30, 0(%3)"
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+        "\
  e_add16i 31, 31, -4"
+        "\
  or       30, %4, %4"
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+        "\
  e_add16i 30, 30, -4"
+        "\
  or       31, %4, %4"
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+        "\
  e_stmw   30, 0(%3)"
+#elif defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE)
+        "\
  stmw     30, 0(%3)"
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+        "\
  addi     31, 31, -4"
+        "\
  or       30, %4, %4"
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+        "\
  addi     30, 30, -4"
+        "\
  or       31, %4, %4"
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+        "\
  stmw     30, 0(%3)"
+#endif /* VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+        "\
  or       31, %1, %1"
+        "\
  or       30, %0, %0"
+        "\
" :
+        "=""r"(tScratch),     /* %0 */
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+        "=""r"(tData),        /* %1 */
+        "=""r"(tAddr),        /* %2 */
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+        "=""r"(tAddr),        /* %1 */
+        "=""r"(tData),        /* %2 */
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+        "=""r"(tPtr),         /* %3 */
+        "=""r"(tEventNumber)  /* %4 */
+        :
+        "0"(tScratch),        /* %0 */
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+        "1"(tData),           /* %1 */
+        "2"(tAddr),           /* %2 */
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+        "1"(tAddr),           /* %1 */
+        "2"(tData),           /* %2 */
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+        "3"(tPtr),            /* %3 */
+        "4"(tEventNumber)     /* %4 */
+        : "30", "31"
+      );
+      tScratch++; tData++; tAddr++; tPtr++; tEventNumber++;/* dummy usage to avoid compiler mis-optimisation */
+      tScratch++; tData++; tAddr++; tPtr++; tEventNumber++;/* dummy usage to avoid compiler mis-optimisation */
+    }
+#else /* !VX1000_SUPPORT_OLDA7_ASMxxx */
+    VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp), VX1000_CLOCK()); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_TARGET_TRICORE)
+    VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp), VX1000_CLOCK()); /* on TriCore we have to write this four */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp), VX1000_CLOCK()); /* times to ensure that both time and */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp), VX1000_CLOCK()); /* address are not run over by eventnumber */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_TARGET_TRICORE */
+    VX1000_ARM_DSB()
+    VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventNumber), eventNumber); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    VX1000_ARM_DSB()
+#endif /* !VX1000_SUPPORT_OLDA7_ASMxxx */
+  }
+}
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE)
+/* restore the optimisation level to the user-selected value (only available on the HighTec branch --> only activate when VLE is used) */
+#pragma GCC pop_options
+#endif /* VX1000_SUPPORT_OLDA7_ASMGNUVLE */
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT & !VX1000_OLDA_FORCE_V8 */
+
+#if defined(VX1000_STIM_BY_OLDA)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OldaStimRequestEvent                                                                                 */
+/* API name:      VX1000_STIM_REQUEST_EVENT (internal)                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    eventNumber E [0,gVX1000.Olda.EventCount)                                                                   */
+/*                Validity ensured by internal silent abort.                                                                  */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_OldaInit() must have been called.                                                                    */
+/* Description:   Sends an event without copying any data (the associated STIM data is handled later by vx1000_StimTransfer). */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+#if defined(VX1000_OLDA_FORCE_V8)
+void VX1000_SUFFUN(vx1000_OldaStimRequestEvent)( VX1000_UINT16 eventNumber ) /* -- TODO: exploit vx1000_OldaEvent for this */
+#else  /* !VX1000_OLDA_FORCE_V8 */
+void VX1000_SUFFUN(vx1000_OldaStimRequestEvent)( VX1000_UINT8 eventNumber )
+#endif /* !VX1000_OLDA_FORCE_V8 */
+{
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+  volatile VX1000_UINT32 *pTransferList = VX1000_ADDR_TO_PTR2VU32(gVX1000.Olda.TransferList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 1)
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+  VX1000_UINT32 evsync = 0;
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+  VX1000_UINT32 t0 = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+
+  if ((gVX1000.Olda.Running == 1) && (gVX1000.Olda.MagicId == VX1000_OLDA_MAGIC))
+  {
+    /* OLDA is running */
+    if (eventNumber < gVX1000.Olda.EventCount)
+    {
+      /* eventNumber is valid */
+      VX1000_OLDA_EVENT_T *pEventList = VX1000_ADDR_TO_PTR2OE(gVX1000.Olda.EventList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+      /* The existence of a first dummy descriptor informs the AppDriver that the FW despite memSync requests classic OLDA event triggers */
+      if (pTransferList[ pEventList[eventNumber].TransferIndex ] != 0x00000000UL)
+      {
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 1)
+        volatile VX1000_UINT32 *memSyncTrigPtr = VX1000_ADDR_TO_PTR2VU32(gVX1000.MemSyncTrigPtr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        VX1000_UINT8 evprop = VX1000_CURRENT_CORE_IDX();
+        if (evprop >= (VX1000_MEMSYNC_TRIGGER_COUNT)) /* PRQA S 3356 */ /* PRQA S 3359 */ /* cannot avoid violating MISRA rule 13.7 because this logical operation/control expression is actually an assertion that by design must always evaluate to FALSE  */
+        { /* PRQA S 3201 */ /* cannot avoid violating MISRA rule 14.1 because this block contains code to handle an error supposed never to occur */
+          evprop = 0;
+          VX1000_ERRLOGGER(VX1000_ERRLOG_TOO_MANY_CORES)
+        }
+        evsync = memSyncTrigPtr[evprop];
+#else /* VX1000_MEMSYNC_TRIGGER_COUNT <= 1 */
+        evsync = gVX1000.MemSyncTrigPtr;
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT <= 1 */
+        evsync = (evsync + 0x0C) & ~7UL;   /* seek MemSync_1 but fall back to MemSync_0 if odd */
+      }
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+#if !defined(VX1000_STIM_FORCE_V1)
+      /* Take an individual copy of the timestamp for each event */
+      pEventList[eventNumber].EventTimestamp = t0;
+#else /* VX1000_STIM_FORCE_V1 */
+      /* Do NOT copy the timestamp in this case, as the gVX1000.EventTimestamp  */
+      /* field is used to store the location of the first timestamp in the OLDA */
+      /* buffer. The timestamp is not explicitly needed for stim request events */
+#endif /* VX1000_STIM_FORCE_V1 */
+#if defined(VX1000_OLDA_OVERLOAD_DETECTION)
+      pEventList[eventNumber].EventCounter += 2; /* Increase the Event-Counter by two for Overrun detection */
+#endif /* VX1000_OLDA_OVERLOAD_DETECTION */
+
+      /* Trigger the VX1000 to copy the data */
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+      if (evsync != 0)
+      {
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE) || defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE)
+        {
+          register VX1000_UINT32 tData = t0;
+          register VX1000_UINT32 tAddr = VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp);
+          register VX1000_UINT32 tEventNumber = eventNumber;
+          register VX1000_UINT32 tPtr = evsync;
+          register VX1000_UINT32 tScratch = 0; /* dummy initialisation to force unique register allocation of the compiler */
+          __asm__ volatile
+          (
+            "\
  or       %0, 30, 30"
+            "\
  or       30, %1, %1"
+            "\
  or       %1, 31, 31"
+            "\
  or       31, %2, %2"
+#if defined(VX1000_SUPPORT_OLDA7_ASMGNUVLE)
+            "\
  e_stmw   30, 0(%3)"
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+            "\
  e_add16i 31, 31, -4"
+            "\
  or       30, %4, %4"
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+            "\
  e_add16i 30, 30, -4"
+            "\
  or       31, %4, %4"
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+            "\
  e_stmw   30, 0(%3)"
+#elif defined(VX1000_SUPPORT_OLDA7_ASMGNUBOOKE)
+            "\
  stmw     30, 0(%3)"
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+            "\
  addi     31, 31, -4"
+            "\
  or       30, %4, %4"
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+            "\
  addi     30, 30, -4"
+            "\
  or       31, %4, %4"
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+            "\
  stmw     30, 0(%3)"
+#endif /* VX1000_SUPPORT_OLDA7_ASMGNUBOOKE */
+            "\
  or       31, %1, %1"
+            "\
  or       30, %0, %0"
+            "\
" :
+            "=""r"(tScratch),     /* %0 */
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+            "=""r"(tData),        /* %1 */
+            "=""r"(tAddr),        /* %2 */
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+            "=""r"(tAddr),        /* %1 */
+            "=""r"(tData),        /* %2 */
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+            "=""r"(tPtr),         /* %3 */
+            "=""r"(tEventNumber)  /* %4 */
+            :
+            "0"(tScratch),        /* %0 */
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+            "1"(tData),           /* %1 */
+            "2"(tAddr),           /* %2 */
+#else  /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+            "1"(tAddr),           /* %1 */
+            "2"(tData),           /* %2 */
+#endif /* !VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+            "3"(tPtr),            /* %3 */
+            "4"(tEventNumber)     /* %4 */
+            : "30", "31"
+          );
+          tScratch++; tData++; tAddr++; tPtr++; tEventNumber++;/* dummy usage to avoid compiler mis-optimisation */
+          tScratch++; tData++; tAddr++; tPtr++; tEventNumber++;/* dummy usage to avoid compiler mis-optimisation */
+        }
+#else /* !VX1000_SUPPORT_OLDA7_ASMxxx */
+        VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp), t0); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_TARGET_TRICORE)
+        VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp), t0); /* on TriCore we have to write this four */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp), t0); /* times to ensure that both time and */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventTimestamp), t0); /* address are not run over by eventnumber */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_TARGET_TRICORE */
+#if defined(VX1000_ARM_DSB)
+        VX1000_ARM_DSB()
+#endif /* VX1000_ARM_DSB */
+        VX1000_STORE64(evsync, VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.EventNumber), eventNumber); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_ARM_DSB)
+        VX1000_ARM_DSB()
+#endif /* VX1000_ARM_DSB */
+#endif /* !VX1000_SUPPORT_OLDA7_ASMxxx */
+      }
+      else
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+      {
+        gVX1000.EventTimestamp = t0;
+#if defined(VX1000_SUPPRESS_TRACE_SUPPORT) || defined(VX1000_TARGET_TRICORE)
+#if defined(VX1000_OLDA_AUDMBR_REG_ADDR)
+        if (eventNumber < 15) /* prevent triggering false special or DAQ events */
+#else  /* !VX1000_OLDA_AUDMBR_REG_ADDR */
+        if (eventNumber < 31) /* prevent triggering false special or DAQ events */
+#endif /* !VX1000_OLDA_AUDMBR_REG_ADDR */
+        {
+#if defined(VX1000_TARGET_TRICORE)
+          if (VX1000_ECU_IS_AURIX()) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          {
+            VX1000_MCREG_OCDS_TRIGS = (eventNumber); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          else
+          {
+            VX1000_MCREG_OCDS_TRIGS = (1UL << eventNumber); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+#elif defined(VX1000_OLDA_AUDMBR_REG_ADDR)
+          (VX1000_ADDR_TO_PTR2VU16(VX1000_OLDA_AUDMBR_REG_ADDR))[0] = (1U << eventNumber); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#elif defined(VX1000_OLDA_DTS_BASE_ADDR)
+          VX1000_ADD_MPC_TRIGS(eventNumber); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#elif defined(VX1000_TARGET_XC2000)
+          gVX1000.OldaEventNumber ^= (VX1000_UINT32)(1UL << eventNumber);
+          gVX1000.CalPtr          ^= (VX1000_UINT32)(1UL << eventNumber);
+#else  /* !VX1000_TARGET_TRICORE & !VX1000_TARGET_XC2000 & !VX1000_OLDA_AUDMBR_REG_ADDR & !VX1000_OLDA_DTS_BASE_ADDR */
+          VX1000_ATOMIC_XOR32X2((/*(VX1000_UINT32)*/&gVX1000.OldaEventNumber), (VX1000_UINT32)(1UL << eventNumber));
+#endif /* !VX1000_TARGET_TRICORE & !VX1000_TARGET_XC2000 & !VX1000_OLDA_AUDMBR_REG_ADDR & !VX1000_OLDA_DTS_BASE_ADDR */
+        }
+#endif /* VX1000_SUPPRESS_TRACE_SUPPORT || VX1000_TARGET_TRICORE */
+#if !defined(VX1000_SUPPRESS_TRACE_SUPPORT)
+#if defined(VX1000_TARGET_TRICORE)
+        gVX1000.EventTimestamp = t0;       /* Increase probability that timestamp reaches VX before eventNumber does because TriCore has multiple parallel trace FIFOs */
+#endif /* VX1000_TARGET_TRICORE */
+        gVX1000.EventNumber = eventNumber;
+#if defined(VX1000_ARM_DSB)
+        VX1000_ARM_DSB()
+#endif /* VX1000_ARM_DSB */
+#endif /* !VX1000_SUPPRESS_TRACE_SUPPORT */
+      }
+    } /* eventNumber valid */
+  } /* OLDA running */
+}
+
+#endif /* VX1000_STIM_BY_OLDA */
+
+#endif /* VX1000_OLDA */
+
+
+#if defined(VX1000_STIM)
+
+#if defined(VX1000_STIM_FORCE_V1)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassCheckCounters                                                                                  */
+/* API name:      None                                                                                                        */
+/* Return value:  1 if the counters are consistent with new data available                                                    */
+/*                2 if no new data are available                                                                              */
+/* Parameter1:    eventNumber E [0,gVX1000.Olda.EventCount)                                                                   */
+/* Precondition1: stim_event must be a valid stim event in the range above                                                    */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Description:   Checks whether new stim data have been copied into the ECU                                                  */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassCheckCounters)( VX1000_UINT8 stim_event )
+{
+  VX1000_UINT8 retVal = VX1000_STIM_RET_TIMEOUT;
+
+  if ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].EventType == VX1000_BYPASS_TYPE_DIRECT)
+  {
+    if ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Ctr
+    ==  (VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].RqCtr)
+    {
+      retVal = VX1000_STIM_RET_SUCCESS;
+    }
+  }
+#if defined(VX1000_STIM_BY_OLDA)
+  else
+  {
+    retVal = VX1000_SUFFUN(vx1000_BypassCheckBuffer)(stim_event);
+  }
+#endif /* VX1000_STIM_BY_OLDA */
+
+  return retVal;
+}
+#endif /* VX1000_STIM_FORCE_V1 */
+
+#if defined(VX1000_STIM_BY_OLDA)
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_StimTransfer                                                                                         */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    eventNumber E [0,gVX1000.Olda.EventCount)                                                                   */
+/*                Validity ensured by internal silent abort. // or: {internal assertion, caller }.                            */
+/* Preemption:    This function must not be interrupted by any vx1000_* function.                                             */
+/*                This function should not interrupt and should not be interrupted by code that reads the stimulation data.   */
+/* Termination:   May leave the destination data in an inconsistent state.                                                    */
+/*                Internal data stays valid, no problems on reactivation.                                                     */
+/* Precondition1: vx1000_OldaInit() must have been called successfully.                                                       */
+/* Precondition2: The MMU must be programmed such that the source memory and the destination memory are visible.              */
+/* Precondition3: The MPU must be programmed such that the source memory is readable and the destination memory is writeable. */
+/* Description:   Processes all transfer descriptors assigned to parameter1, copies data from olda buffer to the destinations.*/
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+#if defined(VX1000_OLDA_FORCE_V8)
+static void VX1000_SUFFUN(vx1000_StimTransfer)( VX1000_UINT16 eventNumber );
+static void VX1000_SUFFUN(vx1000_StimTransfer)( VX1000_UINT16 eventNumber ) /* -- TODO: try to exploit vx1000_OldaEvent for this */
+#else  /* !VX1000_OLDA_FORCE_V8 */
+static void VX1000_SUFFUN(vx1000_StimTransfer)( VX1000_UINT8 eventNumber );
+static void VX1000_SUFFUN(vx1000_StimTransfer)( VX1000_UINT8 eventNumber )
+#endif /* !VX1000_OLDA_FORCE_V8 */
+{
+  VX1000_UINT32 srcAddr, *pTransferList = VX1000_ADDR_TO_PTR2U32(gVX1000.Olda.TransferList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  VX1000_OLDA_EVENT_T VX1000_DECL_PTR *event;
+  volatile VX1000_UINT8 *src8;
+  VX1000_UINT32 descriptor;
+  VX1000_UINT16 descriptorIndex;
+  VX1000_UINT8 sz;
+  VX1000_UINT32 k;
+#if defined(VX1000_OLDA_FORCE_V7)
+  VX1000_UINT8 sizeListIndex = 0;
+#endif /* VX1000_OLDA_FORCE_V7 */
+#if defined(VX1000_OLDA_FORCE_V7) || defined(VX1000_OLDA_FORCE_V8)
+  VX1000_UINT32 sizeList = 0; /* just a dummy initialisation to avoid compiler warnings. Actually sizeList IS initialised to the correct value in the first iteration because j is initialised to zero */
+#endif /* VX1000_OLDA_FORCE_V7 || VX1000_OLDA_FORCE_V8 */
+  VX1000_UINT16 descriptorCount;
+#if defined(VX1000_OLDA_BENCHMARK) /* Timing measurement */
+  VX1000_UINT32 t0;
+
+  t0 = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_OLDA_BENCHMARK */
+  if ((gVX1000.Olda.Running == 1) && (gVX1000.Olda.MagicId == VX1000_OLDA_MAGIC))
+  {
+    /* OLDA is running */
+    if (eventNumber < gVX1000.Olda.EventCount)
+    {
+      /* eventNumber is valid */
+      VX1000_OLDA_EVENT_T *pEventList = VX1000_ADDR_TO_PTR2OE(gVX1000.Olda.EventList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      event = &(pEventList[eventNumber]);
+      srcAddr = event->TransferDest; /* yes: srcAddr is loaded from dst entry for stim */
+      descriptorCount = event->TransferCount;
+#if defined(VX1000_OLDA_BENCHMARK)
+#if VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT
+      if (eventNumber < VX1000_OLDA_BENCHMARK_CNT)
+#endif /* VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT */
+      {
+        gVX1000_OLDA_TransferSize[eventNumber]  = 0; /* Size of all transfers  */
+        gVX1000_OLDA_TransferCount[eventNumber] = descriptorCount; /* Count of the transfers */
+      }
+#endif /* VX1000_OLDA_BENCHMARK */
+      descriptorIndex = event->TransferIndex;
+#if ((VX1000_MEMSYNC_TRIGGER_COUNT) > 0)
+#if !defined(VX1000_OLDA_FORCE_V8)
+      if (pTransferList[descriptorIndex] == 0x00000000UL)
+      {
+        /* skip the first dummy descriptor (it just informs the AppDriver that the FW despite memSync requests classic OLDA event triggers) */
+        descriptorIndex++;
+        if (descriptorCount > 0) { descriptorCount--; }
+      }
+#endif /* !VX1000_OLDA_FORCE_V8 */
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT */
+      while (descriptorCount > 0)
+      {
+        /* eventNumber is active: data is to be copied */
+#if !defined(VX1000_OLDA_FORCE_V8)
+#if defined(VX1000_OLDA_FORCE_V7)
+        /* TransferList entry consists of up to 4 transfer sizes, followed by up to 4 pure transfer address entries */
+        if (sizeListIndex==0)
+        {
+          sizeListIndex = 4;
+          sizeList = pTransferList[descriptorIndex];
+        }
+        else
+        { /* opening brace for OLDAv7 condition - it is closed after code sections for other OLDA versions */
+          --sizeListIndex;
+          descriptor = pTransferList[descriptorIndex];
+          sz = (VX1000_UINT8)(sizeList & 0x000000FFUL); /* copy 0..255 bytes (this differs from DAQ which uses words) */
+          sizeList >>= 8U;
+#else /* !VX1000_OLDA_FORCE_V7 */
+        /* TransferList entry contains merged size and address information for exactly one transfer */
+        { /* opening brace for OLDAv6 condition - it is closed after code sections for other OLDA versions */
+          sz = (VX1000_UINT8)(pTransferList[descriptorIndex] >> (VX1000_OLDA_SIZE_OFFSET)) & ((1<<(VX1000_OLDA_SIZE_LENGTH))-1);
+          descriptor = (pTransferList[descriptorIndex] & (~(VX1000_OLDA_SIZE_MASK)) ) | (VX1000_OLDA_SIZE_REPLACEMENT);
+#endif /* !VX1000_OLDA_FORCE_V7 */
+#if defined(VX1000_OLDA_BENCHMARK)
+#if VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT
+          if (eventNumber < VX1000_OLDA_BENCHMARK_CNT)
+#endif /* VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT */
+          {
+            gVX1000_OLDA_TransferSize[eventNumber] += (VX1000_UINT32)sz; /* Size of all transfers in BYTEs */
+          }
+#endif /* VX1000_OLDA_BENCHMARK */
+          src8 = VX1000_ADDR_TO_PTR2U8(srcAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          for (k = 0; k < sz; ++k) { VX1000_ADDR_TO_PTR2VU8(descriptor)[k] = src8[k]; } /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          srcAddr += (VX1000_UINT32)sz;
+#else /* VX1000_OLDA_FORCE_V8 */
+        { /* opening brace for OLDAv8 condition - it is closed after code sections for other OLDA versions */
+          descriptor = pTransferList[descriptorIndex];
+          ++descriptorIndex;
+          switch ((VX1000_UINT8)(descriptor & 0x000000FFUL))
+          {
+            case 5: /* OLDA8CMD_DONE */
+              descriptorCount = 1;
+              break;
+#if defined(VX1000_SUPPORT_OLDA8CMD_WAIT)
+            case 7:
+              /* Wait for flag that the remaining part of the data is already valid */
+#error The semantic of the address and index bits for this command is not specified, yet
+              break;
+#endif   /* VX1000_SUPPORT_OLDA8CMD_WAIT */
+            case 9: /* OLDA8CMD_JUMP */
+              switch ((descriptor >> 8) & 0xFFU)
+              {
+                case 0x00U: descriptorIndex += (VX1000_INT16)(descriptor >> 16);  break;  /* relative jump (+/-) to another descriptor */
+                default:    VX1000_ERRLOGGER(VX1000_ERRLOG_OLDA_UNIMPLSUB) break;
+              }
+              break;
+#if defined(VX1000_SUPPORT_OLDA8CMD_LEGACY)
+            case 11:
+              /* todo KNM: interpret the rest of the descriptors as an older olda version X (see a solution in vx1000_oldaEvent) and then remove this entire line */ VX1000_ERRLOGGER(VX1000_ERRLOG_OLDA_UNIMPLCMD) descriptorCount = 1; /* this aborts the current stim transfer because all following descriptors would be misinterpreted */
+              break;
+#endif /* VX1000_SUPPORT_OLDA8CMD_LEGACY */
+#if defined(VX1000_SUPPORT_OLDA8CMD_SP8N)
+            case 14:
+              for (sizeList = descriptor & 0x0000FF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+              {
+                sz = ((VX1000_UINT8) ((pTransferList[descriptorIndex] >> 24) & 0x000000FFUL));
+                ++descriptorIndex;
+                srcAddr += sz;
+              }
+              break;
+#endif   /* VX1000_SUPPORT_OLDA8CMD_SP8N */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CP8N)
+            case 15:
+              for (sizeList = descriptor & 0x0000FF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+              {
+                sz = ((VX1000_UINT8) ((pTransferList[descriptorIndex] >> 24) & 0x000000FFUL));
+                descriptor = (descriptor & 0xFF000000UL) | (pTransferList[descriptorIndex] & 0x00FFFFFFUL);
+                ++descriptorIndex;
+#if defined(VX1000_OLDA_BENCHMARK)
+#if VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT
+                if (eventNumber < (VX1000_OLDA_BENCHMARK_CNT))
+#endif /* VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT */
+                {
+                  gVX1000_OLDA_TransferSize[eventNumber] += (VX1000_UINT32)sz << 0; /* Size of all transfers in BYTEs */
+                }
+#endif /* VX1000_OLDA_BENCHMARK */
+                src8 = VX1000_ADDR_TO_PTR2VU8(srcAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                for (k = 0; k < sz; ++k) { VX1000_ADDR_TO_PTR2VU8(descriptor)[k] = src8[k]; } /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                srcAddr += (VX1000_UINT32)sz;
+              }
+              break;
+#endif   /* VX1000_SUPPORT_OLDA8CMD_CP8N */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CP16N)
+            case 16:
+              for (sizeList = descriptor & 0x0000FF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+              {
+                volatile VX1000_UINT16 *src16 = VX1000_ADDR_TO_PTR2VU16(srcAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                sz = ((VX1000_UINT8) ((pTransferList[descriptorIndex] >> 24) & 0x000000FFUL));
+                descriptor = (descriptor & 0xFF000000UL) | (pTransferList[descriptorIndex] & 0x00FFFFFEUL);
+                ++descriptorIndex;
+#if defined(VX1000_OLDA_BENCHMARK)
+#if VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT
+                if (eventNumber < (VX1000_OLDA_BENCHMARK_CNT))
+#endif /* VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT */
+                {
+                  gVX1000_OLDA_TransferSize[eventNumber] += (VX1000_UINT32)sz << 1; /* Size of all transfers in BYTEs */
+                }
+#endif /* VX1000_OLDA_BENCHMARK */
+                for (k = 0; k < sz; ++k) { VX1000_ADDR_TO_PTR2VU16(descriptor)[k] = src16[k]; } /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                srcAddr += ((VX1000_UINT32)sz << 1);
+              }
+              break;
+#endif   /* VX1000_SUPPORT_OLDA8CMD_CP16N */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CP32N)
+            case 17:
+              for (sizeList = descriptor & 0x0000FF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+              {
+                volatile VX1000_UINT32 *src32 = VX1000_ADDR_TO_PTR2VU32(srcAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                sz = ((VX1000_UINT8) ((pTransferList[descriptorIndex] >> 24) & 0x000000FFUL));
+                descriptor = (descriptor & 0xFF000000UL) | (pTransferList[descriptorIndex] & 0x00FFFFFCUL);
+                ++descriptorIndex;
+#if defined(VX1000_OLDA_BENCHMARK)
+#if VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT
+                if (eventNumber < (VX1000_OLDA_BENCHMARK_CNT))
+#endif /* VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT */
+                {
+                  gVX1000_OLDA_TransferSize[eventNumber] += (VX1000_UINT32)sz << 2; /* Size of all transfers in BYTEs */
+                }
+#endif /* VX1000_OLDA_BENCHMARK */
+                for (k = 0; k < sz; ++k) { VX1000_ADDR_TO_PTR2VU32(descriptor)[k] = src32[k]; } /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                srcAddr += ((VX1000_UINT32)sz << 2);
+              }
+              break;
+#endif   /* VX1000_SUPPORT_OLDA8CMD_CP32N */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CP64N)
+            case 18:
+              for (sizeList = descriptor & 0x0000FF00UL; sizeList != 0; sizeList -= 0x00000100UL)
+              {
+                volatile VX1000_UINT64 *src64 = VX1000_ADDR_TO_PTR2VU64(srcAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                sz = ((VX1000_UINT8) ((pTransferList[descriptorIndex] >> 24) & 0x000000FFUL));
+                descriptor = (descriptor & 0xFF000000UL) | (pTransferList[descriptorIndex] & 0x00FFFFF8UL);
+                ++descriptorIndex;
+#if defined(VX1000_OLDA_BENCHMARK)
+#if VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT
+                if (eventNumber < (VX1000_OLDA_BENCHMARK_CNT))
+#endif /* VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT */
+                {
+                  gVX1000_OLDA_TransferSize[eventNumber] += (VX1000_UINT32)sz << 3; /* Size of all transfers in BYTEs */
+                }
+#endif /* VX1000_OLDA_BENCHMARK */
+                for (k = 0; k < sz; ++k) { VX1000_ADDR_TO_PTR2VU64(descriptor)[k] = src64[k]; } /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+                srcAddr += ((VX1000_UINT32)sz << 3);
+              }
+              break;
+#endif   /* VX1000_SUPPORT_OLDA8CMD_CP64N */
+#if defined(VX1000_ADDONS_DASSTIM_OLDACMD)
+            case 19:
+              VX1000_ADDONS_DASSTIM_OLDACMD(eventNumber, &descriptorIndex, &sizeList, &srcAddr, &descriptor);
+              break;
+#endif /* VX1000_ADDONS_DASSTIM_OLDACMD */
+            /* cases 20 and 21 used exclusively by DAQ */
+#if defined(VX1000_SUPPORT_OLDA8CMD_CALLJITA)
+            case 22:
+              descriptorIndex += (VX1000_UINT16)((VX1000_ADDR_TO_PTR2OCB(pTransferList[descriptorIndex]))(srcAddr, t0, 0UL)); /* PRQA S 0305 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+              break;
+#endif /* VX1000_SUPPORT_OLDA8CMD_CALLJITA */
+            default:
+              VX1000_ERRLOGGER(VX1000_ERRLOG_OLDA_UNIMPLCMD)
+              break;
+          }
+          --descriptorIndex;
+#endif /* VX1000_OLDA_FORCE_V8 */
+          descriptorCount--;
+#if !defined(VX1000_OLDA_FORCE_V8)
+#if defined(VX1000_OLDA_FORCE_V7)
+        } /* closing brace for OLDAv7 condition - just replicated to help editors with syntax highlighting and auto-indentation */
+#else  /* !VX1000_OLDA_FORCE_V7 */
+        } /* closing brace for OLDAv6 condition - just replicated to help editors with syntax highlighting and auto-indentation */
+#endif /* !VX1000_OLDA_FORCE_V7 */
+#else  /* VX1000_OLDA_FORCE_V8 */
+        } /* closing brace for OLDAv8 condition - just replicated to help editors with syntax highlighting and auto-indentation */
+#endif /* VX1000_OLDA_FORCE_V8 */
+        descriptorIndex++;
+      } /* while */
+    }
+#if defined(VX1000_OLDA_BENCHMARK)
+#if VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT
+    if (eventNumber < VX1000_OLDA_BENCHMARK_CNT)
+#endif /* VX1000_OLDA_BENCHMARK_CNT < VX1000_OLDA_EVENT_COUNT */
+    {
+      gVX1000_OLDA_Duration[eventNumber] = (VX1000_CLOCK()) - t0; /* Timing measurement */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+#endif /* VX1000_OLDA_BENCHMARK */
+  }
+  return;
+}
+
+#if defined(VX1000_STIM_FORCE_V1)
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassCheckBuffer                                                                                    */
+/* API name:      None                                                                                                        */
+/* Return value:  1 if the buffers is consistent with data from the last DAQ event                                            */
+/*                2 if no new data is available or the buffer is being copied to                                              */
+/* Parameter1:    eventNumber E [0,gVX1000.Olda.EventCount)                                                                   */
+/* Precondition1: stim_event must be a valid stim event in the range above                                                    */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Description:   Checks whether the stim buffer for the given event contains data consistent with the last DAQ event         */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassCheckBuffer)( VX1000_UINT8 stim_event )
+{
+  VX1000_UINT8 retVal = VX1000_STIM_RET_TIMEOUT;
+  VX1000_OLDA_EVENT_T *pEventList = VX1000_ADDR_TO_PTR2OE(gVX1000.Olda.EventList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+
+  VX1000_UINT32 lastEcuTimestamp = pEventList[(VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].DaqEvent].EventTimestamp;
+  VX1000_UINT32 endTimestamp = (VX1000_ADDR_TO_PTR2U32(pEventList[stim_event].TransferDest - VX1000_BP_TIMESTAMP_SIZE))[0]; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  VX1000_UINT32 startTimestamp = (VX1000_ADDR_TO_PTR2U32(pEventList[stim_event].EventTimestamp))[0]; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+
+  if ((lastEcuTimestamp == endTimestamp) && (lastEcuTimestamp == startTimestamp))
+  {
+    retVal = VX1000_STIM_RET_SUCCESS;
+  }
+
+  return retVal;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassCopyBuffer                                                                                     */
+/* API name:      None                                                                                                        */
+/* Return value:  1 if the data have been successfully copied                                                                 */
+/*                2 if data are inconsistent: a serious error has occurred, such as writing to the buffer during copying      */
+/* Parameter1:    eventNumber E [0,gVX1000.Olda.EventCount)                                                                   */
+/* Precondition1: Stimulation must be active and a DAQ event should have been sent before copying.                            */
+/* Precondition2: BypassCheckBuffer must have been called before hand to check the buffer data are valid.                     */
+/* Precondition3: stim_event must be a valid stim event in the range above                                                    */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Description:   Checks whether the stim buffer for the given event contains data consistent with the last DAQ event         */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassCopyBuffer)( VX1000_UINT8 stim_event )
+{
+  VX1000_OLDA_EVENT_T *pEventList = VX1000_ADDR_TO_PTR2OE(gVX1000.Olda.EventList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  VX1000_UINT8 retVal /*= VX1000_STIM_RET_INACTIVE*/;      /* 0 means "Bypass inactive, enable the bypassed code" */
+#if defined(VX1000_OLDA_BENCHMARK) /* Timing measurement */
+  VX1000_UINT32 t0 = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_OLDA_BENCHMARK */
+
+  /* Do not copy the timestamps at the start and end of the buffers */
+  VX1000_UINT32* src = VX1000_ADDR_TO_PTR2U32(pEventList[stim_event].EventTimestamp + VX1000_BP_TIMESTAMP_SIZE); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  VX1000_UINT32* dst = VX1000_ADDR_TO_PTR2U32(pEventList[stim_event].TransferDest); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  /* Size of the buffer in bytes */
+  VX1000_UINT32 n, siz = pEventList[stim_event].TransferDest - pEventList[stim_event].EventTimestamp - 2 * VX1000_BP_TIMESTAMP_SIZE;
+#if defined(VX1000_OLDA_BENCHMARK)
+  gVX1000_OLDA_TransferSize[stim_event]  = siz; /* Size of all transfers */
+  gVX1000_OLDA_TransferCount[stim_event] = 0;   /* Count of the transfers */
+#endif /* VX1000_OLDA_BENCHMARK */
+
+  /* Copy data using memcopy if available */
+  /* TODO: depending on OLDA mode, the byte count must be used sometimes! */
+  siz >>= 2; /* Convert buffer size into 32-bit words */
+  for (n = 0; n < siz; ++n) { dst[n] = src[n]; }
+
+  /* Check the timestamp again: */
+  if (VX1000_SUFFUN(vx1000_BypassCheckBuffer)(stim_event) == VX1000_STIM_RET_SUCCESS)
+  {
+    retVal = VX1000_STIM_RET_SUCCESS;
+  }
+  else
+  {
+    retVal = VX1000_STIM_RET_ERROR;
+  }
+
+#if defined(VX1000_OLDA_BENCHMARK)
+  gVX1000_OLDA_Duration[stim_event] = (VX1000_CLOCK()) - t0; /* Timing measurement */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_OLDA_BENCHMARK */
+
+  return retVal;
+}
+
+#if defined(VX1000_BYPASS_ALL_CHANS_STIMD)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassAreAllChansStimd                                                                               */
+/* API name:      None                                                                                                        */
+/* Return value:  TRUE (active) or FALSE (inactive)                                                                           */
+/* Precondition1:                                                                                                             */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Description:   Returns true if all channels have received valid stim data                                                  */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassAreAllChansStimd)(void)
+{
+  VX1000_UINT8 invalidCount = 0;
+  VX1000_UINT8 retCode = 0;
+  VX1000_UINT8 i;
+
+  /* First check global enable if all channels flag already set */
+  if (gVX1000.Stim.Enable != VX1000_STIM_GLOBAL_ALL_CHAN)
+  {
+    /* If not, loop over all stim events */
+    for (i = 0; i < VX1000_STIM_EVENT_COUNT; i++)
+    {
+      /* Has the stim channel been activated by the VX - ie do we care if it has stim data? */
+      if (((VX1000_STIMEVENT_ARRAYNAME)[i].Enable > VX1000_STIM_INACTIVE)
+      /* True if the channel has not yet received valid stim data */
+      &&  ((VX1000_STIMEVENT_ARRAYNAME)[i].Enable < VX1000_STIM_BUFFER_VALID) )
+      {
+        ++invalidCount;
+        break;
+      }
+    }
+    if (invalidCount == 0)
+    {
+      gVX1000.Stim.Enable = VX1000_STIM_GLOBAL_ALL_CHAN;
+      retCode = 1;
+    }
+  }
+  else
+  {
+    retCode = 1;
+  }
+
+  return retCode;
+}
+#endif /* VX1000_BYPASS_ALL_CHANS_STIMD */
+
+#endif /* VX1000_STIM_FORCE_V1 */
+
+#endif /* VX1000_STIM_BY_OLDA */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_SetTimeoutUs                                                                                         */
+/* API name:      none (only used internally)                                                                                 */
+/* Return value:  The absolute timeout time as clock value in [ticks].                                                        */
+/* Parameter1:    t: the relative timeout time in [us].                                                                       */
+/*                No invalid input possible.                                                                                  */
+/* Preemption:    No problem inside this function, but the API must not hit into an existing SetTimeoutUs-CheckTimeout frame. */
+/* Termination:   No effect                                                                                                   */
+/* Precondition1: the timer used by VX1000_CLOCK() must already running (with the expected speed).                            */
+/* Description:   Calculates the absolute due time.                                                                           */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT32 VX1000_SUFFUN(vx1000_SetTimeoutUs)(VX1000_UINT32 t)
+{
+#if ((VX1000_CLOCK_TICKS_BASE_NS) < 100000UL) /* was: "#if ((VX1000_CLOCK_TICKS_PER_US) > 10)", but CLOCK_TICKS may be a function! */
+  VX1000_UINT32 dt = t * (VX1000_CLOCK_TICKS_PER_US);
+#else /* VX1000_CLOCK_TICKS_BASE_NS */
+  VX1000_UINT32 dt = (t * (VX1000_CLOCK_TICKS_PER_MS)) / 1000UL;
+#endif /* VX1000_CLOCK_TICKS_BASE_NS */
+  if ( dt >= ((1UL << (((VX1000_CLOCK_TIMER_SIZE) - 1) & 0x1F)) /* dummy operation needed for MISRA: */ + ( 0UL & t) ) )
+  {
+    dt = (1UL << (((VX1000_CLOCK_TIMER_SIZE) - 1) & 0x1F)) - 1UL;
+    VX1000_ERRLOGGER(VX1000_ERRLOG_TM_DTST_TOO_LONG)
+  }
+  return (VX1000_CLOCK()) + dt; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_CheckTimeout                                                                                         */
+/* API name:      none (only used internally)                                                                                 */
+/* Return value:  true if action timed out, false otherwise.                                                                  */
+/* Parameter1:    timeout: the deadline in [ticks].                                                                           */
+/*                No invalid input possible.                                                                                  */
+/* Preemption:    No problem                                                                                                  */
+/* Termination:   No effect                                                                                                   */
+/* Precondition1: vx1000_SetTimeoutUs() must have been called before for an absolute time max. 0x7FFFFFFF ticks in the past.  */
+/* Description:   checks whether the precomputed deadline has be passed already or not.                                       */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_CheckTimeout)(VX1000_UINT32 timeout)
+{
+  VX1000_UINT8 retVal = 0;  /* "no timeout, yet" */
+  if (((timeout - (VX1000_CLOCK())) & (1UL << (((VX1000_CLOCK_TIMER_SIZE) - 1) & 0x1F))) != 0) { retVal = 1; } /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  return retVal;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_StimSkip                                                                                             */
+/* API name:      VX1000_STIM_SKIP                                                                                            */
+/* Wrapper API:   VX1000If_StimSkip                                                                                           */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    eventNumber E [0,gVX1000.Olda.EventCount)                                                                   */
+/* Precondition1:                                                                                                             */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Description:   Sends a stim skip event to tell the VX not to stimulate the next cycle (in effect a dummy STIM request)     */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+void VX1000_SUFFUN(vx1000_StimSkip)( VX1000_UINT8 stim_event )
+{
+  if (VX1000_STIM_ACTIVE(stim_event) != 0)
+  {
+    VX1000_SPECIAL_EVENT(VX1000_ECU_EVT_STIM_SKIP( stim_event )) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */ /* PRQA S 0501 */ /* Violation of MISRA rule 12.8 because 64-bit data types are known to be not MISRA-conformant. This is just an example to be overruled by a user-defined implementation of an atomic 64-bit-store operation. */
+  }
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_StimInit                                                                                             */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:    This function should not interrupt and should not be interrupted by code that reads the stimulation data.   */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_InitAsyncStart must have been called.                                                                */
+/* Description:   Initialises the stimulation control structures. Called in VX1000_INIT_ASYNC_START() and every time STIM     */
+/*                is turned off                                                                                               */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static void VX1000_SUFFUN(vx1000_StimInit)(void)
+{
+  VX1000_UINT32 i;
+
+  gVX1000.Stim.Control = 0;
+  gVX1000.Stim.EvtOffset = VX1000_STIM_EVENT_OFFSET;
+  gVX1000.Stim.EvtNumber = VX1000_STIM_EVENT_COUNT;
+
+#if !defined(VX1000_STIM_FORCE_V1)
+  gVX1000.Stim.Version = 0;
+  for (i = 0; i < VX1000_STIM_EVENT_COUNT; i++)
+  {
+    (VX1000_STIMEVENT_ARRAYNAME)[i].Ctr = 0;
+    (VX1000_STIMEVENT_ARRAYNAME)[i].RqCtr = 0;
+    (VX1000_STIMEVENT_ARRAYNAME)[i].Enable = 0;
+#if !defined(VX1000_STIM_BY_OLDA)
+    gVX1000.Stim.Event[i].Copying = 0;
+#endif /* !VX1000_STIM_BY_OLDA */
+  }
+  gVX1000.Stim.Enable = 0;
+#else /* VX1000_STIM_FORCE_V1 */
+  gVX1000.Stim.Version = 1;
+  gVX1000.Stim.EventPointer = VX1000_PTR2SE_TO_ADDRESS(&gVX1000.Stim.Events);  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if defined(VX1000_HOOK_BASED_BYPASSING)
+  gVX1000.Stim.hbbLUTNumber = VX1000_BYPASS_HBB_LUT_ENTRIES;
+  gVX1000.Stim.hbbLUTPointer = (VX1000_UINT32)( VX1000_BYPASS_HBB_LUT_ADDR ); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  gVX1000.Stim.hbbLUTVXPointer = 0;
+#endif /* VX1000_HOOK_BASED_BYPASSING */
+  gVX1000.Stim.Events.MagicId = VX1000_STIM_EVENT_MAGIC;
+  gVX1000.Stim.Events.Version = 1;
+
+  for (i = 0; i < VX1000_STIM_EVENT_COUNT; i++)
+  {
+    (VX1000_STIMEVENT_ARRAYNAME)[i].DaqEvent = 0;
+    (VX1000_STIMEVENT_ARRAYNAME)[i].Enable = VX1000_STIM_INACTIVE;
+    (VX1000_STIMEVENT_ARRAYNAME)[i].EventType = VX1000_BYPASS_TYPE_DIRECT;
+    (VX1000_STIMEVENT_ARRAYNAME)[i].Copying = 0;
+    (VX1000_STIMEVENT_ARRAYNAME)[i].Ctr = 0;
+    (VX1000_STIMEVENT_ARRAYNAME)[i].RqCtr = 0;
+  }
+  VX1000_SET_STIM_INFO()
+  gVX1000.Stim.Enable = VX1000_STIM_GLOBAL_INACTIVE;
+#endif /* VX1000_STIM_FORCE_V1 */
+  if ( (VX1000_PTR2VU8_TO_ADDRESS(&gVX1000.Stim.EvtOffset)) != (0x8UL + VX1000_STIM_PTR) ) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  {
+    gVX1000.ToolDetectState |= VX1000_TDS_ERROR;
+    VX1000_ERRLOGGER(VX1000_ERRLOG_STRUCTS_PADDED)
+  }
+  gVX1000.Stim.MagicId = (VX1000_UINT32)(VX1000_STIM_MAGIC);
+}
+
+
+#if defined(VX1000_STIM_BENCHMARK)
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_StimBenchmarkInit                                                                                    */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: None                                                                                                        */
+/* Description:   Initialises the STIM benchmark data.                                                                        */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static void VX1000_SUFFUN(vx1000_StimBenchmarkInit)( void )
+{
+  VX1000_UINT32 i;
+
+  for (i = 0; i < VX1000_STIM_EVENT_COUNT; i++)
+  {
+    gVX1000_STIM_Begin[i] = 0;
+    gVX1000_STIM_Duration[i] = 0;
+  }
+
+#if defined(VX1000_STIM_HISTOGRAM)
+  for (i = 0; i < 256; i++) { gVX1000_STIM_Histogram[i] = 0; }
+  for (i = 0; i < 16; i++) { gVX1000_STIM_Histogram2[i] = 0; }
+#endif /* VX1000_STIM_HISTOGRAM */
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_StimBenchmarkStimEnd                                                                                 */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    eventNumber E [VX1000_STIM_EVENT_OFFSET,gVX1000.Olda.EventCount)                                            */
+/*                Validity has to be ensured by caller.                                                                       */
+/* Parameter2:    flag signalling whether there was a stim timeout (TRUE) or not (FALSE)                                      */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: gVX1000_STIM_Begin shall have been initialised for the same event before.                                   */
+/* Description:   Record de duration of the current stim transfer; also update the stim histogram.                            */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static void VX1000_SUFFUN(vx1000_StimBenchmarkStimEnd)( VX1000_UINT8 stim_event, VX1000_UINT8 timeout_flag )
+{
+  VX1000_UINT32 t0,t1,dt;
+
+  t0 = gVX1000_STIM_Begin[stim_event - (VX1000_STIM_EVENT_OFFSET)];
+  if (t0 != 0)
+  {
+    gVX1000_STIM_Begin[stim_event - (VX1000_STIM_EVENT_OFFSET)] = 0;
+    t1 = VX1000_CLOCK(); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    dt =  t1 - t0;
+    gVX1000_STIM_Duration[stim_event - (VX1000_STIM_EVENT_OFFSET)] = dt; /* Last delay for each individual event */
+
+    /* Build the histograms for event VX1000_STIM_HISTOGRAM */
+#if defined(VX1000_STIM_HISTOGRAM)
+    if (stim_event == (VX1000_STIM_HISTOGRAM))
+    {
+      gVX1000_STIM_Histogram2[0]++; /* Index 0 is the cycles with 0 timeouts counter ! */
+
+      if (0==timeout_flag)
+      {
+        /* Build the delay histogram */
+        /* 20us resolution, 0..5100us:     */
+        if ((VX1000_CLOCK_TICKS_PER_MS) >= 50) /* note: this cannot be replaced by a preprocessor condition because the user may define VX1000_CLOCK_TICKS_PER_MS to a runtime evaluated formula/function */
+        {
+          t0 = (VX1000_UINT32)(dt / (VX1000_UINT32)((VX1000_CLOCK_TICKS_PER_MS) / 50UL));
+        }
+        else
+        {
+          t0 = (VX1000_UINT32)((VX1000_UINT32)(50UL * dt) / (VX1000_CLOCK_TICKS_PER_MS));
+        }
+        if (t0 >= 256UL) { t0 = 255UL; }
+        gVX1000_STIM_Histogram[t0]++;
+      }
+      else
+      {
+        /* Build the timeout burst count histogram */
+        /* 0..15 */
+        t0 = gVX1000.Stim.TimeoutCtr2;
+        if (t0 <= 15)
+        {
+          gVX1000_STIM_Histogram2[t0]++;
+          gVX1000_STIM_Histogram2[t0-1]--; /* t0 is always >0 when timeout_flag is set */
+        }
+      }
+    }
+#else /* !VX1000_STIM_HISTOGRAM */
+    VX1000_DUMMYREAD(timeout_flag) /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+#endif /* !VX1000_STIM_HISTOGRAM */
+  }
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_StimBenchmarkStimCheck                                                                               */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_StimInit must have been called.                                                                      */
+/* Description:                                                                                                               */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static void VX1000_SUFFUN(vx1000_StimBenchmarkStimCheck)( void )
+{
+#if defined(VX1000_STIM_HISTOGRAM)
+  if (VX1000_STIM_ACTIVE(VX1000_STIM_HISTOGRAM) != 0)
+  {
+#if !defined(VX1000_STIM_FORCE_V1)
+    if ((VX1000_STIMEVENT_ARRAYNAME)[(VX1000_STIM_HISTOGRAM) - (VX1000_STIM_EVENT_OFFSET)].Ctr
+    ==  (VX1000_STIMEVENT_ARRAYNAME)[(VX1000_STIM_HISTOGRAM) - (VX1000_STIM_EVENT_OFFSET)].RqCtr)
+#else /* VX1000_STIM_FORCE_V1 */
+    if (VX1000_SUFFUN(vx1000_BypassCheckCounters)(VX1000_STIM_HISTOGRAM) == VX1000_STIM_RET_SUCCESS)
+#endif /* VX1000_STIM_FORCE_V1 */
+    {
+      VX1000_SUFFUN(vx1000_StimBenchmarkStimEnd)( VX1000_STIM_HISTOGRAM, 0 );
+    }
+  }
+#endif /* VX1000_STIM_HISTOGRAM */
+}
+
+
+#endif /* VX1000_STIM_BENCHMARK */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_StimControl                                                                                          */
+/* API name:      VX1000_STIM_CONTROL / VX1000_BYPASS_CONTROL                                                                 */
+/* Wrapper API:   VX1000If_StimControl / VX1000If_BypassControl                                                               */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_StimInit must have been called.                                                                      */
+/* Description:   The Stim-Keep-Alive-Handler (to be called cyclically by the application).                                   */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+void VX1000_SUFFUN(vx1000_StimControl)(void)
+{
+  if ((gVX1000.Stim.Control != 0) && (0==gVX1000.Stim.Enable))
+  {
+
+    /* Clear benchmark data */
+#if defined(VX1000_STIM_BENCHMARK)
+    VX1000_SUFFUN(vx1000_StimBenchmarkInit)();
+#endif /* VX1000_STIM_BENCHMARK */
+
+    gVX1000.Stim.TimeoutCtr = 0;
+    gVX1000.Stim.TimeoutCtr2 = 0;
+
+#if defined(VX1000_STIM_TYPE_0)
+    VX1000_SPECIAL_EVENT(VX1000_EVENT_STIM_ACK) /* Send an acknowledge STIM event when the ECU is ready for STIM */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_STIM_TYPE_0 */
+
+    gVX1000.Stim.Enable = VX1000_STIM_GLOBAL_VX_ENABLE;
+  }
+  else
+  {
+    /* Re-initialise STIM when VX1000 turns STIM off (but hold the timeout counters) */
+    if ((0==gVX1000.Stim.Control) && (gVX1000.Stim.Enable != VX1000_STIM_GLOBAL_INACTIVE)) { VX1000_SUFFUN(vx1000_StimInit)(); }
+  }
+
+#if defined(VX1000_STIM_BENCHMARK)
+  /* STIM Benchmark: Specific measurements for a single event from request to acknowledge */
+  VX1000_SUFFUN(vx1000_StimBenchmarkStimCheck)();
+#endif /* VX1000_STIM_BENCHMARK */
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_StimActive                                                                                           */
+/* API name:      VX1000_STIM_ACTIVE                                                                                          */
+/* Wrapper API:   VX1000If_StimActive                                                                                         */
+/* Return value:  TRUE (active) or FALSE (inactive)                                                                           */
+/* Parameter1:    eventNumber E [VX1000_STIM_EVENT_OFFSET,gVX1000.Olda.EventCount)                                            */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_StimInit must have been called.                                                                      */
+/* Description:   Returns true if stim is active both globally and for a specific event that is of type STIM.                 */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_StimActive)( VX1000_UINT8 stim_event )
+{
+  VX1000_UINT8 retVal = 0;  /* "inactive" */
+  if (((((gVX1000.Stim.Control) != 0) && (gVX1000.Stim.Enable != (VX1000_STIM_GLOBAL_INACTIVE)))
+#if (0==(VX1000_STIM_EVENT_OFFSET))
+  && ((stim_event) < (VX1000_STIM_EVENT_COUNT)))
+#else /* VX1000_STIM_EVENT_OFFSET */
+  && (((stim_event) >= (VX1000_STIM_EVENT_OFFSET)) && ((stim_event) < ((VX1000_STIM_EVENT_OFFSET) + (VX1000_STIM_EVENT_COUNT)))))
+#endif /* VX1000_STIM_EVENT_OFFSET */
+  && ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Enable != 0))
+  {
+    retVal = 1;  /* "active" */
+  }
+  return retVal;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_StimRequest                                                                                          */
+/* API name:      VX1000_STIM_REQUEST                                                                                         */
+/* Wrapper API:   VX1000If_StimRequest                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    eventNumber E [VX1000_STIM_EVENT_OFFSET,gVX1000.Olda.EventCount)                                            */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Preemption:    This function must not interrupt and not be interrupted by vx1000_* functions operating on the same event.  */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Request a specific STIM data set associated to event stim_event.                                            */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+void VX1000_SUFFUN(vx1000_StimRequest)( VX1000_UINT8 stim_event )
+{
+#if defined(VX1000_STIM_BENCHMARK)
+  gVX1000_STIM_Begin[stim_event - (VX1000_STIM_EVENT_OFFSET)] = VX1000_CLOCK(); /* Timing measurement */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_STIM_BENCHMARK */
+#if defined(VX1000_STIM_FORCE_V1)
+  /* Only if the event is "direct stimulation" instead of stim-by-olda, send a stim request */
+  if ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].EventType == VX1000_BYPASS_TYPE_DIRECT)
+#endif /* VX1000_STIM_FORCE_V1 */
+  {
+    (VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].RqCtr++;
+    VX1000_STIM_REQUEST_EVENT(stim_event) /* PRQA S 0303 */ /* PRQA S 0306 */ /* macro expansion contains VX1000_ADDR_TO_PTR2XXX: cannot avoid violating MISRA rule 11.3 because in a few configurations a peripheral register at a fix HW address must be accessed via pointer to update the HW value */ /* PRQA S 0501 */ /* Violation of MISRA rule 12.8 because 64-bit data types are known to be not MISRA-conformant. This is just an example to be overruled by a user-defined implementation of an atomic 64-bit-store operation. */
+  }
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_StimWait                                                                                             */
+/* API name:      VX1000_STIM_WAIT (expression) / VX1000_STIM_WAIT_VOID (statement) /                                         */
+/*                VX1000_BYPASS_STIM (expression) / VX1000_BYPASS_STIM_VOID (statement)                                       */
+/* Wrapper API:   VX1000If_StimWait (expression) / VX1000If_StimWaitVoid (statement) /                                        */
+/*                VX1000If_BypassStim (expression) / VX1000If_BypassStimVoid  (statement)                                     */
+/* Return value:  0 (data arrived before timeout or timeout but data still copied successfully)                               */
+/*                1 (timeout, no new data arrived or error during copying and destination data corrupted)                     */
+/* Parameter1:    eventNumber E [VX1000_STIM_EVENT_OFFSET,gVX1000.Olda.EventCount)                                            */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Parameter2:    flag: 0 (don\'t copy data / 1 (copy olda data)                                                               */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Parameter3:    timeout in microseconds, starting from related call to VX1000_STIM_REQUEST                                  */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_StimInit must have been called.                                                                      */
+/* Precondition2: VX1000_STIM_REQUEST must have been called recently for the same event.                                      */
+/* Description:   Busy wait until a specific STIM request is fulfilled.                                                       */
+/*                Optionally processes all transfer descriptors assigned to parameter1 (only available with olda).            */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_StimWait)( VX1000_UINT8 stim_event, VX1000_UINT8 copy_enable, VX1000_UINT32 timeout_us )
+{
+  VX1000_UINT8 errorcode = 0U;
+#if ((!defined(VX1000_STIM_BY_OLDA)) || defined(VX1000_STIM_FORCE_V1))
+  VX1000_UINT8 lastChance = 0U;
+#endif /* !VX1000_STIM_BY_OLDA || VX1000_STIM_FORCE_V1 */
+  VX1000_UINT8 keepLooping = 1U;
+#if (!defined(VX1000_RESET_STIM_TIMEOUT)) || (!defined(VX1000_CHECK_STIM_TIMEOUT))
+  static volatile VX1000_UINT32 gVX1000_timeout[VX1000_STIM_EVENT_COUNT]; /* can be per core and static */
+#endif /* !VX1000_RESET_STIM_TIMEOUT || !VX1000_CHECK_STIM_TIMEOUT */
+
+#if !defined(VX1000_STIM_FORCE_V1)
+  gVX1000_timeout[(stim_event) - (VX1000_STIM_EVENT_OFFSET)] = VX1000_SUFFUN(vx1000_SetTimeoutUs)((VX1000_UINT32)(timeout_us)); /* reset STIM timeout */
+    while (keepLooping != 0U) /* Busy wait with timeout until direct stimulation is done (or olda stimulation data arrived) */
+    {
+      VX1000_UINT8 timedOut;
+#if !defined(VX1000_STIM_BY_OLDA)
+      VX1000_UINT8 copying;
+#endif /* !VX1000_STIM_BY_OLDA */
+      VX1000_UINT8 haveData;
+#if defined(VX1000_TARGET_POWERPC)
+    /* For parallel pods perform dummy writes inside a trace window that is active for the executing core. */
+    /* This way, while waiting for the STIM data, stuck event triggers will be flushed off the Nexus FIFO. */
+#if (!defined(VX1000_OLDA)) && (!defined(VX1000_SUPPRESS_TRACE))
+#if (VX1000_MEMSYNC_TRIGGER_COUNT == 0)
+    gVX1000.EventTimestamp = VX1000_CLOCK(); /* gVX1000 is always in a trace window visible by all cores, so this write will produce the desired trace load and as a side effect allow the NIOS to better estimate the FIFO fill level */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#elif (VX1000_MEMSYNC_TRIGGER_COUNT == 1)
+    /* A byte store into the sync area s guaranteed to produce the desired trace load but as byte will NOT be (mis)interpreted by the decoder because ii only processes 64bit stores */
+    (VX1000_ADDR_TO_PTR2U8(gVX1000.MemSyncTrigPtr + 12UL))[0] = 0; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+    {
+      VX1000_UINT32 core;
+      for (core = 0; core < (VX1000_MEMSYNC_TRIGGER_COUNT); ++core)
+      {
+        /* at least one trace window of at least 8 bytes will be active for this core. A byte store into that area will produce the desired trace load but will NOT be (mis)interpreted by the decoder */
+        (VX1000_ADDR_TO_PTR2U8(((VX1000_ADDR_TO_PTR2VU32(gVX1000.MemSyncTrigPtr))[core]) + 12UL))[0] = 0; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      }
+    }
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+#endif /* !VX1000_OLDA & !VX1000_SUPPRESS_TRACE */
+#endif /* VX1000_TARGET_POWERPC */
+    /*
+    Note that in order to avoid race conditions, the order of the following
+    three assignments must not be changed under any circumstances!!!
+    */
+    timedOut = VX1000_SUFFUN(vx1000_CheckTimeout)(gVX1000_timeout[stim_event - (VX1000_STIM_EVENT_OFFSET)]);
+#if !defined(VX1000_STIM_BY_OLDA)
+    copying = (VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Copying;
+#endif /* !VX1000_STIM_BY_OLDA */
+    haveData = ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Ctr == (VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].RqCtr) ? 1U : 0U;
+    if (haveData != 0U)
+    {
+      /* data has arrived */
+      keepLooping = 0U;
+#if !defined(VX1000_STIM_BY_OLDA)
+      if (lastChance != 0U)
+      {
+        errorcode = 1U; /* timeout, but new data already valid */
+      }
+#endif /* !VX1000_STIM_BY_OLDA */
+    }
+    else if (timedOut != 0U)
+    {
+#if !defined(VX1000_STIM_BY_OLDA)
+      if ((lastChance == 0U) && (copying != 0U))
+      {
+        /* If timeout happened, but copying data has already started,       */
+        /* concede a second chance to complete within the next millisecond: */
+        lastChance = 1U;
+        gVX1000_timeout[(stim_event) - (VX1000_STIM_EVENT_OFFSET)] = VX1000_SUFFUN(vx1000_SetTimeoutUs)((VX1000_UINT32)(1000U)); /* reset STIM timeout */
+      }
+      else
+#endif /* !VX1000_STIM_BY_OLDA */
+      {
+        keepLooping = 0U;
+        errorcode = 2U; /* timeout, no new data or data incomplete */
+#if !defined(VX1000_STIM_BY_OLDA)
+        if (lastChance == 0U)
+#endif /* !VX1000_STIM_BY_OLDA */
+        {
+          if (VX1000_STIM_ACTIVE(stim_event) != 0U)
+          {
+            VX1000_SPECIAL_EVENT(VX1000_EVENT_STIM_TIMEOUT(stim_event)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+        }
+#if !defined(VX1000_STIM_BY_OLDA)
+        else
+        {
+          VX1000_SPECIAL_EVENT(VX1000_EVENT_STIM_ERR(stim_event)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+#endif /* !VX1000_STIM_BY_OLDA */
+      }
+    }
+    else
+    {
+      ; /* empty else is only here for MISRA */
+    }
+  } /* while */
+
+  if (errorcode == 2) /* Timeout (no new valid data) --> increment timeout counter and timeout burst counter */
+  {
+    gVX1000.Stim.TimeoutCtr++;
+    gVX1000.Stim.TimeoutCtr2++;
+  }
+  else /* either no timeout at all or timeout, but still all data arrived successfully */
+  {
+    gVX1000.Stim.TimeoutCtr2 = 0; /* Clear the timeout burst counter */
+#if defined(VX1000_STIM_BY_OLDA)
+    if (copy_enable != 0)
+    {
+      /* Copy the STIM data to final memory locations */
+      VX1000_SUFFUN(vx1000_StimTransfer)(stim_event);
+    }
+#else  /* !VX1000_STIM_BY_OLDA */
+    VX1000_DUMMYREAD(copy_enable) /* only here to prevent compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+#endif /* !VX1000_STIM_BY_OLDA */
+  }
+  errorcode >>= 1;
+#if defined(VX1000_STIM_BENCHMARK)
+  VX1000_SUFFUN(vx1000_StimBenchmarkStimEnd)(stim_event, errorcode);
+#endif /* VX1000_STIM_BENCHMARK */
+  return errorcode;
+#else /* VX1000_STIM_FORCE_V1 */
+  VX1000_UINT8 retVal = 2;
+
+  if ((VX1000_STIM_ACTIVE(stim_event) != VX1000_STIM_GLOBAL_INACTIVE)
+  &&  ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Enable >= VX1000_STIM_DAQ_SENT))
+  {
+    VX1000_INT32 specialEvent = -1;
+    gVX1000_timeout[(stim_event) - (VX1000_STIM_EVENT_OFFSET)] = VX1000_SUFFUN(vx1000_SetTimeoutUs)((VX1000_UINT32)(timeout_us)); /* reset STIM timeout */
+
+    /* Step 1: Busy wait to check for valid STIM data */
+    /* Check whether new data have arrived - in the case of direct stim, counters are checked, for OLDA, the buffer timestamps */
+    while (keepLooping != 0)
+    {
+      VX1000_UINT8 timedOut;
+      VX1000_UINT8 copying;
+      VX1000_UINT8 haveData;
+#if defined(VX1000_TARGET_POWERPC)
+      /* For parallel pods perform dummy writes inside a trace window that is active for the executing core. */
+      /* This way, while waiting for the STIM data, stuck event triggers will be flushed off the Nexus FIFO. */
+#if (!defined(VX1000_OLDA)) && (!defined(VX1000_SUPPRESS_TRACE))
+#if (VX1000_MEMSYNC_TRIGGER_COUNT == 0)
+      gVX1000.EventTimestamp = VX1000_CLOCK(); /* gVX1000 is always in a trace window visible by all cores, so this write will produce the desired trace load and as a side effect allow the NIOS to better estimate the FIFO fill level */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#elif (VX1000_MEMSYNC_TRIGGER_COUNT == 1)
+      /* A byte store into the sync area s guaranteed to produce the desired trace load but as byte will NOT be (mis)interpreted by the decoder because ii only processes 64bit stores */
+      (VX1000_ADDR_TO_PTR2U8(gVX1000.MemSyncTrigPtr + 12UL))[0] = 0; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+      {
+        VX1000_UINT32 core;
+        for (core = 0; core < (VX1000_MEMSYNC_TRIGGER_COUNT); ++core)
+        {
+          /* at least one trace window of at least 8 bytes will be active for this core. A byte store into that area will produce the desired trace load but will NOT be (mis)interpreted by the decoder */
+          (VX1000_ADDR_TO_PTR2U8(((VX1000_ADDR_TO_PTR2VU32(gVX1000.MemSyncTrigPtr))[core]) + 12UL))[0] = 0; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+      }
+#endif /* VX1000_MEMSYNC_TRIGGER_COUNT > 1 */
+#endif /* !VX1000_OLDA & !VX1000_SUPPRESS_TRACE */
+#endif /* VX1000_TARGET_POWERPC */
+      /*
+      Note that in order to avoid race conditions, the order of the following
+      three assignments must not be changed under any circumstances!!!
+      */
+      timedOut = VX1000_SUFFUN(vx1000_CheckTimeout)(gVX1000_timeout[stim_event - (VX1000_STIM_EVENT_OFFSET)]);
+      copying = (VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Copying;
+      haveData = (VX1000_SUFFUN(vx1000_BypassCheckCounters)(stim_event) == VX1000_STIM_RET_SUCCESS) ? 1U : 0U;
+      if (haveData != 0U)
+      {
+        /* data has arrived */
+        keepLooping = 0U;
+        if (lastChance != 0U)
+        {
+          errorcode = 1U; /* timeout, but new data already valid */
+        }
+      }
+      else if (timedOut != 0U)
+      {
+        if ((lastChance == 0U) && (copying != 0U) && ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].EventType == VX1000_BYPASS_TYPE_DIRECT))
+        {
+          /* If timeout happened, but copying data has already started,   */
+          /* concede a second chance to complete within the next millisecond: */
+          lastChance = 1;
+          gVX1000_timeout[(stim_event) - (VX1000_STIM_EVENT_OFFSET)] = VX1000_SUFFUN(vx1000_SetTimeoutUs)((VX1000_UINT32)(1000U)); /* reset STIM timeout */
+        }
+        else
+        {
+          keepLooping = 0U;
+          if (lastChance != 0U)
+          {
+            specialEvent = ((VX1000_INT32) VX1000_EVENT_STIM_ERR(stim_event));
+            errorcode = 3U; /* timeout, data incomplete */
+            (VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Enable = VX1000_STIM_BUFFER_INVALID; /* Data invalid */
+          }
+          else
+          {
+            /* Do not send a timeout for OLDA-based stimulation */
+            errorcode = 2U; /* timeout, no new data */
+            if ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].EventType == VX1000_BYPASS_TYPE_DIRECT)
+            {
+              specialEvent = ((VX1000_INT32) VX1000_EVENT_STIM_TIMEOUT(stim_event));
+            }
+          }
+        }
+      }
+      else
+      {
+        ; /* this empty else case and semicolon are only here for MISRA */
+      }
+      if (specialEvent != -1)
+      {
+        VX1000_SPECIAL_EVENT((VX1000_UINT32)specialEvent) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      }
+    } /* while */
+
+    /* Step 2: Check the errorcode and copy data in the case of OLDA */
+    if (errorcode < 2) /* todo: care for "The result of this logical operation is always \'false\'." compiler warning */
+    {
+      /* Set data valid flag for the event */
+      (VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Enable = VX1000_STIM_BUFFER_VALID;
+#if defined(VX1000_STIM_BY_OLDA)
+      if ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].EventType != VX1000_BYPASS_TYPE_DIRECT)
+      {
+        /* Copy data from VX-write to ECU-read buffer */
+        if (VX1000_SUFFUN(vx1000_BypassCopyBuffer)(stim_event) != VX1000_STIM_RET_SUCCESS)
+        {
+          /* Flag errors during copying */
+          (VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Enable = VX1000_STIM_BUFFER_INVALID;
+          errorcode = 3;
+        }
+        /* Copy the STIM data to final memory locations */
+        else if ((copy_enable != 0)
+        && ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].EventType == VX1000_BYPASS_TYPE_OLDA))
+        {
+#if defined(VX1000_BYPASS_ALL_CHANS_STIMD)
+#if defined(VX1000_IS_INSTANT_BYP_ALLOWED)
+          VX1000_UINT8 bypassAreAllChansStimd = VX1000_SUFFUN(vx1000_BypassAreAllChansStimd)();
+          /* Only copy if this channel does not need to wait for other channels OR if valid stim data received from all other channels */
+          if (((VX1000_IS_INSTANT_BYP_ALLOWED(stim_event)) && ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Enable == VX1000_STIM_BUFFER_VALID)) || (bypassAreAllChansStimd == 1)) /* PRQA S 3356 */ /* cannot avoid violating MISRA rule 13.7 because of dependency on user-defined callback not guaranteed to be evaluable at compile time */
+#else /* !VX1000_IS_INSTANT_BYP_ALLOWED */
+          /* Only copy if valid stim data received from all other channels first */
+          if (VX1000_SUFFUN(vx1000_BypassAreAllChansStimd)() == 1)
+#endif /* !VX1000_IS_INSTANT_BYP_ALLOWED */
+#else /* VX1000_BYPASS_ALL_CHANS_STIMD */
+          if ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Enable == VX1000_STIM_BUFFER_VALID)
+#endif /* VX1000_BYPASS_ALL_CHANS_STIMD */
+          {
+            VX1000_SUFFUN(vx1000_StimTransfer)(stim_event);
+          }
+        } else
+        {
+          /* this else block is here only to satisfy MISRA*/
+        }
+      }
+#else /* !VX1000_STIM_BY_OLDA */
+    VX1000_DUMMYREAD(copy_enable)      /* dummy usage to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+#endif /* !VX1000_STIM_BY_OLDA */
+    }
+
+    /* Step 3: Check the errorcode for timeouts and errors */
+    /* todo: care for the "The result of this logical operation is always \'true\'." compiler warning */
+    if (errorcode >= 2) /* Timeout (no new valid data) --> increment timeout counter and timeout burst counter */
+    {
+      gVX1000.Stim.TimeoutCtr++;
+      gVX1000.Stim.TimeoutCtr2++;
+      if (errorcode == 3)
+      {
+        retVal = 3;
+      }
+      else
+      {
+        retVal = 2;
+      }
+    }
+    else /* either no timeout at all or timeout, but still all data arrived successfully */
+    {
+      gVX1000.Stim.TimeoutCtr2 = 0; /* Clear the timeout burst counter */
+      retVal = 0;
+    }
+    errorcode >>= 1;
+#if defined(VX1000_STIM_BENCHMARK)
+    VX1000_SUFFUN(vx1000_StimBenchmarkStimEnd)(stim_event, errorcode);
+#endif /* VX1000_STIM_BENCHMARK */
+  } /* STIM event active & DAQ event sent */
+
+  return retVal >> 1; /* turn the verbose internal status into the bool of the API */
+#endif /* VX1000_STIM_FORCE_V1 */
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_Bypass                                                                                               */
+/* API name:      VX1000_BYPASS (expression) / VX1000_BYPASS_VOID (statement)                                                 */
+/* Wrapper API:   VX1000If_Bypass (expression) / VX1000If_BypassVoid (statement)                                              */
+/* Return value:  status: 0 (bypassed code shall be activated because bypassing is not active)                                */
+/*                1 (everything done, bypassed code shall be disabled)                                                        */
+/*                2 (bypassing failed; it\'s up to the application design whether executing the bypassed code makes sense here)*/
+/* Parameter1:    daq_event E [0,gVX1000.Olda.EventCount)                                                                     */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Parameter2:    stim_event E [VX1000_STIM_EVENT_OFFSET,gVX1000.Olda.EventCount)                                             */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Parameter3:    timeout in microseconds, starting right now.                                                                */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Initiate a bypass by sending DAQ data to the tool and implicitly requesting a stimulation (daq_event),      */
+/*                then busy wait with timeout for the tool to complete the stimulation (stim_event).                          */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_Bypass)( VX1000_UINT8 daq_event, VX1000_UINT8 stim_event, VX1000_UINT32 timeout_us)
+{
+  VX1000_UINT8 retVal = 0;    /* 0 means "Bypass inactive, enable the bypassed code" */
+
+#if !defined(VX1000_STIM_FORCE_V1)
+  if ((VX1000_STIM_ACTIVE(stim_event)) != 0)
+  {
+    VX1000_EVENT(daq_event) /* PRQA S 0303 */ /* PRQA S 0306 */ /* macro expansion contains VX1000_ADDR_TO_PTR2XXX: cannot avoid violating MISRA rule 11.3 because in a few configurations a peripheral register at a fix HW address must be accessed via pointer to update the HW value */ /* PRQA S 0501 */ /* Violation of MISRA rule 12.8 because 64-bit data types are known to be not MISRA-conformant. This is just an example to be overruled by a user-defined implementation of an atomic 64-bit-store operation. */
+    VX1000_STIM_REQUEST(stim_event)
+    if ((VX1000_STIM_WAIT(stim_event, timeout_us)) != 0)
+#else /* VX1000_STIM_FORCE_V1 */
+  if ((VX1000_BYPASS_DAQ(daq_event, stim_event)) == VX1000_STIM_RET_SUCCESS)
+  {
+    if ((VX1000_STIM_WAIT(stim_event, timeout_us)) != 0) /* note: do NOT use VX1000_STIM_RET_SUCCESS here because STIM_WAIT\'s return codes differ from STIM_EVENT\'s! */
+#endif /* VX1000_STIM_FORCE_V1 */
+    {
+      retVal = 2;           /* "Bypass active, timeout" */
+    }
+    else
+    {
+      retVal = 1;           /* "Bypass active, OK, disable the bypassed code" */
+    }
+  }
+  return retVal;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassTrigger                                                                                        */
+/* API name:      VX1000_BYPASS_TRIGGER (expression) / VX1000_BYPASS_TRIGGER_VOID (statement)                                 */
+/* Wrapper API:   VX1000If_BypassTrigger (expression) / VX1000If_BypassTriggerVoid (statement)                                */
+/* Return value:  status: 0 (bypassed code shall be activated because bypassing is not active)                                */
+/*                1 (everything done, bypassed code shall be disabled)                                                        */
+/* Parameter1:    daq_event E [0,gVX1000.Olda.EventCount)                                                                     */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Parameter2:    stim_event E [VX1000_STIM_EVENT_OFFSET,gVX1000.Olda.EventCount)                                             */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Initiate a bypass by sending DAQ data to the tool and implicitly requesting a stimulation (daq_event).      */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassTrigger)( VX1000_UINT8 daq_event, VX1000_UINT8 stim_event )
+{
+  VX1000_UINT8 retVal = VX1000_STIM_RET_INACTIVE;  /* 0 means "Bypass inactive" */
+
+  if (VX1000_STIM_ACTIVE(stim_event) != 0)
+  {
+    VX1000_EVENT(daq_event) /* PRQA S 0303 */ /* PRQA S 0306 */ /* macro expansion contains VX1000_ADDR_TO_PTR2XXX: cannot avoid violating MISRA rule 11.3 because in a few configurations a peripheral register at a fix HW address must be accessed via pointer to update the HW value */ /* PRQA S 0501 */ /* Violation of MISRA rule 12.8 because 64-bit data types are known to be not MISRA-conformant. This is just an example to be overruled by a user-defined implementation of an atomic 64-bit-store operation. */
+#if defined(VX1000_STIM_FORCE_V1)
+    if ((VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Enable < VX1000_STIM_DAQ_SENT)
+    {
+      (VX1000_STIMEVENT_ARRAYNAME)[stim_event - (VX1000_STIM_EVENT_OFFSET)].Enable = VX1000_STIM_DAQ_SENT;
+    }
+#endif /* VX1000_STIM_FORCE_V1 */
+    retVal = VX1000_STIM_RET_SUCCESS;              /* "Bypass active" */
+  }
+  return retVal;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassDaq                                                                                            */
+/* API name:      VX1000_BYPASS_DAQ (expression) / VX1000_BYPASS_DAQ_VOID (statement)                                         */
+/* Wrapper API:   VX1000If_BypassDaq (expression) / VX1000If_BypassDaqVoid (statement)                                        */
+/* Return value:  status: 0 (bypassed code shall be activated because bypassing is not active)                                */
+/*                1 (everything done, bypassed code shall be disabled)                                                        */
+/* Parameter1:    daq_event E [0,gVX1000.Olda.EventCount)                                                                     */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Parameter2:    stim_event E [VX1000_STIM_EVENT_OFFSET,gVX1000.Olda.EventCount)                                             */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Description:   Initiate a bypass by sending a DAQ event followed by a stim request                                         */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassDaq)( VX1000_UINT8 daq_event, VX1000_UINT8 stim_event )
+{
+  VX1000_UINT8 retVal = VX1000_BYPASS_TRIGGER(daq_event, stim_event);
+  if (retVal != (VX1000_STIM_RET_INACTIVE))
+  {
+    VX1000_STIM_REQUEST(stim_event)
+  }
+  return retVal;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassWait                                                                                           */
+/* API name:      VX1000_BYPASS_WAIT (expression) / VX1000_BYPASS_WAIT_VOID (statement)                                       */
+/* Wrapper API:   VX1000If_BypassWait (expression) / VX1000If_BypassWaitVoid (statement)                                      */
+/* Return value:  status: 0 (bypassed code shall be activated because bypassing is not active)                                */
+/*                1 (everything done, bypassed code shall be disabled)                                                        */
+/*                2 (bypassing failed; it\'s up to the application design whether executing the bypassed code makes sense here)*/
+/* Parameter1:    stim_event E [VX1000_STIM_EVENT_OFFSET,gVX1000.Olda.EventCount)                                             */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Parameter2:    timeout in microseconds, starting right now.                                                                */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Busy wait with timeout for the tool to complete a stimulation (stim_event) that has been initiated          */
+/*                beforehand by an appropriate call to VX1000_BYPASS_TRIGGER.                                                 */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassWait)( VX1000_UINT8 stim_event, VX1000_UINT32 timeout_us )
+{
+  VX1000_UINT8 retVal = 0;    /* 0 means "Bypass inactive, enable the bypassed code" */
+
+  if (VX1000_STIM_ACTIVE(stim_event) != 0)
+  {
+    VX1000_STIM_REQUEST(stim_event)
+    if ((VX1000_STIM_WAIT(stim_event, timeout_us)) != 0) /* note: do NOT use VX1000_STIM_RET_SUCCESS here because STIM_WAIT\'s return codes differ from STIM_EVENT\'s! */
+    {
+      retVal = 2;           /* "Bypass active, timeout. It may be too late to enable the bypassed code" */
+    }
+    else
+    {
+      retVal = 1;           /* "Bypass active, ok, disable the bypassed code" */
+    }
+  }
+  return retVal;
+}
+
+#if defined(VX1000_HOOK_BASED_BYPASSING)
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassHbbHookValid                                                                                   */
+/* API name:      None                                                                                                        */
+/* Return value:  status: 0 (the given hook is not valid: invalid ID, stim inactive, invalid LUT address, no valid stim data) */
+/*                1 (the given hook is valid and has valid data ready)                                                        */
+/* Parameter1:    HookID H [0,VX1000_BYPASS_HBB_LUT_ENTRIES)                                                                  */
+/*                Validity checked by the function                                                                            */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Check whether valid data corresponding to the given Hook ID is present in the buffer                        */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassHbbHookValid)(VX1000_UINT32 HookID)
+{
+  VX1000_UINT8 retVal = 0;
+  /* First check whether the hook table has a valid pointer and if the hook is valid */
+  if ( (gVX1000.Stim.hbbLUTVXPointer != 0) && (HookID < VX1000_BYPASS_HBB_LUT_ENTRIES) )
+  {
+    /* Is the stim event valid and the olda address set */
+    if ( (VX1000_STIM_ACTIVE((VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent)) && ((VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress != 0xFFFF) ) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    {
+#if defined(VX1000_BYPASS_ALL_CHANS_STIMD) && defined(VX1000_STIM_FORCE_V1)
+#if defined(VX1000_IS_INSTANT_BYP_ALLOWED)
+      VX1000_UINT8 bypassAreAllChansStimd = VX1000_SUFFUN(vx1000_BypassAreAllChansStimd)();
+      /* Does this channel not need to wait for other channels OR have all channels been stimulated */
+      if (((VX1000_IS_INSTANT_BYP_ALLOWED((VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent)) && (gVX1000.Stim.Events.Event[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent - (VX1000_STIM_EVENT_OFFSET)].Enable == VX1000_STIM_BUFFER_VALID)) || (bypassAreAllChansStimd == 1)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */ /* PRQA S 3356 */ /* cannot avoid violating MISRA rule 13.7 because of dependency on user-defined callback not guaranteed to be evaluable at compile time */
+#else /* !VX1000_IS_INSTANT_BYP_ALLOWED */
+      /* Have all channels been stimulated */
+      if (VX1000_SUFFUN(vx1000_BypassAreAllChansStimd)() == 1)
+#endif /* !VX1000_IS_INSTANT_BYP_ALLOWED */
+#else /* !VX1000_BYPASS_ALL_CHANS_STIMD || !VX1000_STIM_FORCE_V1 */
+      /* Has this single channel been stimulated */
+      if (gVX1000.Stim.Events.Event[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent - (VX1000_STIM_EVENT_OFFSET)].Enable == VX1000_STIM_BUFFER_VALID) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* !VX1000_BYPASS_ALL_CHANS_STIMD || !VX1000_STIM_FORCE_V1 */
+      {
+        {
+          retVal = 1;
+        }
+      }
+    }
+  }
+  return retVal;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassHbbGetVal_8                                                                                    */
+/* API name:      VX1000_BYPASS_HBB_GETVAL_8 (expression)                                                                     */
+/* Wrapper API:   VX1000If_BypassHbbGetval8  (expression)                                                                     */
+/* Return value:  VX1000_UINT8 corresponding to the stimulated value if hook is valid and data available                      */
+/*                DefaultValue is returned otherwise                                                                          */
+/* Parameter1:    HookID H [0,VX1000_BYPASS_HBB_LUT_ENTRIES)                                                                  */
+/*                Validity checked by the function                                                                            */
+/* Parameter2:    DefaultValue D to be returned if hook is not valid                                                          */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Check whether valid data corresponding to the given Hook ID is present in the buffer                        */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_BypassHbbGetVal_8)(VX1000_UINT32 HookID, VX1000_UINT8 DefaultValue)
+{
+  if ((VX1000_SUFFUN(vx1000_BypassHbbHookValid)(HookID)) != 0)
+  {
+    VX1000_OLDA_EVENT_T *pEventList = VX1000_ADDR_TO_PTR2OE(gVX1000.Olda.EventList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    VX1000_UINT8 *src = VX1000_ADDR_TO_PTR2U8(pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    DefaultValue = src[0];
+  }
+  return DefaultValue;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassHbbGetVal_16                                                                                   */
+/* API name:      VX1000_BYPASS_HBB_GETVAL_16 (expression)                                                                    */
+/* Wrapper API:   VX1000If_BypassHbbGetval16  (expression)                                                                    */
+/* Return value:  VX1000_UINT16 corresponding to the stimulated value if hook is valid and data available                     */
+/*                DefaultValue is returned otherwise                                                                          */
+/* Parameter1:    HookID H [0,VX1000_BYPASS_HBB_LUT_ENTRIES)                                                                  */
+/*                Validity checked by the function                                                                            */
+/* Parameter2:    DefaultValue D to be returned if hook is not valid                                                          */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Check whether valid data corresponding to the given Hook ID is present in the buffer                        */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT16 VX1000_SUFFUN(vx1000_BypassHbbGetVal_16)(VX1000_UINT32 HookID, VX1000_UINT16 DefaultValue)
+{
+  volatile VX1000_UINT16 newValue = DefaultValue; /* take a volatile copy because some compilers do not realise that we modify it via pointers and thus return the original value */
+  if ((VX1000_SUFFUN(vx1000_BypassHbbHookValid)(HookID)) != 0)
+  {
+    VX1000_OLDA_EVENT_T *pEventList = VX1000_ADDR_TO_PTR2OE(gVX1000.Olda.EventList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    if (((pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress) & (sizeof(DefaultValue) - 1UL)) != 0UL) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    {
+      volatile VX1000_UINT8 *dst = VX1000_ADDR_TO_PTR2VU8(VX1000_PTR2VU16_TO_ADDRESS(&newValue)), *src = VX1000_ADDR_TO_PTR2VU8(pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      VX1000_UINT8 i;
+      for (i = 0; i < sizeof(DefaultValue); ++i)
+      {
+        dst[i] = src[i];
+      }
+    }
+    else
+    {
+      newValue = VX1000_ADDR_TO_PTR2VU16(pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress)[0];/* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+  }
+  return newValue;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassHbbGetVal_32                                                                                   */
+/* API name:      VX1000_BYPASS_HBB_GETVAL_32 (expression)                                                                    */
+/* Wrapper API:   VX1000If_BypassHbbGetval32  (expression)                                                                    */
+/* Return value:  VX1000_UINT32 corresponding to the stimulated value if hook is valid and data available                     */
+/*                DefaultValue is returned otherwise                                                                          */
+/* Parameter1:    HookID H [0,VX1000_BYPASS_HBB_LUT_ENTRIES)                                                                  */
+/*                Validity checked by the function                                                                            */
+/* Parameter2:    DefaultValue D to be returned if hook is not valid                                                          */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Check whether valid data corresponding to the given Hook ID is present in the buffer                        */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT32 VX1000_SUFFUN(vx1000_BypassHbbGetVal_32)(VX1000_UINT32 HookID, VX1000_UINT32 DefaultValue)
+{
+  volatile VX1000_UINT32 newValue = DefaultValue; /* take a volatile copy because some compilers do not realise that we modify it via pointers and thus return the original value */
+  if ((VX1000_SUFFUN(vx1000_BypassHbbHookValid)(HookID)) != 0)
+  {
+    VX1000_OLDA_EVENT_T *pEventList = VX1000_ADDR_TO_PTR2OE(gVX1000.Olda.EventList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    if (((pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress) & (sizeof(DefaultValue) - 1UL)) != 0UL) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    {
+      volatile VX1000_UINT8 *dst = VX1000_ADDR_TO_PTR2VU8(VX1000_PTR2VU32_TO_ADDRESS(&newValue)), *src = VX1000_ADDR_TO_PTR2VU8(pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      VX1000_UINT8 i;
+      for (i = 0; i < sizeof(DefaultValue); ++i)
+      {
+        dst[i] = src[i];
+      }
+    }
+    else
+    {
+      newValue = VX1000_ADDR_TO_PTR2VU32(pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress)[0];/* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+  }
+  return newValue;
+}
+
+#if defined(VX1000_UINT64)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassHbbGetVal_64                                                                                   */
+/* API name:      VX1000_BYPASS_HBB_GETVAL_64 (expression)                                                                    */
+/* Wrapper API:   VX1000If_BypassHbbGetval64  (expression)                                                                    */
+/* Return value:  VX1000_UINT64 corresponding to the stimulated value if hook is valid and data available                     */
+/*                DefaultValue is returned otherwise                                                                          */
+/* Parameter1:    HookID H [0,VX1000_BYPASS_HBB_LUT_ENTRIES)                                                                  */
+/*                Validity checked by the function                                                                            */
+/* Parameter2:    DefaultValue D to be returned if hook is not valid                                                          */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Check whether valid data corresponding to the given Hook ID is present in the buffer                        */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT64 VX1000_SUFFUN(vx1000_BypassHbbGetVal_64)(VX1000_UINT32 HookID, VX1000_UINT64 DefaultValue)
+{
+  volatile VX1000_UINT64 newValue = DefaultValue; /* take a volatile copy because some compilers do not realise that we modify it via pointers and thus return the original value */
+  if ((VX1000_SUFFUN(vx1000_BypassHbbHookValid)(HookID)) != 0)
+  {
+    VX1000_OLDA_EVENT_T *pEventList = VX1000_ADDR_TO_PTR2OE(gVX1000.Olda.EventList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    if (((pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress) & (sizeof(DefaultValue) - 1UL)) != 0UL) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    {
+      volatile VX1000_UINT8 *dst = VX1000_ADDR_TO_PTR2VU8(VX1000_PTR2VU64_TO_ADDRESS(&newValue)), *src = VX1000_ADDR_TO_PTR2VU8(pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      VX1000_UINT8 i;
+      for (i = 0; i < sizeof(DefaultValue); ++i)
+      {
+        dst[i] = src[i];
+      }
+    }
+    else
+    {
+      newValue = VX1000_ADDR_TO_PTR2VU64(pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress)[0];/* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+  }
+  return newValue;
+}
+#endif /* VX1000_UINT64 */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassHbbGetVal_Float                                                                                */
+/* API name:      VX1000_BYPASS_HBB_GETVAL_FLOAT (expression)                                                                 */
+/* Wrapper API:   VX1000If_BypassHbbGetvalFloat  (expression)                                                                 */
+/* Return value:  VX1000_FLOAT corresponding to the stimulated value if hook is valid and data available                      */
+/*                DefaultValue is returned otherwise                                                                          */
+/* Parameter1:    HookID H [0,VX1000_BYPASS_HBB_LUT_ENTRIES)                                                                  */
+/*                Validity checked by the function                                                                            */
+/* Parameter2:    DefaultValue D to be returned if hook is not valid                                                          */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Check whether valid data corresponding to the given Hook ID is present in the buffer                        */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_FLOAT VX1000_SUFFUN(vx1000_BypassHbbGetVal_Float)(VX1000_UINT32 HookID, VX1000_FLOAT DefaultValue)
+{
+  volatile VX1000_FLOAT newValue = DefaultValue; /* take a volatile copy because some compilers do not realise that we modify it via pointers and thus return the original value */
+  if ((VX1000_SUFFUN(vx1000_BypassHbbHookValid)(HookID)) != 0)
+  {
+    VX1000_OLDA_EVENT_T *pEventList = VX1000_ADDR_TO_PTR2OE(gVX1000.Olda.EventList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    if (((pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress) & (sizeof(DefaultValue) - 1UL)) != 0UL) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    {
+      volatile VX1000_UINT8 *dst = VX1000_ADDR_TO_PTR2VU8(VX1000_PTR2VF_TO_ADDRESS(&newValue)), *src = VX1000_ADDR_TO_PTR2VU8(pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      VX1000_UINT8 i;
+      for (i = 0; i < sizeof(DefaultValue); ++i)
+      {
+        dst[i] = src[i];
+      }
+    }
+    else
+    {
+      newValue = VX1000_ADDR_TO_PTR2VF(pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress)[0];/* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+  }
+  return newValue;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_BypassHbbGetVal_Double                                                                               */
+/* API name:      VX1000_BYPASS_HBB_GETVAL_DOUBLE (expression)                                                                */
+/* Wrapper API:   VX1000If_BypassHbbGetvalDouble  (expression)                                                                */
+/* Return value:  VX1000_DOUBLE corresponding to the stimulated value if hook is valid and data available                     */
+/*                DefaultValue is returned otherwise                                                                          */
+/* Parameter1:    HookID H [0,VX1000_BYPASS_HBB_LUT_ENTRIES)                                                                  */
+/*                Validity checked by the function                                                                            */
+/* Parameter2:    DefaultValue D to be returned if hook is not valid                                                          */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Check whether valid data corresponding to the given Hook ID is present in the buffer                        */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_DOUBLE VX1000_SUFFUN(vx1000_BypassHbbGetVal_Double)(VX1000_UINT32 HookID, VX1000_DOUBLE DefaultValue)
+{
+  volatile VX1000_DOUBLE newValue = DefaultValue; /* take a volatile copy because some compilers do not realise that we modify it via pointers and thus return the original value */
+  if ((VX1000_SUFFUN(vx1000_BypassHbbHookValid)(HookID)) != 0)
+  {
+    VX1000_OLDA_EVENT_T *pEventList = VX1000_ADDR_TO_PTR2OE(gVX1000.Olda.EventList); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    if (((pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress) & (sizeof(DefaultValue) - 1UL)) != 0UL) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    {
+      volatile VX1000_UINT8 *dst = VX1000_ADDR_TO_PTR2VU8(VX1000_PTR2VD_TO_ADDRESS(&newValue)), *src = VX1000_ADDR_TO_PTR2VU8(pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      VX1000_UINT8 i;
+      for (i = 0; i < sizeof(DefaultValue); ++i)
+      {
+        dst[i] = src[i];
+      }
+    }
+    else
+    {
+      newValue = VX1000_ADDR_TO_PTR2VD(pEventList[(VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].StimEvent].TransferDest + (VX1000_ADDR_TO_PTR2VTE(gVX1000.Stim.hbbLUTVXPointer))[HookID].OldaAddress)[0];/* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+  }
+  return newValue;
+}
+#endif /* VX1000_HOOK_BASED_BYPASSING */
+
+
+#if defined(VX1000_STIM_BY_OLDA)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_Stimulate                                                                                            */
+/* API name:      VX1000_STIMULATE (expression) / VX1000_STIMULATE_VOID (statement)                                           */
+/* Wrapper API:   VX1000If_Stimulate (expression) / VX1000If_StimulateVoid (statement)                                        */
+/* Return value:  status: 0 (bypassed code shall be activated because bypassing is not active)                                */
+/*                1 (everything done, bypassed code shall be disabled)                                                        */
+/*                2 (bypassing failed; it\'s up to the application design whether executing the bypassed code makes sense here)*/
+/* Parameter1:    stim_trigger_event E [0,gVX1000.Olda.EventCount)                                                            */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Parameter2:    stim_event E [VX1000_STIM_EVENT_OFFSET,gVX1000.Olda.EventCount)                                             */
+/*                Validity has to be ensured by caller!                                                                       */
+/* Parameter3:    cycle_delay specifies the number of cycles between the triggering and the associated stimulation.           */
+/*                During first cycle_delay cycles there\'s no stimulation in the ECU; instead VX device fills its STIM FIFO.   */
+/* Parameter4:    timeout in microseconds, starting right now.                                                                */
+/*                Hint: the timeout may be chosen as small as zero when cycle_delay > 0                                       */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Initiate a bypass by requesting a stimulation (stim_trigger_event) without sending DAQ data,                */
+/*                and after the first cycle_delay calls, also busy wait with timeout for the tool to actually complete        */
+/*                the stimulation (stim_event). In the meantime, the requested data stay in the VX internal pipeline          */
+/*                and are used later. This pipeline depth / initial delay has to be considered when generating the stim data. */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_Stimulate)( VX1000_UINT8 stim_trigger_event, VX1000_UINT8 stim_event,
+                                              VX1000_UINT8 cycle_delay, VX1000_UINT32 timeout_us)
+{
+  VX1000_UINT8 retVal = 0; /* means "Stim not active" */
+
+  if (0==cycle_delay)
+  {
+    /* If cycle_delay is 0, stimulation has normal bypass behaviour */
+    retVal = VX1000_SUFFUN(vx1000_Bypass)(stim_trigger_event, stim_event, timeout_us);
+  }
+  else
+  {
+    if (VX1000_STIM_ACTIVE(stim_event) != 0)
+    {
+      if (0==((VX1000_STIMEVENT_ARRAYNAME)[(stim_event) - (VX1000_STIM_EVENT_OFFSET)].Copying)) /* (Pipelined STIM feature reuses the events copying flag as cycle delay counter) */
+      {
+        /* Delay period has expired */
+        /* Wait for stimulation data available in the OLDA buffer and stimulate */
+#if !defined(VX1000_STIM_FORCE_V1)
+        if ((VX1000_STIM_WAIT(stim_event, timeout_us)) != 0)
+        {
+          /* We cannot distinguish the cases "EOF_stimfile reached, no more data" and    */
+          /* "timeout requirement just too hard, stim data still waiting in the queue".  */
+          /* In either case we do NOT try to pre-fetch further data and we always signal */
+          /* "Stim (still) active, Timeout" to the caller: */
+          retVal = 2;
+        }
+        else
+        {
+          VX1000_STIM_REQUEST(stim_event)     /* Request stimulation data */
+          VX1000_EVENT(stim_trigger_event)    /* Trigger a stimulation */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* macro expansion contains VX1000_ADDR_TO_PTR2XXX: cannot avoid violating MISRA rule 11.3 because in a few configurations a peripheral register at a fix HW address must be accessed via pointer to update the HW value */ /* PRQA S 0501 */ /* Violation of MISRA rule 12.8 because 64-bit data types are known to be not MISRA-conformant. This is just an example to be overruled by a user-defined implementation of an atomic 64-bit-store operation. */
+          retVal = 1;                         /* Stim active, OK */
+        }
+      }
+      else
+      {
+        (VX1000_STIMEVENT_ARRAYNAME)[(stim_event) - (VX1000_STIM_EVENT_OFFSET)].Copying--; /* (Pipelined STIM feature reuses the events copying flag as cycle delay counter) */
+        VX1000_EVENT(stim_trigger_event)      /* Trigger a stimulation */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* macro expansion contains VX1000_ADDR_TO_PTR2XXX: cannot avoid violating MISRA rule 11.3 because in a few configurations a peripheral register at a fix HW address must be accessed via pointer to update the HW value */ /* PRQA S 0501 */ /* Violation of MISRA rule 12.8 because 64-bit data types are known to be not MISRA-conformant. This is just an example to be overruled by a user-defined implementation of an atomic 64-bit-store operation. */
+        if (0==((VX1000_STIMEVENT_ARRAYNAME)[(stim_event) - (VX1000_STIM_EVENT_OFFSET)].Copying)) /* (Pipelined STIM feature reuses the events copying flag as cycle delay counter) */
+        {
+          VX1000_STIM_REQUEST(stim_event)     /* Request stimulation data */
+#else /* VX1000_STIM_FORCE_V1 */
+        if ((VX1000_STIM_WAIT(stim_event, timeout_us)) != 0)
+        {
+          /* We cannot distinguish the cases "EOF_stimfile reached, no more data" and    */
+          /* "timeout requirement just too hard, stim data still waiting in the queue".  */
+          /* In either case we do NOT try to pre-fetch further data and we always signal */
+          /* "Stim (still) active, Timeout" to the caller: */
+          retVal = 2;
+        }
+        else
+        {
+          VX1000_BYPASS_TRIGGER_VOID(stim_trigger_event, stim_event)   /* Trigger a stimulation */
+          VX1000_STIM_REQUEST_EVENT(stim_event)                        /* Request stimulation data */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          retVal = 1;                                                  /* Stim active, OK */
+        }
+      }
+      else
+      {
+        (VX1000_STIMEVENT_ARRAYNAME)[(stim_event) - (VX1000_STIM_EVENT_OFFSET)].Copying--;        /* (Pipelined STIM feature reuses the events copying flag as cycle delay counter) */
+        VX1000_BYPASS_TRIGGER_VOID(stim_trigger_event, stim_event)                                /* Trigger a stimulation */
+        if (0==((VX1000_STIMEVENT_ARRAYNAME)[(stim_event) - (VX1000_STIM_EVENT_OFFSET)].Copying)) /* (Pipelined STIM feature reuses the events copying flag as cycle delay counter) */
+        {
+          VX1000_STIM_REQUEST_EVENT(stim_event)                                                   /* Request stimulation data */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_STIM_FORCE_V1 */
+        } /* common closing brace for STIMv0 and STIMv1 */
+        /* Stim not active, start-up delay still in progress */
+      }
+    } /* if Stim active */
+    else
+    {
+      if (cycle_delay > 100) { cycle_delay = 100; } /* Silently ensures to not exceed the VX\'s maximum queue size */
+      (VX1000_STIMEVENT_ARRAYNAME)[(stim_event) - (VX1000_STIM_EVENT_OFFSET)].Copying = cycle_delay; /* (Pipelined STIM feature reuses the events copying flag as cycle delay counter) */
+    } /* if Stim not active */
+  } /* if cycle_delay > 0 */
+
+  return retVal;
+}
+#endif /* VX1000_STIM_BY_OLDA */
+#endif /* VX1000_STIM */
+
+
+#if (defined(VX1000_OVERLAY) && (!defined(VX1000_COMPILED_FOR_SLAVECORES)))
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlayInit                                                                                          */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Initialises the global variables that are used by the overlay functions.                                    */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static void VX1000_SUFFUN(vx1000_OverlayInit)(void)
+{
+  gVX1000.Ovl.presenceCounter = 0;
+  gVX1000.Ovl.ovlConfigValue  = 0;
+  gVX1000.Ovl.ovlConfigMask   = 0;
+  gVX1000.Ovl.calFeaturesEnable = 0
+#if defined(VX1000_OVLENBL_KEEP_AWAKE)
+                                | (VX1000_OVLFEAT_KEEP_AWAKE)
+#endif /* VX1000_OVLENBL_KEEP_AWAKE */
+#if defined(VX1000_OVLENBL_SYNC_PAGESWITCH)
+                                | (VX1000_OVLFEAT_SYNC_PAGESWITCH)
+#endif /* VX1000_OVLENBL_SYNC_PAGESWITCH */
+#if defined(VX1000_OVLENBL_PERSISTENT_EMEM)
+                                | (VX1000_OVLFEAT_PERSISTENT_EMEM)
+#endif /* VX1000_OVLENBL_PERSISTENT_EMEM */
+#if defined(VX1000_OVLENBL_RST_ON_CALWAKEUP)
+                                | (VX1000_OVLFEAT_RST_ON_CALWAKEUP)
+#endif /* VX1000_OVLENBL_RST_ON_CALWAKEUP */
+#if defined(VX1000_OVLENBL_USE_VX_EPK_TRANS)
+                                | (VX1000_OVLFEAT_USE_VX_EPK_TRANS)
+#endif /* VX1000_OVLENBL_USE_VX_EPK_TRANS */
+#if defined(VX1000_OVLENBL_VALIDATE_PAGESW)
+                                | (VX1000_OVLFEAT_VALIDATE_PAGESW)
+#endif /* VX1000_OVLENBL_VALIDATE_PAGESW */
+#if defined(VX1000_OVLENBL_CORE_SYNC_PAGESW)
+                                | (VX1000_OVLFEAT_CORE_SYNC_PAGESW)
+#endif /* VX1000_OVLENBL_CORE_SYNC_PAGESW */
+#if defined(VX1000_OVERLAY_VX_CONFIGURABLE)
+                                | (VX1000_OVLFEAT_VX)
+#elif defined(VX1000_OVERLAY_USERMANAGED)
+                                | (VX1000_OVLFEAT_USER)
+#else /* any of the built-in methods of the driver*/
+                                | (VX1000_OVLFEAT_DRIVER)
+#endif /* !VX1000_OVERLAY_VX_CONFIGURABLE && !VX1000_OVERLAY_USERMANAGED */
+#if (defined(VX1000_OVERLAY_VX_CONFIGURABLE)) && (defined(VX1000_OVLENBL_REGWRITE_VIA_MX)) && (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_OVERLAY_CONTROL))
+                                | (VX1000_OVLFEAT_ECU_REGS_VIA_MX)
+#endif /* VX1000_OVERLAY_VX_CONFIGURABLE & VX1000_OVLENBL_REGWRITE_VIA_MX & VX1000_MAILBOX & VX1000_MAILBOX_OVERLAY_CONTROL */
+#if defined(VX1000_OVLENBL_RST_ON_SNCPAGESW)
+                                | (VX1000_OVLFEAT_RST_ON_SNCPAGESW)
+#endif /* VX1000_OVLENBL_RST_ON_SNCPAGESW */
+                                ;
+
+  gVX1000.Ovl.persistentECUEmemHeaderPtr = VX1000_EMEM_HDR_PTR;
+#if defined(VX1000_OVLENBL_CORE_SYNC_PAGESW) || defined(VX1000_OVLENBL_SYNC_PAGESWITCH)
+  gVX1000.Ovl.ovlBusMasterMask = VX1000_OVL_CAL_BUS_MASTER;
+#endif /* VX1000_OVLENBL_CORE_SYNC_PAGESW */
+  gVX1000.Ovl.ecuLastPresenceCounter = 0;
+#if defined(VX1000_OVLENBL_USE_VX_EPK_TRANS)
+  gVX1000.Ovl.ovlEPKLength = (VX1000_UINT16)(VX1000_OVL_EPK_LENGTH);
+  gVX1000.Ovl.ovlReferencePageDataEPKAddress = ((VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32) (VX1000_OVL_EPK_REFPAGE_ADDR));
+  gVX1000.Ovl.ovlWorkingPageDataEPKAddress = 0xFFFFFFFFUL;
+#else /* !VX1000_OVLENBL_USE_VX_EPK_TRANS */
+  gVX1000.Ovl.ovlEPKLength = 0U;
+#if (defined(VX1000_OVERLAY_ADDR) && defined(VX1000_OVERLAY_SIZE)) && defined(VX1000_CALRAM_ADDR)
+  for (gVX1000.Ovl.ovlReferencePageDataEPKAddress = VX1000_OVERLAY_SIZE; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+       gVX1000.Ovl.ovlReferencePageDataEPKAddress > 0x0800UL;
+       gVX1000.Ovl.ovlReferencePageDataEPKAddress >>= 1)
+  {
+    gVX1000.Ovl.ovlEPKLength += 0x1000U;
+  }
+  gVX1000.Ovl.ovlEPKLength |= (VX1000_UINT16)gVX1000.Ovl.ovlReferencePageDataEPKAddress;
+  gVX1000.Ovl.ovlReferencePageDataEPKAddress = ((VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32) (VX1000_OVERLAY_ADDR)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  gVX1000.Ovl.ovlWorkingPageDataEPKAddress = ((VX1000_INNERSTRUCT_VOLATILE VX1000_UINT32) VX1000_CALRAM_PHYSADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else /* !VX1000_OVERLAY_ADDR || !VX1000_OVERLAY_SIZE || !VX1000_CALRAM_ADDR */
+  gVX1000.Ovl.ovlReferencePageDataEPKAddress = 0UL;
+  gVX1000.Ovl.ovlWorkingPageDataEPKAddress = 0UL;
+#endif /* !VX1000_OVERLAY_ADDR || !VX1000_OVERLAY_SIZE || !VX1000_CALRAM_ADDR */
+#endif /* !VX1000_OVLENBL_USE_VX_EPK_TRANS */
+  gVX1000.Ovl.syncCalSwitchDataPtr = (VX1000_PTR2SPS_TO_ADDRESS(&gVX1000.Ovl.syncCalData));  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  gVX1000.Ovl.version = VX1000_OVL_VERSION;
+
+  if (gVX1000.Ovl.persistentECUEmemHeaderPtr != 0)
+  {
+    vx1000_EmemHdrInit();
+  }
+
+#if defined(VX1000_MAILBOX_OVERLAY_CONTROL)
+  gVX1000_XCP_CalPage = VX1000_CALPAGE_FLASH;
+  gVX1000_ECU_CalPage = VX1000_CALPAGE_FLASH;
+#endif /* VX1000_MAILBOX_OVERLAY_CONTROL */
+
+#if (defined(VX1000_OVERLAY)) && (defined(VX1000_OVERLAY_VX_CONFIGURABLE)) && (defined(VX1000_OVLENBL_REGWRITE_VIA_MX)) && (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_OVERLAY_CONTROL))
+  gVX1000.Ovl.ovlConfigRegsPtr = (VX1000_PTR2OCR_TO_ADDRESS(&gVX1000.Ovl.ovlConfigRegs)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  if (VX1000_SUFFUN(vx1000_OverlayReadEcuDescr)() != 0)
+  {
+    gVX1000.Ovl.ovlConfigRegsPtr = 0;  /* the feature seems not to be supported, yet. The error is already logged by the callee */
+  }
+#else /* !VX1000_OVERLAY || !VX1000_OVERLAY_VX_CONFIGURABLE || !VX1000_OVLENBL_REGWRITE_VIA_MX || !VX1000_MAILBOX || !VX1000_MAILBOX_OVERLAY_CONTROL */
+  gVX1000.Ovl.ovlConfigRegsPtr = 0;    /* the feature is disabled */
+#endif /* !VX1000_OVERLAY || !VX1000_OVERLAY_VX_CONFIGURABLE || !VX1000_OVLENBL_REGWRITE_VIA_MX || !VX1000_MAILBOX || !VX1000_MAILBOX_OVERLAY_CONTROL */
+
+  gVX1000.ToolDetectState &= ~(VX1000_TDS_WORKING_PAGE);
+  if ( (VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.Ovl.ovlConfigValue)) != (0x8UL + VX1000_PTR2VOVL_TO_ADDRESS(&gVX1000.Ovl)) ) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  {
+    gVX1000.ToolDetectState |= VX1000_TDS_ERROR;
+    VX1000_ERRLOGGER(VX1000_ERRLOG_STRUCTS_PADDED)
+  }
+  gVX1000.Ovl.syncCalData.pageSwitchRequested = 0;
+  gVX1000.Ovl.magicId = VX1000_OVL_MAGIC;
+}
+
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_EmemHdrInit                                                                                          */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Reset the EmemHdr related VX1000 structure data                                                             */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static void VX1000_SUFFUN(vx1000_EmemHdrInit)(void)
+{
+  VX1000_EMEM_HDR_T *hdr = VX1000_ADDR_TO_PTR2EH(gVX1000.Ovl.persistentECUEmemHeaderPtr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  volatile VX1000_UINT32 * const addr =  (VX1000_ADDR_TO_PTR2U32(gVX1000.Ovl.persistentECUEmemHeaderPtr)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  /* dummy access the memory of the magic ID, the version and reserved fields by 32bit-writes to initialise the ECC hardware: */
+  addr[0] = addr[1] = 0UL;
+
+  /* now the hardware will accept smaller-then-32bit accesses to the same memory. Do the actual initialisation */
+  hdr->version = VX1000_EMEM_HDR_VERSION;
+  hdr->reserved = 0; /* Initialise the reserved field for CRC-reasons */
+  hdr->magicId = VX1000_EMEM_HDR_MAGIC;
+}
+
+#endif /* VX1000_OVERLAY & !VX1000_COMPILED_FOR_SLAVECORES */
+
+
+#if defined(VX1000_RES_MGMT) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_ResMgmtInit                                                                                          */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Reset the Resource Management related VX1000 structure data                                                 */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static void VX1000_SUFFUN(vx1000_ResMgmtInit)(void)
+{
+  gVX1000.ResMgmt.resMgmtEnable = 0UL; /* PRQA S 3198 */ /* this global volatile variable is accessed by debug tool in the background */
+
+  gVX1000.ResMgmt.version = VX1000_RES_MGMT_VERSION;
+  gVX1000.ResMgmt.ovlConfigItemStart  = (VX1000_UINT8)(VX1000_RES_MGMT_CFG_ITEM_START);
+  gVX1000.ResMgmt.ovlConfigItemLength = (VX1000_UINT8)(VX1000_RES_MGMT_CFG_ITEM_LEN);
+
+  gVX1000.ResMgmt.ovlRamStart   = (VX1000_UINT32)(VX1000_RES_MGMT_RAM_START);
+  gVX1000.ResMgmt.ovlRamSize    = (VX1000_UINT32)(VX1000_RES_MGMT_RAM_SIZE);
+
+  gVX1000.ResMgmt.resMgmtEnable = (VX1000_RES_MGMT_ENBLVAL_CFG_ITEM)
+                                | (VX1000_RES_MGMT_ENBLVAL_OVL_RAM);
+  if ( (VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.ResMgmt.resMgmtEnable)) != (0x8UL + (VX1000_RES_MGMT_PTR)) ) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  {
+    gVX1000.ToolDetectState |= VX1000_TDS_ERROR;
+    VX1000_ERRLOGGER(VX1000_ERRLOG_STRUCTS_PADDED)
+  }
+  gVX1000.ResMgmt.magicId = VX1000_RES_MGMT_MAGIC;
+}
+
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_DisableAccess                                                                                        */
+/* API name:      VX1000_DISABLE_ACCESS (expression) / VX1000_DISABLE_ACCESS_VOID (statement)                                 */
+/* Wrapper API:   VX1000If_DisableAccess (expression) / VX1000If_DisableAccessVoid (statement)                                */
+/* Return value:  0 Disabled access successfully                                                                              */
+/*                1 VX1000 already detected. VX1000 access not disabled                                                       */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Disables the access of the VX1000 to the ECU resources. The VX1000 will prevent the MC from accessing       */
+/*                the microcontroller when the VX1000 access is disabled                                                      */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_DisableAccess)( void )
+{
+  VX1000_UINT8 retVal = 0;
+  if (VX1000_DETECTED())
+  {
+    retVal = 1;
+  }
+  else
+  {
+    VX1000_INVALIDATE_EMEM()
+    gVX1000.ToolDetectState |= VX1000_TDS_VX_ACCESS_DISABLED;
+  }
+  return retVal;
+}
+
+#endif /* VX1000_RES_MGMT & !VX1000_COMPILED_FOR_SLAVECORES */
+
+
+/*------------------------------------------------------------------------------- */
+/* Calibration (_classic_ version with fixed settings from VX1000_cfg.h)          */
+
+#if defined(VX1000_OVERLAY) && (!defined(VX1000_OVERLAY_VX_CONFIGURABLE))
+
+#if defined(VX1000_INIT_CAL_PAGE_INTERNAL)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlayHwInit                                                                                        */
+/* API name:      None (note: may be overloaded by user via VX1000_INIT_CAL_PAGE)                                             */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    bit0: allow update of the status variables;                                                                 */
+/*                bit1: allow RAM initialisation;                                                                             */
+/*                bit2: allow reconfiguration of the remap registers                                                          */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:                                                                                                               */
+/* Devel state:   Idea                                                                                                        */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static void VX1000_SUFFUN(vx1000_OverlayHwInit)(void)
+{
+  const VX1000_UINT32 overlaySize = (VX1000_UINT32)(VX1000_OVERLAY_SIZE);      /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  const VX1000_UINT32 overlayAddr = (VX1000_UINT32)(VX1000_OVERLAY_ADDR);      /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  const VX1000_UINT32 overlayPhys = (VX1000_UINT32)(VX1000_OVERLAY_PHYSADDR);  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  const VX1000_UINT32 calRamAddr  = (VX1000_UINT32)(VX1000_CALRAM_ADDR);       /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  /* ensure that the mapping is not already/still active (even if not needed on all derivatives) */
+
+#if defined(VX1000_DETECTION) || defined(VX1000_TARGET_TRICORE)
+  if ((!VX1000_DETECTED()) || ((gVX1000.ToolCtrlState & (VX1000_UINT32)(VX1000_TCS_SKIP_WP_INIT)) == 0)) /* skip internal overlay initialisation if a VX is connected and external overlay control has been requested */
+#endif /* VX1000_DETECTION || VX1000_TARGET_TRICORE */
+  {
+    /* Initialise CALRAM: copy original flash content to RAM, then map RAM over flash (with cache inhibit etc.) */
+#if (defined(VX1000_OVERLAY_TLB) || defined(VX1000_OVERLAY_DESCR_IDX)) || (defined(VX1000_MPC56xCRAM_BASE_ADDR) || defined(VX1000_SH2_FCU_BASE_ADDR))
+#if defined(VX1000_RUNNING_ON_MAINCORE) && (!defined(VX1000_OVLENBL_HW_INIT_PER_CORE))
+    if (VX1000_RUNNING_ON_MAINCORE() != 0)
+#endif /* VX1000_RUNNING_ON_MAINCORE && !VX1000_OVLENBL_HW_INIT_PER_CORE */
+    {
+#if defined(VX1000_OVLENBL_HW_INIT_PER_CORE) || (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+      (void)VX1000_SUFFUN(vx1000_MapCalRam)(overlaySize, overlayAddr, overlayAddr, overlayPhys); /* ensure that the mapping is not already/still active (even if not needed on all derivatives) */
+#endif /* VX1000_OVLENBL_HW_INIT_PER_CORE || !VX1000_COMPILED_FOR_SLAVECORES */
+    }
+#endif /* VX1000_OVERLAY_TLB | VX1000_OVERLAY_DESCR_IDX | VX1000_MPC56xCRAM_BASE_ADDR | VX1000_SH2_FCU_BASE_ADDR */
+#if defined(VX1000_RUNNING_ON_MAINCORE) && (!defined(VX1000_OVLENBL_MEMCPY_PER_CORE)) /* hint: considering VX1000_OVLENBL_MEMCPY_PER_CORE actually not needed up to now (self-addresses can\'t be measured anyway) */
+    if (VX1000_RUNNING_ON_MAINCORE() != 0)
+#endif /* VX1000_RUNNING_ON_MAINCORE && !VX1000_OVLENBL_MEMCPY_PER_CORE */
+    {
+#if defined(VX1000_OVLENBL_MEMCPY_PER_CORE) || (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+#if defined(VX1000_TARGET_XC2000)
+      VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+#else /* !VX1000_TARGET_XC2000 */
+      if ((((overlaySize | overlayAddr) | calRamAddr) & 0x3UL) != 0UL)
+      {
+        VX1000_UINT32 cnt;
+        volatile const VX1000_CHAR *pSrc = VX1000_ADDR_TO_PTR2VCC(overlayAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        volatile VX1000_CHAR *pDst = VX1000_ADDR_TO_PTR2VC(calRamAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        for (cnt = 0; cnt < overlaySize; cnt++)
+        {
+          pDst[cnt] = pSrc[cnt];
+        }
+      }
+      else
+      {
+        VX1000_UINT32 cnt;
+        volatile const VX1000_UINT32 *pSrc = VX1000_ADDR_TO_PTR2VCU32(overlayAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        volatile VX1000_UINT32 *pDst = VX1000_ADDR_TO_PTR2VU32(calRamAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        for (cnt = 0; cnt < (overlaySize >> 2U); cnt++)
+        {
+          pDst[cnt] = pSrc[cnt];
+        }
+      }
+#endif /* !VX1000_TARGET_XC2000 */
+#endif /* VX1000_OVLENBL_MEMCPY_PER_CORE || !VX1000_COMPILED_FOR_SLAVECORES */
+    }
+#if (defined(VX1000_OVERLAY_TLB) || defined(VX1000_OVERLAY_DESCR_IDX)) || (defined(VX1000_MPC56xCRAM_BASE_ADDR) || defined(VX1000_SH2_FCU_BASE_ADDR))
+#if defined(VX1000_RUNNING_ON_MAINCORE) && (!defined(VX1000_OVLENBL_HW_INIT_PER_CORE))
+    if (VX1000_RUNNING_ON_MAINCORE() != 0)
+#endif /* VX1000_RUNNING_ON_MAINCORE && !VX1000_OVLENBL_HW_INIT_PER_CORE */
+    {
+#if defined(VX1000_OVLENBL_HW_INIT_PER_CORE) || (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+      VX1000_WRP_SET_CAL_PAGE_VOID(0, VX1000_CALPAGE_RAM, ((VX1000_CAL_ECU) | (VX1000_CAL_XCP)), 1U)
+#endif /* VX1000_OVLENBL_HW_INIT_PER_CORE || !VX1000_COMPILED_FOR_SLAVECORES */
+    }
+#endif /* VX1000_OVERLAY_TLB | VX1000_OVERLAY_DESCR_IDX | VX1000_MPC56xCRAM_BASE_ADDR | VX1000_SH2_FCU_BASE_ADDR */
+  }
+}
+#endif /* VX1000_INIT_CAL_PAGE_INTERNAL */
+
+#if defined(VX1000_OVERLAY_TLB)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MapCalRam - may be overloaded internally for the used hardware                                       */
+/* API name:      None                                                                                                        */
+/* Return value:  status:                                                                                                     */
+/*                0: MMU not changed                                                                                          */
+/*                1: mapping complete                                                                                         */
+/* Parameter1:    Overlay window size                                                                                         */
+/* Parameter2:    properly aligned virtual flash access address                                                               */
+/* Parameter3:    overlay storage address (not used on MPC55xx/MPC56xx)                                                       */
+/* Parameter4:    physical address of Parameter2 or Parameter3                                                                */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for enabling/disabling a single overlay window using MPC555x MMU features.       */
+/*                Note: The driver is not responsible for the boot-up-initialisation of the TLB entry. The application\'s      */
+/*                boot code must have preinitialised all TLB entries in a way that the driver only needs to re-initialise     */
+/*                the TLB entry that is specified in VX1000_cfg.h.                                                            */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_MapCalRam)( VX1000_UINT32 size, VX1000_UINT32 target, VX1000_UINT32 source1, VX1000_UINT32 source2 )
+{
+  VX1000_UINT8 n = (VX1000_UINT8)(VX1000_OVERLAY_TLB); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  VX1000_UINT32 ea = target;
+  VX1000_UINT32 ra = source2;
+  volatile VX1000_UINT32 pagesize = size; /* the volatile is here to avoid compiler warnings because some compilers see that this static function is called with identical size parameter always */
+  VX1000_UINT8 properties  = 0x00
+#if defined(VX1000_OVERLAY_IS_LITTLE_ENDIAN)
+                           | 0x01    /* interpret data in this page as little instead of big endian */
+#endif /* VX1000_OVERLAY_IS_LITTLE_ENDIAN */
+                           | 0x00    /* NO suppression of speculative or out-of-order processing */
+                           | 0x00    /* NO force of coherence because e200 MMU does not support it */
+                           | 0x08    /* cache_inhibit to enable coherent views from all clients */
+                           | 0x00    /* NO cache_writethrough because it may not be set together with cache_inhibit on e200 MMUs! */
+#if defined(VX1000_OVERLAY_CONTAINS_VLECODE)
+                           | 0x20    /* interpret code from this page as VLE instead of BookE */
+#endif /* VX1000_OVERLAY_CONTAINS_VLECODE */
+                           ;
+  VX1000_UINT8 permissions = 0x3F;
+  VX1000_UINT32 rpn, epn;
+  VX1000_UINT8 pagetype, pageshift, retVal = 0;
+
+  switch (pagesize) /* note: supported sizes depend on the derivative (but if TLBs are supported, then at least 4K,16K,64K and 256K will work) */
+  {
+    case 0x001000UL: pagetype = 1U; pageshift = 12U; break; /*   4 K */
+    case 0x004000UL: pagetype = 2U; pageshift = 14U; break; /*  16 K */
+    case 0x010000UL: pagetype = 3U; pageshift = 16U; break; /*  64 K */
+    case 0x040000UL: pagetype = 4U; pageshift = 18U; break; /* 256 K */
+    case 0x100000UL: pagetype = 5U; pageshift = 20U; break; /*   1 M */
+    default: pagetype = 0U; pageshift = 0U; break;        /* invalid */
+  }
+  if (0==pagetype)
+  {
+    VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_INVALID_SIZE)
+    VX1000_DUMMYREAD(source1)                             /* just to avoid compiler "unused" warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  }
+  else if (((ra | ea) & (pagesize - 1)) != 0)
+  {
+    VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_MISALIGNED)
+  }
+  else
+  {
+    rpn = ra / pagesize;
+    epn = ea / pagesize;
+    VX1000_MPC_MMU_MTMAS0(0x10000000UL | (VX1000_UINT32)(((VX1000_UINT32)n) << 16U)) /* Select TLB entry */
+    VX1000_MPC_MMU_MTMAS1(0x80000000UL | (VX1000_UINT32)(((VX1000_UINT32)pagetype) << 8U))  /* VALID=1, IPROT=0, TID=0, TS=0, TSIZE=pagetype */
+    VX1000_MPC_MMU_MTMAS2((epn << pageshift) | (VX1000_UINT32)(0x3FU & properties))
+    VX1000_MPC_MMU_MTMAS3((rpn << pageshift) | (VX1000_UINT32)(0x3FU & permissions)) /* RPN = , U0:3=0, UX/SX=0, UR/SR=1, UW/SW=1 */
+    VX1000_MPC_MMU_TLBWE()  /* Make pre-charged entry from MAS0..MAS3 to valid as an MMU TLB */
+    retVal = 1;
+  }
+  return retVal;
+}
+
+#elif defined(VX1000_OVERLAY_DESCR_IDX)
+
+#if defined(VX1000_TARGET_POWERPC)
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MapCalRam - may be overloaded internally for the used hardware                                       */
+/* API name:      None                                                                                                        */
+/* Return value:  status:                                                                                                     */
+/*                0: requested overlay not possible                                                                           */
+/*                1: mapping complete                                                                                         */
+/* Parameter1:    Overlay window size                                                                                         */
+/* Parameter2:    properly aligned virtual flash access address                                                               */
+/* Parameter3:    overlay memory address (hard-wired on this hardware)                                                        */
+/*                If Parameter2 == Parameter3, the overlay is turned off completely.                                          */
+/* Parameter4:    physical address of Parameter3 (currently not used on MPC57xxX)                                             */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for enabling/disabling a single overlay window using MPC57xxM PFLASH features.   */
+/*                Note: The driver assumes exclusive ownership of the overlay unit.                                           */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_UINT32 size, VX1000_UINT32 target, VX1000_UINT32 source1, VX1000_UINT32 source2)
+{
+  VX1000_UINT8 retVal = 1U; /* return "mapping complete" by default */
+
+  if ((size > (8UL * (1024UL * 1024UL))) || ((size & (size - 1)) != 0))
+  {
+    VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_INVALID_SIZE)
+    retVal = 0; /* unsupported size specified */
+    VX1000_DUMMYREAD(source2) /* just to avoid compiler "unused" warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  }
+  else if (((target | source1) & (size - 1UL)) != 0UL)
+  {
+    VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_MISALIGNED)
+    retVal = 0; /* misaligned address specified */
+  }
+  else if (target==source1) /* turn mapping off */
+  {
+#if ((VX1000_OVERLAY_DESCR_IDX) < 16)
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0108UL + (((VX1000_OVERLAY_DESCR_IDX) + 16) << 4)))[0] = /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0108UL + (( VX1000_OVERLAY_DESCR_IDX      ) << 4)))[0] = 0x00000000UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else /* VX1000_OVERLAY_DESCR_IDX >= 16 */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0108UL + (((VX1000_OVERLAY_DESCR_IDX) & 31) << 4)))[0] = 0x00000000UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_OVERLAY_DESCR_IDX >= 16 */
+  }
+  else /* install the mapping */
+  {
+    VX1000_UINT32 ld_size;
+    for (ld_size = 0UL; (ld_size == ld_size) && ((1UL << ld_size) < size); ld_size++) { /* intentionally empty */ }
+#if !defined (VX1000_OVLENBL_CORE_SYNC_PAGESW)
+    ld_size |= 0xFFFF0000UL; /* assign the overlay to any available bus masters */
+#endif /* !VX1000_OVLENBL_CORE_SYNC_PAGESW */
+
+    if (0==(source1 & 0x01000000UL)) /* attention: this is MPC5746M/MPC5777M specific! */
+    {
+      (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0008UL))[0] |= 1 << 20; /* PFCR3.BDRM -> enable read accesses of buddy RAM because it\'s not an internal address */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x000CUL))[0] = 0xFFFFffffUL; /* PFAPR -> enable flash RW-accesses for all masters */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#if ((VX1000_OVERLAY_DESCR_IDX) < 16)
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0010UL))[0] = 0x00000111UL; /* PFCRCR -> enable overlay feature (secure mode) */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0100UL + ((((VX1000_OVERLAY_DESCR_IDX) + 16)) << 4)))[0] = /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0100UL + ((( VX1000_OVERLAY_DESCR_IDX      )) << 4)))[0] = target; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0104UL + ((((VX1000_OVERLAY_DESCR_IDX) + 16)) << 4)))[0] = /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0104UL + ((( VX1000_OVERLAY_DESCR_IDX      )) << 4)))[0] = source1; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0108UL + ((((VX1000_OVERLAY_DESCR_IDX) + 16)) << 4)))[0] = /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0108UL + ((( VX1000_OVERLAY_DESCR_IDX      )) << 4)))[0] = ld_size; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0014UL))[0] |= (1UL << (31 - ((VX1000_OVERLAY_DESCR_IDX) + 16))) | (1UL << (31 - (VX1000_OVERLAY_DESCR_IDX))); /* PFCRDE -> set descr valid */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else /* VX1000_OVERLAY_DESCR_IDX >= 16 */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0010UL))[0] = 0x00000011UL; /* PFCRCR -> enable overlay feature (big mode) */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0100UL + (((VX1000_OVERLAY_DESCR_IDX) & 31) << 4)))[0] = target; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0104UL + (((VX1000_OVERLAY_DESCR_IDX) & 31) << 4)))[0] = source1; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0108UL + (((VX1000_OVERLAY_DESCR_IDX) & 31) << 4)))[0] = ld_size; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x0014UL))[0] |= (1UL << (31 - ((VX1000_OVERLAY_DESCR_IDX) & 31))); /* PFCRDE -> set descr valid */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_OVERLAY_DESCR_IDX >= 16 */
+  }
+  return retVal;
+}
+
+#elif defined(VX1000_TARGET_TRICORE)
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MapCalRam - may be overloaded internally for the used hardware                                       */
+/* API name:      None                                                                                                        */
+/* Return value:  status:                                                                                                     */
+/*                0: requested overlay not possible                                                                           */
+/*                1: mapping complete                                                                                         */
+/* Parameter1:    Overlay window size                                                                                         */
+/* Parameter2:    properly aligned uncached flash access address                                                              */
+/* Parameter3:    overlay storage address (not used on TriCore)                                                               */
+/* Parameter4:    physical address of Parameter2 or Parameter3                                                                */
+/*                If RAM address == flash address, the overlay is turned off completely.                                      */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for enabling/disabling a single overlay window using TriCore overlay features.   */
+/*                Note: The driver assumes exclusive ownership of the overlay unit.                                           */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_MapCalRam)( VX1000_UINT32 size, VX1000_UINT32 target, VX1000_UINT32 source1, VX1000_UINT32 source2 )
+{
+  VX1000_UINT8 retVal = 1U; /* return "mapping complete" by default */
+  VX1000_UINT8 sfrModel = 0U; /* dummy initialisation to prevent compiler warnings */
+  VX1000_UINT32 validWindowSizes = 0x00000000UL;
+  VX1000_UINT32 rabrSpecBits = 0x00000000UL;
+
+  VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,0UL, (source1),(retVal),(sfrModel),(0)))  /* dummy accesses to avoid compiler/MISRA "unused"/"overwritten without prior usage" warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  switch ((VX1000_MCREG_CBS_JTAGID) & (VX1000_JTAGID_PN_MASK)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  {
+    case VX1000_JTAGID_PN_TC172x: /* FutureMax */
+      /* fallthrough to VX1000_JTAGID_PN_TC1797 */
+    case VX1000_JTAGID_PN_TC1387: /* AudoS */
+      /* fallthrough to VX1000_JTAGID_PN_TC1797 */
+    case VX1000_JTAGID_PN_TC178x: /* AudoMax */
+      /* fallthrough to VX1000_JTAGID_PN_TC1797 */
+    case VX1000_JTAGID_PN_TC1767: /* AudoFuture */
+      /* fallthrough to VX1000_JTAGID_PN_TC1797 */
+    case VX1000_JTAGID_PN_TC1797: /* AudoFuture */
+      /* note: we had to guess the RABR bits from the documentation of incompatible devices ... */
+      if (source2 >= 0xAFF00000UL) /* is it in EMEM (e.g. 512 Kb)? */
+      {
+        validWindowSizes = 0x0003FC00UL;
+        rabrSpecBits = 0xA0000000UL ^ 0xC0000000UL;  /* ?!? the manual spouts twaddle and the FW uses "0x4FF00000UL" instead ... */
+      }
+      else if (source2 >= 0xAFE80000UL) /* is it in PMU space (e.g. 8 Kb OVRAM)? */
+      {
+        validWindowSizes = 0x00000FF0UL;
+        rabrSpecBits = 0xA0000000UL ^ 0x80000000UL;  /* ?!? the manual spouts twaddle and the FW uses "0x4FF00000UL" instead ... */
+      }
+      else if (source2 >= 0xA0800000UL) /* is it in EBU space (external memory; size depends on board)? */
+      {
+        validWindowSizes = 0x0003FC00UL;
+        rabrSpecBits = 0xA0000000UL ^ 0xE0000000UL;  /* ?!? the manual spouts twaddle and the FW ignores it completely ... */
+      }
+      else
+      {
+        ; /* dummy else with empty statement only here for MISRA */
+      }
+      break;
+    case VX1000_JTAGID_PN_TC1798: /* AudoMax */
+      if (source2 >= 0xB1000000UL) /* is it in EMEM (768 Kb)? */  /* ?!? the FW uses "0xBF000000UL" instead ... */
+      {
+        validWindowSizes = 0x0003FFE0UL;
+        rabrSpecBits = 0xB1000000UL ^ 0xC1000000UL;  /* ?!? the FW uses "0x4F000000UL" instead ... */
+      }
+      else if (source2 >= 0xB0000000UL) /* is it in LMU-SRAM (128 Kb)? */
+      {
+        validWindowSizes = 0x0003FFE0UL;
+        rabrSpecBits = 0xB0000000UL ^ 0x80000000UL;
+      }
+      else if (source2 >= 0xA3000000UL) /* is it in EBU space (external memory; size depends on board)? */
+      {
+        validWindowSizes = 0x0003FFE0UL;
+        rabrSpecBits = 0xA3000000UL ^ 0xA3000000UL;
+      }
+      else
+      {
+        ; /* dummy else with empty statement only here for MISRA */
+      }
+      break;
+    case VX1000_JTAGID_PN_TC21x:   /* ?just a guess: "Aurix single core with same properties as all other TC2xx derivatives"? */
+      /* fallthrough to VX1000_JTAGID_PN_TC22x */
+    case VX1000_JTAGID_PN_TC22x:   /* Aurix single core */
+      /* fallthrough to VX1000_JTAGID_PN_TC23x */
+    case VX1000_JTAGID_PN_TC23x:   /* Aurix single core */
+      /* fallthrough to VX1000_JTAGID_PN_TC24x */
+    case VX1000_JTAGID_PN_TC24x:   /* Aurix single core */
+      /* fallthrough to VX1000_JTAGID_PN_TC26x */
+    case VX1000_JTAGID_PN_TC26x:   /* Aurix dual core */
+      /* fallthrough to VX1000_JTAGID_PN_TC27xTC2Dx */
+    case VX1000_JTAGID_PN_TC27xTC2Dx:  /* Aurix triple core */
+      /* fallthrough to VX1000_JTAGID_PN_TC29x */
+    case VX1000_JTAGID_PN_TC29x:  /* Aurix triple core */
+      if (source2 >= 0xBF000000UL) /* is it in EMEM (e.g. 1024 Kb)? */
+      {
+        validWindowSizes = 0x0003FFE0UL;
+        rabrSpecBits = 0xBF000000UL ^ 0x87000000UL;
+      }
+      else if (source2 >= 0xB0000000UL) /* is it in LMURAM (32 Kb)? */
+      {
+        validWindowSizes = 0x0000FFE0UL; /* hint: NOT available on VX1000_JTAGID_PN_TC26x */
+        rabrSpecBits = 0xB0000000UL ^ 0x86000000UL;
+      }
+      else if (source2 >= 0xA3000000UL) /* is it in EBU space (external memory; size depends on board)? */
+      {
+        validWindowSizes = 0x0003FFE0UL; /* hint: ONLY available on VX1000_JTAGID_PN_TC29x */
+        rabrSpecBits = 0xA3000000UL ^ 0x85000000UL;
+      }
+      else if (source2 >= 0x90000000UL) /* is it in LMURAM (32 Kb)? */
+      {
+        validWindowSizes = 0x0000FFE0UL; /* hint: NOT available on VX1000_JTAGID_PN_TC26x */
+        rabrSpecBits = 0x90000000UL ^ 0x86000000UL;
+      }
+      else if (source2 >= 0x70100000UL) /* is it in PSPR0 (16 Kb)? */
+      {
+        validWindowSizes = 0x00007FE0UL;
+        rabrSpecBits = 0x70000000UL ^ 0x80000000UL;
+      }
+      else if (source2 >= 0x70000000UL) /* is it in DSPR0 (72 kBbyte whose first 8 Kb are however reserved for multi core)? */
+      {
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x70000000UL ^ 0x80000000UL;
+      }
+      else if (source2 >= 0x60100000UL) /* is it in PSPR1 (16 Kb)? */
+      {
+        validWindowSizes = 0x00007FE0UL; /* hint: NOT available on single core derivatives */
+        rabrSpecBits = 0x60000000UL ^ 0x81000000UL;
+      }
+      else if (source2 >= 0x60000000UL) /* is it in DSPR1 (72 kBbyte whose first 8 Kb are however reserved for multi core)? */
+      {
+        validWindowSizes = 0x0001FFE0UL; /* hint: NOT available on single core derivatives */
+        rabrSpecBits = 0x60000000UL ^ 0x81000000UL;
+      }
+      else if (source2 >= 0x50100000UL) /* is it in PSPR2 (16 Kb)? */
+      {
+        validWindowSizes = 0x00007FE0UL; /* hint: ONLY available on triple core derivatives */
+        rabrSpecBits = 0x50000000UL ^ 0x82000000UL;
+      }
+      else if (source2 >= 0x50000000UL) /* is it in DSPR2 (72 kBbyte whose first 8 Kb are however reserved for multi core)? */
+      {
+        validWindowSizes = 0x0001FFE0UL; /* hint: ONLY available on triple core derivatives */
+        rabrSpecBits = 0x50000000UL ^ 0x82000000UL;
+      }
+      else
+      {
+        ; /* dummy else with empty statement only here for MISRA */
+      }
+      break;
+    case VX1000_JTAGID_PN_TC32x:
+      /* fallthrough to VX1000_JTAGID_PN_TC33x */
+    case VX1000_JTAGID_PN_TC33x:
+      /* fallthrough to VX1000_JTAGID_PN_TC33xED */
+    case VX1000_JTAGID_PN_TC33xED:
+      /* fallthrough to VX1000_JTAGID_PN_TC35x */
+    case VX1000_JTAGID_PN_TC35x:
+      /* fallthrough to VX1000_JTAGID_PN_TC36x */
+    case VX1000_JTAGID_PN_TC36x:
+      /* fallthrough to VX1000_JTAGID_PN_TC37x */
+    case VX1000_JTAGID_PN_TC37x:
+      /* fallthrough to VX1000_JTAGID_PN_TC37xED */
+    case VX1000_JTAGID_PN_TC37xED:
+      /* fallthrough to VX1000_JTAGID_PN_TC38x */
+    case VX1000_JTAGID_PN_TC38x:
+      /* fallthrough to VX1000_JTAGID_PN_TC39x */
+    case VX1000_JTAGID_PN_TC39x:
+      if (source2 >= 0xB9000000UL) /* is it in EMEM (e.g. 4 Mb)? */
+      {
+        validWindowSizes = 0x003FFFE0UL; /* hint: ONLY available on ADAS, ED and TC39x devices */
+        rabrSpecBits = 0xB9000000UL ^ 0x89000000UL;
+      }
+      else if (source2 >= 0xB0000000UL) /* is it in LMURAM (e.g. 1 Mb)? */
+      {
+        validWindowSizes = 0x001FFFE0UL; /* hint: ONLY available on TC39x + TC38x */
+        rabrSpecBits = 0xB0000000UL ^ 0x88000000UL;
+      }
+      else if (source2 >= 0xA1000000UL) /* is it in EBU space (external memory; size depends on board)? */
+      {
+        validWindowSizes = 0x003FFFE0UL; /* hint: ONLY available on TC39x */
+        rabrSpecBits = 0xA1000000UL ^ 0x8A000000UL;
+      }
+      else if (source2 >= 0x99000000UL) /* is it in EMEM (e.g. 4 Mb)? */
+      {
+        validWindowSizes = 0x003FFFE0UL; /* hint: ONLY available on ADAS, ED and TC39x devices */
+        rabrSpecBits = 0x99000000UL ^ 0x89000000UL;
+      }
+      else if (source2 >= 0x90000000UL) /* is it in LMURAM (e.g. 1 Mb)? */
+      {
+        validWindowSizes = 0x001FFFE0UL; /* hint: ONLY available on TC39x + TC38x */
+        rabrSpecBits = 0x90000000UL ^ 0x88000000UL;
+      }
+      else if (source2 >= 0x81000000UL) /* is it in EBU space (external memory; size <= 112Mb depends on board)? */
+      {
+        validWindowSizes = 0x003FFFE0UL; /* hint: ONLY available on TC39x */
+        rabrSpecBits = 0x81000000UL ^ 0x8A000000UL;
+      }
+      else if (source2 >= 0x70100000UL) /* is it in PSPR0 (64 Kb)? */
+      {
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x70000000UL ^ 0x80000000UL;
+      }
+      else if (source2 >= 0x70000000UL) /* is it in DSPR0 (96 Kb)? */
+      {
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x70000000UL ^ 0x80000000UL;
+      }
+      else if (source2 >= 0x60100000UL) /* is it in PSPR1 (64 Kb)? */
+      {
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x60000000UL ^ 0x81000000UL;
+      }
+      else if (source2 >= 0x60000000UL) /* is it in DSPR1 (96 Kb)? */
+      {
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x60000000UL ^ 0x81000000UL;
+      }
+      else if (source2 >= 0x50100000UL) /* is it in PSPR2 (64 Kb)? */
+      {
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x50000000UL ^ 0x82000000UL;
+      }
+      else if (source2 >= 0x50000000UL) /* is it in DSPR2 (96 Kb)? */
+      {
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x50000000UL ^ 0x82000000UL;
+      }
+      else if (source2 >= 0x40100000UL) /* is it in PSPR3 (64 Kb)? */
+      { /* PRQA S 0715 */ /* If the user\'s compiler only supports the bare ISO-5.2.4.1 translation limits of maximum 15 scopes or "else if" levels, the user has to disable the ECU-defined overlay feature */
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x40000000UL ^ 0x83000000UL;
+      }
+      else if (source2 >= 0x40000000UL) /* is it in DSPR3 (96 Kb)? */ /* PRQA S 0715 */ /* If the user\'s compiler only supports the bare ISO-5.2.4.1 translation limits of maximum 15 scopes or "else if" levels, the user has to disable the ECU-defined overlay feature */
+      {
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x40000000UL ^ 0x83000000UL;
+      }
+      else if (source2 >= 0x30100000UL) /* is it in PSPR4 (64 Kb)? */
+      {
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x30000000UL ^ 0x84000000UL;
+      }
+      else if (source2 >= 0x30000000UL) /* is it in DSPR4 (96 Kb)? */
+      {
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x30000000UL ^ 0x84000000UL;
+      }
+      else if (source2 >= 0x10100000UL) /* is it in PSPR5 (64 Kb)? */
+      {
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x10000000UL ^ 0x85000000UL;
+      }
+      else if (source2 >= 0x10000000UL) /* is it in DSPR5 (96 Kb)? */
+      {
+        validWindowSizes = 0x0001FFE0UL;
+        rabrSpecBits = 0x10000000UL ^ 0x85000000UL;
+      }
+      else
+      {
+        ; /* dummy else with empty statement only here for MISRA */
+      }
+      break;
+    default:
+      break;
+  }
+  if (target == source2)
+  {
+    validWindowSizes = 0xFFFFFFFFUL; /* allow any window size to be turned _off_ */
+  }
+
+  if ((0==(size & validWindowSizes)) || ((size & (size - 1)) != 0))
+  {
+    VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_INVALID_SIZE)
+    retVal = 0; /* unsupported size specified */
+  }
+  else if (((target | source2) & (size - 1UL)) != 0UL)
+  {
+    VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_MISALIGNED)
+    retVal = 0; /* misaligned address specified */
+  }
+  else
+  {
+    switch ((VX1000_MCREG_CBS_JTAGID) & (VX1000_JTAGID_PN_MASK)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    {
+      case VX1000_JTAGID_PN_TC172x:       sfrModel = 0U; break; /* FutureMax : not sure about the sfrModel */
+      case VX1000_JTAGID_PN_TC1387:       sfrModel = 0U; break; /* AudoS */
+      case VX1000_JTAGID_PN_TC178x:       sfrModel = 0U; break; /* AudoMax */
+      case VX1000_JTAGID_PN_TC1767:       sfrModel = 0U; break; /* AudoFuture */
+      case VX1000_JTAGID_PN_TC1797:       sfrModel = 0U; break; /* AudoFuture */
+      case VX1000_JTAGID_PN_TC1798:       sfrModel = 1U; break; /* AudoMax */
+      case VX1000_JTAGID_PN_TC21x:        sfrModel = 2U; break; /* just a guess: "Aurix single core with same properties as all other TC2xx derivatives" */
+      case VX1000_JTAGID_PN_TC22x:        sfrModel = 2U; break; /* Aurix single core */
+      case VX1000_JTAGID_PN_TC23x:        sfrModel = 2U; break; /* Aurix single core */
+      case VX1000_JTAGID_PN_TC24x:        sfrModel = 2U; break; /* Aurix single core */
+      case VX1000_JTAGID_PN_TC26x:        sfrModel = 3U; break; /* Aurix dual core */
+      case VX1000_JTAGID_PN_TC27xTC2Dx:   sfrModel = 4U; break; /* Aurix triple core */
+      case VX1000_JTAGID_PN_TC29x:        sfrModel = 4U; break; /* Aurix triple core */
+      /*
+      TODOKNM: case VX1000_JTAGID_PN_TC32x:        sfrModel = ?U; break; How many cores have we got?
+      */
+      case VX1000_JTAGID_PN_TC33x:        sfrModel = 2U; break; /* Aurix single core */
+      case VX1000_JTAGID_PN_TC33xED:      sfrModel = 3U; break; /* Aurix dual core */
+      case VX1000_JTAGID_PN_TC35x:        sfrModel = 4U; break; /* Aurix triple core */
+      case VX1000_JTAGID_PN_TC36x:        sfrModel = 3U; break; /* Aurix dual core */
+      case VX1000_JTAGID_PN_TC37x:        sfrModel = 4U; break; /* Aurix triple core */
+      case VX1000_JTAGID_PN_TC37xED:      sfrModel = 4U; break; /* Aurix triple core */
+      case VX1000_JTAGID_PN_TC38x:        sfrModel = 5U; break; /* Aurix quad core */
+      case VX1000_JTAGID_PN_TC39x:        sfrModel = 7U; break; /* Aurix hexa core */
+      default:
+        break;
+    }
+
+    /* Change the Redirected Address Base Register, the Overlay Mask Register and the Overlay Target Address Register to turn mappings on or off */
+    switch (sfrModel)
+    {
+      case 0U: /* standard TriCore registers (unprotected) */
+      case 1U: /* AudoMax standard TriCore registers (but ENDINIT protected) */
+        if (sfrModel == 1U)
+        {
+          (VX1000_ADDR_TO_PTR2VU32(0xF0000478UL))[0] = 0x000000A1UL; /* unlock sequence for CBS_OCNTRL */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(0xF0000478UL))[0] = 0x0000005EUL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(0xF0000478UL))[0] = 0x000000A1UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(0xF0000478UL))[0] = 0x0000005EUL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          VX1000_MCREG_CBS_OCNTRL = 0x000000C0UL; /* unlock the ENDINIT protected registers */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+        VX1000_MCREG_OVC_OENABLE = 0x00000001UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        if (sfrModel == 1U)
+        {
+          VX1000_MCREG_CBS_OCNTRL = 0x00000040UL; /* restore the ENDINIT protection state (TODO: do this only when actually protected beforehand!) */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+#if 0 /* experiments on AudoMax showed that changing the range registers is not possible while the overlay is turned off --> disabled the code, while the illegal "#if 0" reminds us in every release that we have to find a workaround */
+        /* turn this mapping off before changing its parameters */
+        (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK(VX1000_OVERLAY_DESCR_IDX)))[0] = 0x00000000UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* 0 */
+        if (target == source2)
+        {
+          /* disable the range */
+          VX1000_MCREG_OVC_OCON = 0x00000000UL | ((0x0000FFFFUL & (VX1000_MCREG_OVC_OCON)) &~ (1UL << (VX1000_OVERLAY_DESCR_IDX))); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          VX1000_MCREG_OVC_OCON = 0x00050000UL | ((0x0000FFFFUL & (VX1000_MCREG_OVC_OCON))); /* DCINVAL|OVSTRT */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+        else
+        {
+          /* install the new mapping: */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR( VX1000_OVERLAY_DESCR_IDX)))[0] = rabrSpecBits ^ source2; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR( VX1000_OVERLAY_DESCR_IDX)))[0] = 0x0FFFFFFFUL & target; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK(VX1000_OVERLAY_DESCR_IDX)))[0] = 0x10000000UL - size; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          if (source1 == 1)
+          {
+            /* disable the range */
+            VX1000_MCREG_OVC_OCON = 0x00000000UL | ((0x0000FFFFUL & (VX1000_MCREG_OVC_OCON)) &~ (1UL << (VX1000_OVERLAY_DESCR_IDX))); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            VX1000_MCREG_OVC_OCON = 0x00050000UL | ((0x0000FFFFUL & (VX1000_MCREG_OVC_OCON))); /* DCINVAL|OVSTRT */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          else
+          {
+            /* Overlay Configuration and Range Select Register (NOTE: basically we do not want to change the windows of other drivers, but when we read their enable-bits, on AudoMax all windows are turned off!? --> disabled the code) */
+            VX1000_MCREG_OVC_OCON = (0x00000000UL /*| (0x0000FFFFUL & (VX1000_MCREG_OVC_OCON))*/) | (1UL << (VX1000_OVERLAY_DESCR_IDX)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            VX1000_MCREG_OVC_OCON = (0x00050000UL /*| (0x0000FFFFUL & (VX1000_MCREG_OVC_OCON))*/) | (1UL << (VX1000_OVERLAY_DESCR_IDX) /* ORed again because we cannot read from the register */); /* DCINVAL|OVSTRT */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+        }
+        break;
+      case 2U: /* Aurix single core */
+      case 3U: /* Aurix dual core */
+      case 4U: /* Aurix triple core */
+      case 5U: /* AurixPlus quad core */
+      /*"static code checkers see that this will never come true:" case 6U:*/ /* potential AurixPlus penta core */
+      /*case 7U:*/ /* AurixPlus hexa core - see below*/
+      default: /* replaces "case 7U:" as last label because some compilers/code checkers complain if dummy default case is missing and others (correctly) complain that the dummy default case is unreachable code */
+        (VX1000_ADDR_TO_PTR2VU32(0xF0000478UL))[0] = 0x000000A1UL; /* unlock sequence for CBS_OCNTRL */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        (VX1000_ADDR_TO_PTR2VU32(0xF0000478UL))[0] = 0x0000005EUL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        (VX1000_ADDR_TO_PTR2VU32(0xF0000478UL))[0] = 0x000000A1UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        (VX1000_ADDR_TO_PTR2VU32(0xF0000478UL))[0] = 0x0000005EUL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        VX1000_MCREG_CBS_OCNTRL = 0x000000C0UL; /* unlock the ENDINIT protected registers */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        {
+          VX1000_UINT32 sfrReadback = (VX1000_MCREG_CBS_OCNTRL) + (2 * (VX1000_MCREG_CBS_OCNTRL));
+          VX1000_DUMMYREAD(sfrReadback)
+        }
+        VX1000_MCREG_SCU_OVCENBL_AURIX = 0x0000003FUL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        /* turn mapping off before changing its parameters */
+        (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(VX1000_OVERLAY_DESCR_IDX, 0UL)))[0] = 0x00000000UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        if (sfrModel != 2U) /* not a single core derivative */
+        {
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(VX1000_OVERLAY_DESCR_IDX, 1UL)))[0] = 0x00000000UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+        if ((sfrModel != 2U) && (sfrModel != 3U)) /* neither single nor dual core derivative */
+        {
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(VX1000_OVERLAY_DESCR_IDX, 2UL)))[0] = 0x00000000UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+        if (((sfrModel != 2U) && (sfrModel != 3U)) && (sfrModel != 4)) /* neither single nor dual nor triple core derivative */
+        {
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(VX1000_OVERLAY_DESCR_IDX, 3UL)))[0] = 0x00000000UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+        if ((sfrModel == 7U) /* "static code checkers see that this will never come true:" || (sfrModel == 6U)*/) /* penta or hexa core derivative */
+        {
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(VX1000_OVERLAY_DESCR_IDX, 4UL)))[0] = 0x00000000UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+        if (sfrModel == 7U) /* hexa core derivative */
+        {
+          /* Note that there is one gap in the OVC core indices (CPU5 continues with index 6) */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(VX1000_OVERLAY_DESCR_IDX, 6UL)))[0] = 0x00000000UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+        if (target != source2)
+        {
+          /* install the new mapping: */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( VX1000_OVERLAY_DESCR_IDX, 0UL)))[0] = rabrSpecBits ^ source2; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( VX1000_OVERLAY_DESCR_IDX, 0UL)))[0] = 0x0FFFFFFFUL & target; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(VX1000_OVERLAY_DESCR_IDX, 0UL)))[0] = 0x10000000UL - size; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          if (sfrModel != 2U) /* not a single core derivative */
+          {
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( VX1000_OVERLAY_DESCR_IDX, 1UL)))[0] = rabrSpecBits ^ source2; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( VX1000_OVERLAY_DESCR_IDX, 1UL)))[0] = 0x0FFFFFFFUL & target; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(VX1000_OVERLAY_DESCR_IDX, 1UL)))[0] = 0x10000000UL - size; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          if ((sfrModel != 2U) && (sfrModel != 3U)) /* neither single nor dual core derivative */
+          {
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( VX1000_OVERLAY_DESCR_IDX, 2UL)))[0] = rabrSpecBits ^ source2; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( VX1000_OVERLAY_DESCR_IDX, 2UL)))[0] = 0x0FFFFFFFUL & target; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(VX1000_OVERLAY_DESCR_IDX, 2UL)))[0] = 0x10000000UL - size; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          if (((sfrModel != 2U) && (sfrModel != 3U)) && (sfrModel != 4)) /* neither single nor dual nor triple core derivative */
+          {
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( VX1000_OVERLAY_DESCR_IDX, 3UL)))[0] = rabrSpecBits ^ source2; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( VX1000_OVERLAY_DESCR_IDX, 3UL)))[0] = 0x0FFFFFFFUL & target; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(VX1000_OVERLAY_DESCR_IDX, 3UL)))[0] = 0x10000000UL - size; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          if ((sfrModel == 7U) /* "static code checkers see that the second condition never will come true:" || (sfrModel == 6U)*/) /* penta or hexa core derivative */
+          {
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( VX1000_OVERLAY_DESCR_IDX, 4UL)))[0] = rabrSpecBits ^ source2; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( VX1000_OVERLAY_DESCR_IDX, 4UL)))[0] = 0x0FFFFFFFUL & target; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(VX1000_OVERLAY_DESCR_IDX, 4UL)))[0] = 0x10000000UL - size; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          if (sfrModel == 7U) /* hexa core derivative */
+          {
+            /* Note that there is one gap in the OVC core indices (CPU5 continues with index 6) */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( VX1000_OVERLAY_DESCR_IDX, 6UL)))[0] = rabrSpecBits ^ source2; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( VX1000_OVERLAY_DESCR_IDX, 6UL)))[0] = 0x0FFFFFFFUL & target; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(VX1000_OVERLAY_DESCR_IDX, 6UL)))[0] = 0x10000000UL - size; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+        }
+        /* Overlay Range Select Registers */
+        if ((target == source2) || (source1 == 1))
+        {
+          VX1000_MCREG_OVC0_OSEL   &=~ (1UL << (VX1000_OVERLAY_DESCR_IDX)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          if (sfrModel != 2U) /* not a single core derivative */
+          {
+            VX1000_MCREG_OVC1_OSEL &=~ (1UL << (VX1000_OVERLAY_DESCR_IDX)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          if ((sfrModel != 2U) && (sfrModel != 3U)) /* neither single nor dual core derivative */
+          {
+            VX1000_MCREG_OVC2_OSEL &=~ (1UL << (VX1000_OVERLAY_DESCR_IDX)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          if (((sfrModel != 2U) && (sfrModel != 3U)) && (sfrModel != 4)) /* neither single nor dual nor triple core derivative */
+          {
+            VX1000_MCREG_OVC3_OSEL &=~ (1UL << (VX1000_OVERLAY_DESCR_IDX)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          if ((sfrModel == 7U) /* "static code checkers see that this will never come true:" || (sfrModel == 6U)*/) /* penta or hexa core derivative */
+          {
+            VX1000_MCREG_OVC4_OSEL &=~ (1UL << (VX1000_OVERLAY_DESCR_IDX)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          if (sfrModel == 7U) /* hexa core derivative */
+          {
+            VX1000_MCREG_OVC5_OSEL &=~ (1UL << (VX1000_OVERLAY_DESCR_IDX)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+        }
+        else
+        {
+          VX1000_MCREG_OVC0_OSEL   |= 1UL << (VX1000_OVERLAY_DESCR_IDX); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          if (sfrModel != 2U) /* not a single core derivative */
+          {
+            VX1000_MCREG_OVC1_OSEL |= 1UL << (VX1000_OVERLAY_DESCR_IDX); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          if ((sfrModel != 2U) && (sfrModel != 3U)) /* neither single nor dual core derivative */
+          {
+            VX1000_MCREG_OVC2_OSEL |= 1UL << (VX1000_OVERLAY_DESCR_IDX); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          if (((sfrModel != 2U) && (sfrModel != 3U)) && (sfrModel != 4)) /* neither single nor dual nor triple core derivative */
+          {
+            VX1000_MCREG_OVC3_OSEL |= 1UL << (VX1000_OVERLAY_DESCR_IDX); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          if ((sfrModel == 7U) /* "static code checkers see that this will never come true:" || (sfrModel == 6U)*/) /* penta or hexa core derivative */
+          {
+            VX1000_MCREG_OVC4_OSEL |= 1UL << (VX1000_OVERLAY_DESCR_IDX); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          if (sfrModel == 7U) /* hexa core derivative */
+          {
+            VX1000_MCREG_OVC5_OSEL |= 1UL << (VX1000_OVERLAY_DESCR_IDX); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+        }
+        VX1000_MCREG_SCU_OVCCON = 0x0005003FUL; /* DCINVAL|OVSTRT|COREs */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        VX1000_MCREG_CBS_OCNTRL = 0x00000040UL; /* restore the ENDINIT protection state */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        break;
+      }
+    retVal = 1; /* mapping updated */
+  }
+  return retVal;
+}
+
+#endif /* VX1000_TARGET_TRICORE */
+
+#elif defined(VX1000_MPC56xCRAM_BASE_ADDR)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MapCalRam - may be overloaded internally for the used hardware                                       */
+/* API name:      None                                                                                                        */
+/* Return value:  status:                                                                                                     */
+/*                0: requested overlay not possible                                                                           */
+/*                1: mapping complete                                                                                         */
+/* Parameter1:    Overlay window size                                                                                         */
+/* Parameter2:    properly aligned virtual flash access address                                                               */
+/* Parameter3:    overlay memory address (hard-wired on this hardware)                                                        */
+/*                If Parameter2 == Parameter3, the overlay is turned off completely.                                          */
+/* Parameter4:    physical address of Parameter3 (not used on MPC56x)                                                         */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for enabling/disabling a single overlay window using MPC500 CALRAM feature.      */
+/*                Note: The driver assumes exclusive ownership of the entire CRAM controller.                                 */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_UINT32 size, VX1000_UINT32 target, VX1000_UINT32 source1, VX1000_UINT32 source2)
+{
+  VX1000_UINT8 block = 0, retVal = 1; /* return "mapping complete" by default */
+  volatile VX1000_UINT32 *cram = (VX1000_ADDR_TO_PTR2VU32(VX1000_MPC56xCRAM_BASE_ADDR)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+
+  cram[0] = 0; /* CRAMMCR = 0x00000000 */
+  if (target == source1)
+  {
+    cram[0x28U >> 2U] = 0x00000000UL; /* disable all overlays via CRAMOVLCR global enable bit */
+    VX1000_DUMMYREAD(source2)         /* just to avoid compiler "unused" warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  }
+  else
+  {
+    while (size >= 512UL) /* note: the dummy initialisation of size is only here for MISRA, don\'t remove it! */
+    {
+      if ((block <= 7U) && ((target & 0xFFE001FFUL) == 0))
+      {
+        cram[2U + block] = 0x70000000UL | target; /* CRAM_RBAx = SIZCODEx<<28 + (TADDRx &~ SIZEMASK) */
+        block++;
+        target += 512;
+        size -= 512UL;
+      }
+      else
+      {
+        size = 1UL; /* create an impossible size to leave the loop and the function */
+      }
+    }
+    switch (size) /* note: joining smaller than 512bytes blocks is not possible because the HW leaves gaps in the source memory */
+    {
+      case 256:
+        if ((block <= 7U) && ((target & 0xFFE000FFUL) == 0))
+        {
+          cram[2U + block] = 0x60000000UL | target;
+          size -= 256UL;
+          block++;
+        }
+        break;
+      case 128:
+        if ((block <= 7U) && ((target & 0xFFE0007FUL) == 0))
+        {
+          cram[2U + block] = 0x50000000UL | target;
+          size -= 128UL;
+          block++;
+        }
+        break;
+      case 64:
+        if ((block <= 7U) && ((target & 0xFFE0003FUL) == 0))
+        {
+          cram[2U + block] = 0x40000000UL | target;
+          size -= 64UL;
+          block++;
+        }
+        break;
+      case 32:
+        if ((block <= 7U) && ((target & 0xFFE0001FUL) == 0))
+        {
+          cram[2U + block] = 0x30000000UL | target;
+          size -= 32UL;
+          block++;
+        }
+        break;
+      case 16:
+        if ((block <= 7U) && ((target & 0xFFE0000FUL) == 0))
+        {
+          cram[2U + block] = 0x20000000UL | target;
+          size -= 16UL;
+          block++;
+        }
+        break;
+      case 4:  /* Note: there is no 8-byte block mapping */
+        if ((block <= 7U) && ((target & 0xFFE00003UL) == 0))
+        {
+          cram[2U + block] = 0x10000000UL | target;
+          size -= 4UL;
+          block++;
+        }
+        break;
+      default: /* zero or invalid setting */
+        VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_INVALID_SIZE)
+        /* error is generated below */
+        break;
+    }
+    for (; block < 8; block++)
+    {
+      cram[2U + block] = 0x00000000UL; /* invalidate unused blocks */
+    }
+    if (size != 0)
+    {
+      retVal = 0;  /* requested overlay not possible */
+    }
+    else
+    {
+      cram[0x28U >> 2U] = 0x80000000UL;/* enable overlay */ /* CRAMOVLCR = OVL_ENBL << 31; Hint: MSR.DR also has an influence */
+    }
+  }
+  return retVal;
+}
+#endif /* VX1000_MPC56xCRAM_BASE_ADDR */
+#if defined(VX1000_SH2_FCU_BASE_ADDR)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MapCalRam - may be overloaded internally for the used hardware                                       */
+/* API name:      None                                                                                                        */
+/* Return value:  status:                                                                                                     */
+/*                0: requested overlay not possible                                                                           */
+/*                1: mapping complete                                                                                         */
+/* Parameter1:    Overlay window size                                                                                         */
+/* Parameter2:    properly aligned virtual flash access address                                                               */
+/* Parameter3:    overlay memory address                                                                                      */
+/*                If Parameter2 == Parameter3, the overlay is turned off completely.                                          */
+/* Parameter4:    physical address of Parameter3 (optional)                                                                   */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for enabling/disabling a single overlay window using SH2 FCU feature.            */
+/*                Note: The driver assumes exclusive ownership of the overlay unit.                                           */
+/* Devel state:   Specified                                                                                                   */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_MapCalRam)( VX1000_UINT32 size, VX1000_UINT32 target, VX1000_UINT32 source1, VX1000_UINT32 source2 )
+{
+  VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+  ++size; ++target; ++source1; ++source2; /* dummy usage to avoid compiler warnings */
+  return 0; /* not implemented */
+}
+#endif /* VX1000_SH2_FCU_BASE_ADDR */
+
+#if defined(VX1000_TARGET_XC2000)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MapCalRam - may be overloaded internally for the used hardware                                       */
+/* API name:      None                                                                                                        */
+/* Return value:  status:                                                                                                     */
+/*                0: requested overlay not possible                                                                           */
+/*                1: mapping complete                                                                                         */
+/* Parameter1:    Overlay window size                                                                                         */
+/* Parameter2:    properly aligned virtual flash access address                                                               */
+/* Parameter3:    overlay memory address                                                                                      */
+/*                If Parameter2 == Parameter3, the overlay is turned off completely.                                          */
+/* Parameter4:    physical address of Parameter3 (optional)                                                                   */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for enabling/disabling a single overlay window using SH2 FCU feature.            */
+/*                Note: The driver assumes exclusive ownership of the overlay unit.                                           */
+/* Devel state:   Specified                                                                                                   */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_MapCalRam)( VX1000_UINT32 size, VX1000_UINT32 target, VX1000_UINT32 source1, VX1000_UINT32 source2 )
+{
+  VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+  ++size; ++target; ++source1; ++source2; /* dummy usage to avoid compiler warnings */
+  return 0; /* not implemented */
+}
+#endif /* VX1000_TARGET_XC2000 */
+
+#endif /* VX1000_OVERLAY & !VX1000_OVERLAY_VX_CONFIGURABLE */
+
+#if (defined(VX1000_OVERLAY)) && (defined(VX1000_OVERLAY_VX_CONFIGURABLE)) && (defined(VX1000_OVLENBL_REGWRITE_VIA_MX)) && (defined(VX1000_MAILBOX) && defined(VX1000_MAILBOX_OVERLAY_CONTROL))
+
+#if defined(VX1000_TARGET_TRICORE)
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlayWriteEcuDescr                                                                                 */
+/* API name:      None                                                                                                        */
+/* Return value:  status:                                                                                                     */
+/*                0: ovl regs pointed by gVX1000.Ovl.ovlConfigRegsPtr is written to ECU                                       */
+/*                1: nothing is done                                                                                          */
+/* Preemption:    todo vislwn                                                                                                 */
+/* Termination:   todo vislwn                                                                                                 */
+/* Precondition1: todo vislwn                                                                                                 */
+/* Description:   This function writes gVX1000.Ovl.ovlConfigRegsPtr structure to ECU overlay regs.                            */
+/*                It is called in vx1000_DetectVxAsyncEnd() when corresponding defines are activated in vx1000_cfg.h          */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlayWriteEcuDescr)(void)
+{
+  VX1000_UINT8 sfrModel = 0, coreIdx, descIdx, overlayDescriptors = 0, retVal = 1;
+
+  switch ((VX1000_MCREG_CBS_JTAGID) & (VX1000_JTAGID_PN_MASK)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  {
+    case VX1000_JTAGID_PN_TC172x:       overlayDescriptors = 16U; sfrModel = 0U; break; /* FutureMax : not sure about the sfrModel */
+    case VX1000_JTAGID_PN_TC1387:       overlayDescriptors = 16U; sfrModel = 0U; break; /* AudoS */
+    case VX1000_JTAGID_PN_TC178x:       overlayDescriptors = 16U; sfrModel = 0U; break; /* AudoMax */
+    case VX1000_JTAGID_PN_TC1767:       overlayDescriptors = 16U; sfrModel = 0U; break; /* AudoFuture */
+    case VX1000_JTAGID_PN_TC1797:       overlayDescriptors = 16U; sfrModel = 0U; break; /* AudoFuture */
+    case VX1000_JTAGID_PN_TC1798:       overlayDescriptors = 16U; sfrModel = 1U; break; /* AudoMax */
+    case VX1000_JTAGID_PN_TC21x:        overlayDescriptors =  8U; sfrModel = 2U; break; /* just a guess: "Aurix single core with 8 descriptors" */
+    case VX1000_JTAGID_PN_TC22x:        overlayDescriptors =  8U; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC23x:        overlayDescriptors =  8U; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC24x:        overlayDescriptors = 32U; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC26x:        overlayDescriptors = 32U; sfrModel = 3U; break; /* Aurix dual core */
+    case VX1000_JTAGID_PN_TC27xTC2Dx:   overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC29x:        overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    /*
+    case VX1000_JTAGID_PN_TC32x:        overlayDescriptors = 32U; sfrModel = ?U; break; How many cores have we got?
+    */
+    case VX1000_JTAGID_PN_TC33x:        overlayDescriptors = 32U; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC33xED:      overlayDescriptors = 32U; sfrModel = 3U; break; /* Aurix dual core */
+    case VX1000_JTAGID_PN_TC35x:        overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC36x:        overlayDescriptors = 32U; sfrModel = 3U; break; /* Aurix dual core */
+    case VX1000_JTAGID_PN_TC37x:        overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC37xED:      overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC38x:        overlayDescriptors = 32U; sfrModel = 5U; break; /* Aurix quad core */
+    case VX1000_JTAGID_PN_TC39x:        overlayDescriptors = 32U; sfrModel = 7U; break; /* Aurix hexa core */
+    default: break;
+  }
+  if (gVX1000.Ovl.ovlConfigRegsPtr != 0)
+  {
+    switch (sfrModel)
+    {
+      case 4U:
+        for (coreIdx = 0; coreIdx < 3; coreIdx++)
+        {
+          VX1000_MCREG_OVC_OSEL(coreIdx) = (VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr))->OSEL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          for (descIdx = 0; descIdx < overlayDescriptors; descIdx++)
+          {
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( descIdx, coreIdx)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr))->DESCR)[descIdx].RABR; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( descIdx, coreIdx)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr))->DESCR)[descIdx].OTAR; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(descIdx, coreIdx)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr))->DESCR)[descIdx].OMASK; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+        }
+        retVal = 0;
+        break;
+      case 7U:
+        for (coreIdx = 0; coreIdx < 6; coreIdx++)
+        {
+          if (coreIdx == 5) { coreIdx = 6; } /* Note that there is one gap in the OVC core indices (CPU5 continues with index 6) */
+          VX1000_MCREG_OVC_OSEL(coreIdx) = (VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr))->OSEL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          for (descIdx = 0; descIdx < overlayDescriptors; descIdx++)
+          {
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( descIdx, coreIdx)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr))->DESCR)[descIdx].RABR; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( descIdx, coreIdx)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr))->DESCR)[descIdx].OTAR; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(descIdx, coreIdx)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr))->DESCR)[descIdx].OMASK; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+        }
+        retVal = 0;
+        break;
+      default:
+        VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+        break;
+    }
+  }
+  return retVal;
+}
+
+#else /* !VX1000_TARGET_TRICORE */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlayWriteEcuDescr                                                                                 */
+/* API name:      None                                                                                                        */
+/* Return value:  status:                                                                                                     */
+/*                0: ovl regs pointed by gVX1000.Ovl.ovlConfigRegsPtr is written to ECU                                       */
+/*                1: nothing is done                                                                                          */
+/* Preemption:    todo vislwn                                                                                                 */
+/* Termination:   todo vislwn                                                                                                 */
+/* Precondition1: todo vislwn                                                                                                 */
+/* Description:   todo vislwn                                                                                                 */
+/* Devel state:   Idea                                                                                                        */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlayWriteEcuDescr)(void)
+{
+  VX1000_UINT8 retVal = 1;
+  VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+  return retVal;
+}
+
+#endif /* !VX1000_TARGET_TRICORE */
+
+
+#if defined(VX1000_TARGET_TRICORE)
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlayReadEcuDescr                                                                                  */
+/* API name:      None                                                                                                        */
+/* Return value:  status:                                                                                                     */
+/*                0: ovl regs in ECU is read to struct pointed to by gVX1000.Ovl.ovlConfigRegsPtr                             */
+/*                1: nothing is done                                                                                          */
+/* Preemption:    todo vislwn                                                                                                 */
+/* Termination:   todo vislwn                                                                                                 */
+/* Precondition1: todo vislwn                                                                                                 */
+/* Description:   This function reads ECU overlay regs to gVX1000.Ovl.ovlConfigRegsPtr structure.                             */
+/*                It is called in vx1000_OverlayInit() when corresponding defines are activated in VX1000_cfg.h               */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlayReadEcuDescr)(void)
+{
+  VX1000_UINT8 sfrModel = 0, coreIdx, descIdx, overlayDescriptors = 0, retVal = 1;
+
+  switch ((VX1000_MCREG_CBS_JTAGID) & (VX1000_JTAGID_PN_MASK)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  {
+    case VX1000_JTAGID_PN_TC172x:       overlayDescriptors = 16U; sfrModel = 0U; break; /* FutureMax : not sure about the sfrModel */
+    case VX1000_JTAGID_PN_TC1387:       overlayDescriptors = 16U; sfrModel = 0U; break; /* AudoS */
+    case VX1000_JTAGID_PN_TC178x:       overlayDescriptors = 16U; sfrModel = 0U; break; /* AudoMax */
+    case VX1000_JTAGID_PN_TC1767:       overlayDescriptors = 16U; sfrModel = 0U; break; /* AudoFuture */
+    case VX1000_JTAGID_PN_TC1797:       overlayDescriptors = 16U; sfrModel = 0U; break; /* AudoFuture */
+    case VX1000_JTAGID_PN_TC1798:       overlayDescriptors = 16U; sfrModel = 1U; break; /* AudoMax */
+    case VX1000_JTAGID_PN_TC21x:        overlayDescriptors =  8U; sfrModel = 2U; break; /* just a guess: "Aurix single core with 8 descriptors" */
+    case VX1000_JTAGID_PN_TC22x:        overlayDescriptors =  8U; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC23x:        overlayDescriptors =  8U; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC24x:        overlayDescriptors = 32U; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC26x:        overlayDescriptors = 32U; sfrModel = 3U; break; /* Aurix dual core */
+    case VX1000_JTAGID_PN_TC27xTC2Dx:   overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC29x:        overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    /*
+    TODOKNM: case VX1000_JTAGID_PN_TC32x:        overlayDescriptors = 32U; sfrModel = ?U; break; How many cores have we got?
+    */
+    case VX1000_JTAGID_PN_TC33x:        overlayDescriptors = 32U; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC33xED:      overlayDescriptors = 32U; sfrModel = 3U; break; /* Aurix dual core */
+    case VX1000_JTAGID_PN_TC35x:        overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC36x:        overlayDescriptors = 32U; sfrModel = 3U; break; /* Aurix dual core */
+    case VX1000_JTAGID_PN_TC37x:        overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC37xED:      overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC38x:        overlayDescriptors = 32U; sfrModel = 5U; break; /* Aurix quad core */
+    case VX1000_JTAGID_PN_TC39x:        overlayDescriptors = 32U; sfrModel = 7U; break; /* Aurix hexa core */
+    default: break;
+  }
+  if (gVX1000.Ovl.ovlConfigRegsPtr != 0)
+  {
+    switch (sfrModel)
+    {
+      case 7U:
+      case 5U:
+      case 4U:
+      case 3U:
+      case 2U:
+        coreIdx = 0;  /* only need to read from first core, since all cores should be configured the same way */
+        {
+          (VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr))->OSEL = VX1000_MCREG_OVC_OSEL(coreIdx); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          for (descIdx = 0; descIdx < overlayDescriptors; descIdx++)
+          {
+            ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr))->DESCR)[descIdx].RABR = (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( descIdx, coreIdx)))[0]; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr))->DESCR)[descIdx].OTAR = (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( descIdx, coreIdx)))[0]; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr))->DESCR)[descIdx].OMASK= (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(descIdx, coreIdx)))[0]; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+        }
+        retVal = 0;
+        break;
+      default:
+        VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+        break;
+    }
+  }
+  return retVal;
+}
+
+#else /* !VX1000_TARGET_TRICORE */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlayReadEcuDescr                                                                                  */
+/* API name:      None                                                                                                        */
+/* Return value:  status:                                                                                                     */
+/*                0: ovl regs in ECU is read to struct pointed to by gVX1000.Ovl.ovlConfigRegsPtr                             */
+/*                1: nothing is done                                                                                          */
+/* Preemption:    todo vislwn                                                                                                 */
+/* Termination:   todo vislwn                                                                                                 */
+/* Precondition1: todo vislwn                                                                                                 */
+/* Description:   This function reads ECU overlay regs to gVX1000.Ovl.ovlConfigRegsPtr structure.                             */
+/*                It is called in vx1000_OverlayInit() when corresponding defines are activated in VX1000_cfg.h               */
+/* Devel state:   Idea                                                                                                        */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlayReadEcuDescr)(void)
+{
+  VX1000_UINT8 retVal = 1;
+  VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+  return retVal;
+}
+
+#endif /* !VX1000_TARGET_TRICORE */
+
+#endif /* VX1000_OVERLAY & VX1000_OVERLAY_VX_CONFIGURABLE & VX1000_OVLENBL_REGWRITE_VIA_MX & VX1000_MAILBOX & VX1000_MAILBOX_OVERLAY_CONTROL */
+
+#if defined(VX1000_OVLENBL_KEEP_AWAKE)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_IsCalWakeupActive                                                                                    */
+/* API name:      VX1000_IS_CAL_WAKEUP_ACTIVE                                                                                 */
+/* Wrapper API:   VX1000If_IsCalWakeupActive                                                                                  */
+/* Return value:  status:                                                                                                     */
+/*                0: The download of the overlay image has completed (so the ECU can safely fall asleep again)                */
+/*                1: The cause for the wakeup is still active                                                                 */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_InitAsyncStart must have been called.                                                                */
+/* Description:   Returns whether the ECU must stay awake for calibration purposes. Since the last call of this function the  */
+/*                VX1000 has requested the ECU to stay awake.                                                                 */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_IsCalWakeupActive)(void)
+{
+  VX1000_UINT8 retVal = 0;
+  if (gVX1000.Ovl.ecuLastPresenceCounter != gVX1000.Ovl.presenceCounter)
+  {
+    retVal = 1;
+  }
+  gVX1000.Ovl.ecuLastPresenceCounter = gVX1000.Ovl.presenceCounter;
+  return retVal;
+}
+#endif /* VX1000_OVLENBL_KEEP_AWAKE */
+
+#if defined(VX1000_OVLENBL_PERSISTENT_EMEM)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_InvalidateEmem                                                                                       */
+/* API name:      VX1000_INVALIDATE_EMEM                                                                                      */
+/* Wrapper API:   VX1000If_InvalidateEmem                                                                                     */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: The ECC of the used EMEM must have been initialised (e.g. by vx1000_EmemHdrInit).                           */
+/* Description:   Explicitly destroy the signature of VX-allocated persistent ECU-RAM to force reinitialisation if it.        */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+void VX1000_SUFFUN(vx1000_InvalidateEmem)(void)
+{
+  if (gVX1000.MagicId == (VX1000_UINT32)(VX1000_STRUCT_MAGIC))
+  {
+    if (gVX1000.OvlPtr != 0UL)
+    {
+      if (gVX1000.Ovl.persistentECUEmemHeaderPtr != 0UL)
+      {
+        VX1000_EMEM_HDR_T *hdr = (VX1000_ADDR_TO_PTR2EH(gVX1000.Ovl.persistentECUEmemHeaderPtr)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        hdr->ememInitEnd = 0UL;
+        hdr->ememInitEndInvert = 0UL;
+        hdr->ememInitStart = 0UL;
+        hdr->ememInitStartInvert = 0UL;
+      }
+    }
+  }
+}
+#endif /* VX1000_OVLENBL_PERSISTENT_EMEM */
+
+
+#if defined(VX1000_OVERLAY) && defined(VX1000_MAILBOX_OVERLAY_CONTROL)
+
+#if defined(VX1000_OVLENBL_SYNC_PAGESWITCH)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlaySetConfigDone                                                                                 */
+/* API name:      VX1000_OVL_SET_CONFIG_DONE (normal operation) / VX1000_OVL_SET_CONFIG_DONE_STUP (start-up stage)            */
+/* Wrapper API:   VX1000If_OvlSetConfigDone (normal operation) / VX1000If_OvlSetConfigDoneVoid (start-up stage)               */
+/*                may be overloaded by user                                                                                   */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    XCP error code in case of failed page switch, 0 in case of success                                          */
+/* Parameter2:    The ID of the page that is in use now                                                                       */
+/* Parameter3:    A boolean that tells the driver whether to forward the result to the tool (TRUE) or not (FALSE)             */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: A page switch has to be requested and executed.                                                             */
+/* Description:   Inform the driver (and optionally also the tool) about the final reaction to a page switch request.         */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+void VX1000_SUFFUN(vx1000_OverlaySetConfigDone)( VX1000_UINT8 cfgResult, VX1000_UINT8 page, VX1000_UINT8 onStartup )
+{
+#if defined(VX1000_COMPILED_FOR_SLAVECORES)
+  VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,cfgResult, page,onStartup,(0),(0))) /* dummy usage of unused operands */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+#else /* !VX1000_COMPILED_FOR_SLAVECORES */
+  VX1000_UINT32 txLen;
+  VX1000_CHAR txBuf[8];
+
+  if (0 == cfgResult)
+  {
+    txLen = 1;
+    txBuf[0] = (VX1000_CHAR)-1;
+    gVX1000_ECU_CalPage = page;
+    if (page != 0)
+    {
+      gVX1000.ToolDetectState |= VX1000_TDS_WORKING_PAGE;
+    }
+    else
+    {
+      gVX1000.ToolDetectState &= ~(VX1000_TDS_WORKING_PAGE);
+    }
+  }
+  else
+  {
+    txLen = 2;
+    txBuf[0] = (VX1000_CHAR)-2;
+    txBuf[1] = (VX1000_CHAR)cfgResult;
+  }
+  if (0==onStartup)
+  {
+    (void)VX1000_SUFFUN(vx1000_MailboxWrite)(txLen, txBuf);
+  }
+#endif /* VX1000_COMPILED_FOR_SLAVECORES */
+}
+
+#if defined(VX1000_OVL_SET_CONFIG_INTERNAL)
+
+#if defined(VX1000_FLASHPORTCTLR_BASE_ADDR)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlaySetConfig                                                                                     */
+/* API name:      VX1000_OVL_SET_CONFIG (expression) / VX1000_OVL_SET_CONFIG_VOID (statement) - may be overloaded by user     */
+/* Wrapper API:   VX1000If_OvlSetConfigVoid                                                                                   */
+/* Return value:  status:                                                                                                     */
+/*                0: Page switch done                                                                                         */
+/*                1: Nothing done                                                                                             */
+/*                2: Value not written correctly                                                                              */
+/*                3: No single-master page-switch possible                                                                    */
+/*                4: Generic error                                                                                            */
+/* Parameter1:    Overlay windows to be activated/deactivated in case of VX-configurable overlay (otherwise unused)           */
+/* Parameter2:    Resource Mask in case of VX-configurable overlay (otherwise unused)                                         */
+/* Parameter3:    Overlay windows of optional second overlay controller for activation/deactivation in case of VX-configurable*/
+/* Parameter4:    Resource Mask for optional second overlay controller in case of VX-configurable overlay (otherwise unused)  */
+/* Parameter5:    Overlay Page                                                                                                */
+/* Parameter6:    Masters to be activated                                                                                     */
+/* Parameter7:    Masters resource Mask                                                                                       */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for globally enabling/disabling overlays on several MPC57xx family members.      */
+/*                Note: the driver assumes exclusive ownership of the overlay unit.                                           */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlaySetConfig)( VX1000_UINT32 value, VX1000_UINT32 mask, VX1000_UINT32 valueB,
+                                                     VX1000_UINT32 maskB, VX1000_UINT8 page, VX1000_UINT32 master,
+                                                     VX1000_UINT32 calMaster )
+{
+  VX1000_UINT8 retVal = 0;    /* assume OK */
+  volatile VX1000_UINT32 checkValue;
+#if !defined(VX1000_FLASHPORTCTLR_BASE_ADDR2)
+  VX1000_DUMMYREAD(valueB)    /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(maskB)     /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+#endif /* !VX1000_FLASHPORTCTLR_BASE_ADDR2 */
+#if defined(VX1000_OVERLAY_VX_CONFIGURABLE)
+#if defined(VX1000_OVLENBL_CORE_SYNC_PAGESW)
+  /* note: at least for sync page switch mode, calMaster comes from the FW and is always set to 0xFFFFFFFF, while master is an API parameter coming from the app according to the calling core! */
+  VX1000_DUMMYREAD(calMaster) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(master)    /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+#else  /* !VX1000_OVLENBL_CORE_SYNC_PAGESW */
+  if (master != calMaster)
+  {
+    retVal = 3;
+  }
+  else 
+#endif /* !VX1000_OVLENBL_CORE_SYNC_PAGESW */
+  if (page == 0)
+  {
+    VX1000_ATOMIC_AND32((VX1000_UINT32)((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x14UL), ~mask); /* Note that decorated storage is a feature of the PRAM controller and thus SFRs DON\'T support it and therefore VX1000_ATOMIC_AND32 MUST be implemented as normal store encapsulated in mutex! */
+    checkValue = (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x14UL))[0];   /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    if ((checkValue & mask) != 0)
+    {
+      retVal = 2;
+    }
+#if defined(VX1000_FLASHPORTCTLR_BASE_ADDR2)
+    VX1000_ATOMIC_AND32((VX1000_UINT32)((VX1000_FLASHPORTCTLR_BASE_ADDR2) + 0x14UL), ~maskB); /* Note that decorated storage is a feature of the PRAM controller and thus SFRs DON\'T support it and therefore VX1000_ATOMIC_AND32 MUST be implemented as normal store encapsulated in mutex! */
+    checkValue = (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR2) + 0x14UL))[0]; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    if ((checkValue & maskB) != 0)
+    {
+      retVal = 2;
+    }
+#endif /* VX1000_FLASHPORTCTLR_BASE_ADDR2 */
+  }
+  else
+  {
+    VX1000_ATOMIC_OR32((VX1000_UINT32)((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x14UL), (value & mask)); /* Note that decorated storage is a feature of the PRAM controller and thus SFRs DON\'T support it and therefore VX1000_ATOMIC_OR32 MUST be implemented as normal store encapsulated in mutex! */
+    checkValue = (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + 0x14UL))[0]; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    if ((checkValue & mask) != (value & mask))
+    {
+      retVal = 2;
+    }
+#if defined(VX1000_FLASHPORTCTLR_BASE_ADDR2)
+    VX1000_ATOMIC_OR32((VX1000_UINT32)((VX1000_FLASHPORTCTLR_BASE_ADDR2) + 0x14UL), (valueB & maskB)); /* Note that decorated storage is a feature of the PRAM controller and thus SFRs DON\'T support it and therefore VX1000_ATOMIC_OR32 MUST be implemented as normal store encapsulated in mutex! */
+    checkValue = (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR2) + 0x14UL))[0]; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    if ((checkValue & maskB) != (valueB & maskB))
+    {
+      retVal = 2;
+    }
+#endif /* VX1000_FLASHPORTCTLR_BASE_ADDR2 */
+  }
+#else /* !VX1000_OVERLAY_VX_CONFIGURABLE */
+  if (0==(master & calMaster))
+  {
+    VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,value, mask, valueB, maskB,0)) /* dummy usage of unused parameters to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+    retVal = 3;
+  }
+  else
+  {
+    VX1000_ENTER_SPINLOCK()
+    checkValue = (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + (0x0108UL + (((VX1000_OVERLAY_DESCR_IDX) & 31) << 4))))[0]; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    if (page == 0)
+    {
+      checkValue &=~ (master << 16);
+    }
+    else
+    {
+      checkValue |= master << 16;
+    }
+#if ((VX1000_OVERLAY_DESCR_IDX) < 16) /* safe mode */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + (0x0108UL + ((((VX1000_OVERLAY_DESCR_IDX) + 16)) << 4))))[0] = /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + (0x0108UL + ((( VX1000_OVERLAY_DESCR_IDX      )) << 4))))[0] = checkValue; /* this access as a side effect clears PFCRDE.VALID */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + (0x0014UL)))[0] |= (1UL << (31 - ((VX1000_OVERLAY_DESCR_IDX) + 16))) | (1UL << (31 - (VX1000_OVERLAY_DESCR_IDX))); /* PFCRDE -> set descriptor valid again */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else /* VX1000_OVERLAY_DESCR_IDX >= 16 : big mode */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + (0x0108UL + (((VX1000_OVERLAY_DESCR_IDX) & 31) << 4))))[0] = checkValue; /* this access as a side effect clears PFCRDE.VALID */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR) + (0x0014UL)))[0] |= (1UL << (31 - ((VX1000_OVERLAY_DESCR_IDX) & 31))); /* PFCRDE -> set descriptor valid again */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_OVERLAY_DESCR_IDX >= 16 */
+#if defined(VX1000_FLASHPORTCTLR_BASE_ADDR2) && defined(VX1000_OVERLAY_DESCR_IDX2)
+    checkValue = (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR2) + (0x0108UL + (((VX1000_OVERLAY_DESCR_IDX2) & 31) << 4))))[0]; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    if (page == 0)
+    {
+      checkValue &=~ (master << 16);
+    }
+    else
+    {
+      checkValue |= master << 16;
+    }
+#if ((VX1000_OVERLAY_DESCR_IDX2) < 16) /* safe mode */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR2) + (0x0108UL + ((((VX1000_OVERLAY_DESCR_IDX2) + 16)) << 4))))[0] = /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR2) + (0x0108UL + ((( VX1000_OVERLAY_DESCR_IDX2      )) << 4))))[0] = checkValue; /* this access as a side effect clears PFCRDE.VALID */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR2) + (0x0014UL)))[0] |= (1UL << (31 - ((VX1000_OVERLAY_DESCR_IDX2) + 16))) | (1UL << (31 - (VX1000_OVERLAY_DESCR_IDX2))); /* PFCRDE -> set descriptor valid again */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else /* VX1000_OVERLAY_DESCR_IDX2 >= 16 : big mode */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR2) + (0x0108UL + (((VX1000_OVERLAY_DESCR_IDX2) & 31) << 4))))[0] = checkValue; /* this access as a side effect clears PFCRDE.VALID */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32((VX1000_FLASHPORTCTLR_BASE_ADDR2) + (0x0014UL)))[0] |= (1UL << (31 - ((VX1000_OVERLAY_DESCR_IDX2) & 31))); /* PFCRDE -> set descriptor valid again */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_OVERLAY_DESCR_IDX2 >= 16 */
+#endif /* VX1000_FLASHPORTCTLR_BASE_ADDR2 && VX1000_OVERLAY_DESCR_IDX2 */
+    VX1000_LEAVE_SPINLOCK()
+  }
+#endif /* !VX1000_OVERLAY_VX_CONFIGURABLE */
+  return retVal;
+}
+
+#elif defined(VX1000_MPC56xCRAM_BASE_ADDR)  /* & !VX1000_FLASHPORTCTLR_BASE_ADDR */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlaySetConfig                                                                                     */
+/* API name:      VX1000_OVL_SET_CONFIG (expression) / VX1000_OVL_SET_CONFIG_VOID (statement) - may be overloaded by user     */
+/* Wrapper API:   VX1000If_OvlSetConfigVoid                                                                                   */
+/* Return value:  status:                                                                                                     */
+/*                0: Page switch done                                                                                         */
+/*                1: Nothing done                                                                                             */
+/*                2: Value not written correctly                                                                              */
+/*                3: No single-master page-switch possible                                                                    */
+/*                4: Generic error                                                                                            */
+/* Parameter1:    Overlay windows to be activated/deactivated in case of VX-configured overlay (unused otherwise)             */
+/* Parameter2:    Resource Mask                                                                                               */
+/* Parameter3:    not used                                                                                                    */
+/* Parameter4:    not used                                                                                                    */
+/* Parameter5:    Overlay Page                                                                                                */
+/* Parameter6:    Masters to be activated (dummy)                                                                             */
+/* Parameter7:    Masters resource Mask (dummy)                                                                               */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for globally enabling/disabling overlays on several MPC5xx family members.       */
+/*                Note: the driver assumes exclusive ownership of the CRAM controller.                                        */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlaySetConfig)( VX1000_UINT32 value, VX1000_UINT32 mask, VX1000_UINT32 valueB,
+                                                     VX1000_UINT32 maskB, VX1000_UINT8 page, VX1000_UINT32 master,
+                                                     VX1000_UINT32 calMaster )
+{
+  /* Note: Implementation valid only for MPC5xx! */
+  volatile VX1000_UINT32 *cram = VX1000_ADDR_TO_PTR2VU32(VX1000_MPC56xCRAM_BASE_ADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  VX1000_UINT8 idx, retVal = 0; /* assume OK */
+  VX1000_UINT32 checkmask = 0x00000001UL;
+
+  VX1000_DUMMYREAD(valueB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(maskB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+
+  for (idx = 0; idx < 8; ++idx)        /* turn all 8 windows on or all windows off */
+  {
+    if ((mask & checkmask) != 0)
+    {
+      if (page == 0)
+      {
+        cram[2U + idx] &=~0x70000000UL; /* disable any block remapping in CRAM_RBAx */
+      }
+      else
+      {
+        cram[2U + idx] |= 0x70000000UL; /* enable 512-byte block remapping in CRAM_RBAx (other sizes are not supported by the FW) */
+      }
+    }
+    mask ^= checkmask;
+    checkmask <<= 1;
+  }
+
+  if (mask != 0)
+  {
+    VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_TOO_MANY)
+    retVal = 2; /* more windows requested than supported on this hardware */
+    VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,master, calMaster,0,0,0))  /* this code just prevents "unused parameter" warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  }
+  return retVal;
+}
+
+#else /* !VX1000_MPC56xCRAM_BASE_ADDR && !VX1000_FLASHPORTCTLR_BASE_ADDR */
+
+#if defined(VX1000_OVERLAY_TLB)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlaySetConfig                                                                                     */
+/* API name:      VX1000_OVL_SET_CONFIG (expression) / VX1000_OVL_SET_CONFIG_VOID (statement) - may be overloaded by user     */
+/* Wrapper API:   VX1000If_OvlSetConfigVoid                                                                                   */
+/* Return value:  status:                                                                                                     */
+/*                0: Page switch done                                                                                         */
+/*                1: Nothing done                                                                                             */
+/*                2: Value not written correctly                                                                              */
+/*                3: No single-master page-switch possible                                                                    */
+/*                4: Generic error                                                                                            */
+/* Parameter1:    dummy parameter because VX-configurable overlays are not supported by VX for MMU-based overlays             */
+/* Parameter2:    dummy parameter because VX-configurable overlays are not supported by VX for MMU-based overlays             */
+/* Parameter3:    not used                                                                                                    */
+/* Parameter4:    not used                                                                                                    */
+/* Parameter5:    Overlay Page                                                                                                */
+/* Parameter6:    Masters to be activated                                                                                     */
+/* Parameter7:    Masters resource Mask                                                                                       */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   per-core MMU-based method for enabling/disabling the static, user-defined overlay on some MPC55xx/MPC56xx   */
+/*                family members.                                                                                             */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlaySetConfig)( VX1000_UINT32 value, VX1000_UINT32 mask, VX1000_UINT32 valueB,
+                                                     VX1000_UINT32 maskB, VX1000_UINT8 page, VX1000_UINT32 master,
+                                                     VX1000_UINT32 calMaster )
+{
+  /* Note: Implementation valid only for MPC55xx/MPC56xx! */
+  VX1000_UINT8 retVal = 0; /* assume OK */
+
+  VX1000_DUMMYREAD(valueB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(maskB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+
+#if defined(VX1000_OVERLAY_VX_CONFIGURABLE)
+  if (master != calMaster)
+  {
+    retVal = 3; /* not called on the core who\'s MMU shall be reprogrammed */
+  }
+  else
+#endif /* VX1000_OVERLAY_VX_CONFIGURABLE) */
+  if (0==(calMaster & (VX1000_OVL_CAL_BUS_MASTER)))
+  {
+    VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,value, mask,master,calMaster,0)) /* dummy usage of unused parameters to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+    retVal = 1; /* bug in application: API called by a core who is excluded from overlaying by the user\'s configuration */
+  }
+  else
+  {
+    if (page == VX1000_CALPAGE_RAM)
+    {
+      (void)VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_OVERLAY_SIZE, VX1000_OVERLAY_ADDR, VX1000_CALRAM_ADDR, VX1000_CALRAM_PHYSADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+    else
+    {
+      (void)VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_OVERLAY_SIZE, VX1000_OVERLAY_ADDR, VX1000_OVERLAY_ADDR, VX1000_OVERLAY_PHYSADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+  }
+  return retVal;
+}
+#else /* !VX1000_OVERLAY_TLB */
+#if defined(VX1000_TARGET_POWERPC)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlaySetConfig                                                                                     */
+/* API name:      VX1000_OVL_SET_CONFIG (expression) / VX1000_OVL_SET_CONFIG_VOID (statement) - may be overloaded by user     */
+/* Wrapper API:   VX1000If_OvlSetConfigVoid                                                                                   */
+/* Return value:  status:                                                                                                     */
+/*                0: Page switch done                                                                                         */
+/*                1: Nothing done                                                                                             */
+/*                2: Value not written correctly                                                                              */
+/*                3: No single-master page-switch possible                                                                    */
+/*                4: Generic error                                                                                            */
+/* Parameter1:    Overlay windows to be activated/deactivated                                                                 */
+/* Parameter2:    Resource Mask (active bits\' indices must not exceed the derivatives MMU-TLB count!)                         */
+/* Parameter3:    not used                                                                                                    */
+/* Parameter4:    not used                                                                                                    */
+/* Parameter5:    Overlay Page                                                                                                */
+/* Parameter6:    Masters to be activated                                                                                     */
+/* Parameter7:    Masters resource Mask                                                                                       */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   per-core MMU-based method for enabling/disabling arbitrary overlays on some MPC55xx/MPC56xx family members. */
+/* Devel state:   Partially specified                                                                                         */
+/*                TODO:  find a way to transmit the base addresses (physical and virtual) and page attribute bits, where      */
+/*                       the virtual address would be sufficient if we introduced new callbacks "TLBRE()", "mfMASx()" etc.    */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlaySetConfig)( VX1000_UINT32 value, VX1000_UINT32 mask, VX1000_UINT32 valueB,
+                                                     VX1000_UINT32 maskB, VX1000_UINT8 page, VX1000_UINT32 master,
+                                                     VX1000_UINT32 calMaster )
+{
+  /* Note: Implementation valid only for MPC55xx/MPC56xx! */
+  VX1000_UINT8 idx, retVal = 0; /* assume OK */
+  VX1000_UINT32 checkmask = 0x00000001UL;
+  /*const VX1000_UINT32 pagetype = 1U, pageshift = 12U; /-* use 4-Kb-pages which is the minimal size on most MCUs */
+  /*const VX1000_UINT8 cache_inhibit = 1;*/
+  /*const VX1000_UINT8 cache_writethrough = 0;*/
+  /*const VX1000_UINT8 permissions = 0x3F;*/
+
+  VX1000_DUMMYREAD(valueB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(maskB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+
+  if (master != calMaster)
+  {
+    retVal = 3; /* not called on the core who\'s MMU shall be reprogrammed*/
+  }
+  else
+  {
+    for (idx = 0; idx < 32; ++idx)
+    {
+      if ((mask & checkmask) != 0)
+      {
+        /*VX1000_MPC_MMU_MTMAS0(0x10000000UL | ((VX1000_UINT32)idx << 16U)) /-* Select TLB entry */
+        /*VX1000_MPC_MMU_MTMAS1(0x80000000UL | ((VX1000_UINT32)pagetype << 8U))  /-* VALID=1, IPROT=0, TID=0, TS=0, TSIZE=pagetype */
+        /* todo EM00046006     VX1000_MPC_MMU_MTMAS2((target) | (cache_inhibit ? 0x8:0) | (cache_writethrough ? 0x10:0))*/ /* EPN = 0x06000 (addr=0x60000000), WIMAGE = xx000, TODO: vle */
+        if (page == 0)
+        {
+          /* todo EM00046006      VX1000_MPC_MMU_MTMAS3((target) | (0x3FU & permissions))*/ /* restore the native page mapping for this TLB */
+          VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+        }
+        else
+        {
+          /* todo EM00046006      VX1000_MPC_MMU_MTMAS3((source) | (0x3FU & permissions))*/ /* enable the overlay page mapping for this TLB */
+          VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+          VX1000_DUMMYREAD(value) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+        }
+      }
+      /*VX1000_MPC_MMU_TLBWE()  /-* Make pre-charged entry from MAS0..MAS3 to a valid MMU TLB */
+      checkmask <<= 1;
+    }
+  }
+  return retVal;
+}
+#endif /* VX1000_TARGET_POWERPC */
+#endif /* !VX1000_OVERLAY_TLB */
+
+#endif /* !VX1000_MPC56xCRAM_BASE_ADDR && !VX1000_FLASHPORTCTLR_BASE_ADDR */
+
+#if defined(VX1000_SH2_FCU_BASE_ADDR)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlaySetConfig                                                                                     */
+/* API name:      VX1000_OVL_SET_CONFIG (expression) / VX1000_OVL_SET_CONFIG_VOID (statement) - may be overloaded by user     */
+/* Wrapper API:   VX1000If_OvlSetConfigVoid                                                                                   */
+/* Return value:  status:                                                                                                     */
+/*                0: Page switch done                                                                                         */
+/*                1: Nothing done                                                                                             */
+/*                2: Value not written correctly                                                                              */
+/*                3: No single-master page-switch possible                                                                    */
+/*                4: Generic error                                                                                            */
+/* Parameter1:    Overlay windows to be activated/deactivated                                                                 */
+/* Parameter2:    Resource Mask                                                                                               */
+/* Parameter3:    not used                                                                                                    */
+/* Parameter4:    not used                                                                                                    */
+/* Parameter5:    Overlay Page                                                                                                */
+/* Parameter6:    Masters to be activated                                                                                     */
+/* Parameter7:    Masters resource Mask                                                                                       */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for enabling/disabling overlays.                                                 */
+/* Devel state:   Specified                                                                                                   */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlaySetConfig)( VX1000_UINT32 value, VX1000_UINT32 mask, VX1000_UINT32 valueB,
+                                                     VX1000_UINT32 maskB, VX1000_UINT8 page, VX1000_UINT32 master,
+                                                     VX1000_UINT32 calMaster )
+{
+
+  VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,value, mask,page,master,calMaster)) /* dummy usage of unused operands */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(valueB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(maskB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+
+  VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+
+  return 1; /* "not implemented, yet" */
+}
+#endif /* VX1000_SH2_FCU_BASE_ADDR */
+
+#if defined(VX1000_TARGET_X850)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlaySetConfig                                                                                     */
+/* API name:      VX1000_OVL_SET_CONFIG (expression) / VX1000_OVL_SET_CONFIG_VOID (statement) - may be overloaded by user     */
+/* Wrapper API:   VX1000If_OvlSetConfigVoid                                                                                   */
+/* Return value:  status:                                                                                                     */
+/*                0: Page switch done                                                                                         */
+/*                1: Nothing done                                                                                             */
+/*                2: Value not written correctly                                                                              */
+/*                3: No single-master page-switch possible                                                                    */
+/*                4: Generic error                                                                                            */
+/* Parameter1:    Overlay windows to be activated/deactivated (bank A)                                                        */
+/* Parameter2:    Resource Mask (bank A)                                                                                      */
+/* Parameter3:    Overlay windows to be activated/deactivated (bank B)                                                        */
+/* Parameter4:    Resource Mask (bank B)                                                                                      */
+/* Parameter5:    Overlay Page                                                                                                */
+/* Parameter6:    Masters to be activated                                                                                     */
+/* Parameter7:    Masters resource Mask                                                                                       */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for enabling/disabling overlays.                                                 */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+#if defined(VX1000_TARGET_X850_CFU3)
+VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlaySetConfig)( VX1000_UINT32 value, VX1000_UINT32 mask, VX1000_UINT32 valueB,
+                                                     VX1000_UINT32 maskB, VX1000_UINT8 page, VX1000_UINT32 master,
+                                                     VX1000_UINT32 calMaster)
+{
+  VX1000_UINT8 result;
+
+  if (0 == (calMaster & (VX1000_OVL_CAL_BUS_MASTER)))
+  {
+    result = 1;
+  }
+#if defined(VX1000_OVERLAY_VX_CONFIGURABLE)
+  else if (0 == (master & calMaster))
+  {
+    result = 3;
+  }
+#endif /* VX1000_OVERLAY_VX_CONFIGURABLE */
+  else
+  {
+    (VX1000_ADDR_TO_PTR2VU32(0xFFFF7810UL))[0] = ((VX1000_ADDR_TO_PTR2VU32(0xFFFF7810UL))[0] & (~mask)) | (value & mask);  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    (VX1000_ADDR_TO_PTR2VU32(0xFFFF7818UL))[0] = ((VX1000_ADDR_TO_PTR2VU32(0xFFFF7818UL))[0] & (~maskB)) | (valueB & maskB);  /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    /* clear cache */
+    (VX1000_ADDR_TO_PTR2VU32(0xFFFF7808UL))[0] = 1; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    result = 0;
+  }
+
+  return result;
+}
+#else /* !VX1000_TARGET_X850_CFU3 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlaySetConfig                                                                                     */
+/* API name:      VX1000_OVL_SET_CONFIG (expression) / VX1000_OVL_SET_CONFIG_VOID (statement) - may be overloaded by user     */
+/* Wrapper API:   VX1000If_OvlSetConfigVoid                                                                                   */
+/* Return value:  status:                                                                                                     */
+/*                0: Page switch done                                                                                         */
+/*                1: Nothing done                                                                                             */
+/*                2: Value not written correctly                                                                              */
+/*                3: No single-master page-switch possible                                                                    */
+/*                4: Generic error                                                                                            */
+/* Parameter1:    Overlay windows to be activated/deactivated (bank A)                                                        */
+/* Parameter2:    Resource Mask (bank A)                                                                                      */
+/* Parameter3:    Overlay windows to be activated/deactivated (bank B)                                                        */
+/* Parameter4:    Resource Mask (bank B)                                                                                      */
+/* Parameter5:    Overlay Page                                                                                                */
+/* Parameter6:    Masters to be activated                                                                                     */
+/* Parameter7:    Masters resource Mask                                                                                       */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for enabling/disabling overlays.                                                 */
+/* Devel state:   Specified                                                                                                   */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlaySetConfig)( VX1000_UINT32 value, VX1000_UINT32 mask, VX1000_UINT32 valueB,
+                                                     VX1000_UINT32 maskB, VX1000_UINT8 page, VX1000_UINT32 master,
+                                                     VX1000_UINT32 calMaster)
+{
+  VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,value, mask,page,master,calMaster)) /* dummy usage of unused operands */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(valueB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(maskB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+
+  return 1; /* "not implemented, yet" */
+}
+#endif /* !VX1000_TARGET_X850_CFU3 */
+#endif /* VX1000_TARGET_X850 */
+
+#if defined(VX1000_TARGET_TRICORE)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlaySetConfig                                                                                     */
+/* API name:      VX1000_OVL_SET_CONFIG (expression) / VX1000_OVL_SET_CONFIG_VOID (statement) - may be overloaded by user     */
+/* Wrapper API:   VX1000If_OvlSetConfigVoid                                                                                   */
+/* Return value:  status:                                                                                                     */
+/*                0: Page switch done                                                                                         */
+/*                1: Nothing done                                                                                             */
+/*                2: Value not written correctly                                                                              */
+/*                3: No single-master page-switch possible                                                                    */
+/*                4: Generic error                                                                                            */
+/* Parameter1:    Overlay windows to be activated/deactivated in case of VX-configurable overlays (unused otherwise)          */
+/* Parameter2:    Resource Mask in case of VX-configurable overlays (unused otherwise)                                        */
+/* Parameter3:    not used                                                                                                    */
+/* Parameter4:    not used                                                                                                    */
+/* Parameter5:    Overlay Page                                                                                                */
+/* Parameter6:    Masters to be activated                                                                                     */
+/* Parameter7:    Masters resource Mask                                                                                       */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for enabling/disabling overlays.                                                 */
+/*                Note: the driver assumes exclusive ownership of the overlay unit.                                           */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlaySetConfig)( VX1000_UINT32 value, VX1000_UINT32 mask, VX1000_UINT32 valueB,
+                                                     VX1000_UINT32 maskB, VX1000_UINT8 page, VX1000_UINT32 master,
+                                                     VX1000_UINT32 calMaster )
+{
+  VX1000_UINT8 retVal = 0; /* assume OK */
+  VX1000_UINT8 sfrModel = 0U; /* default to classic TriCore registers */
+  VX1000_UINT32 existDescr = 0x00000000UL; /* by default assume invalid configuration */
+  VX1000_UINT32 masterMask = 0x00000000UL;
+
+  VX1000_DUMMYREAD(valueB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(maskB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  switch ((VX1000_MCREG_CBS_JTAGID) & (VX1000_JTAGID_PN_MASK)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  {
+    case VX1000_JTAGID_PN_TC172x:       existDescr = 0x0000FFFFUL; masterMask = 0x00000001UL; sfrModel = 0U; break; /* FutureMax : not sure about the sfrModel */
+    case VX1000_JTAGID_PN_TC1387:       existDescr = 0x0000FFFFUL; masterMask = 0x00000001UL; sfrModel = 0U; break; /* AudoS */
+    case VX1000_JTAGID_PN_TC178x:       existDescr = 0x0000FFFFUL; masterMask = 0x00000001UL; sfrModel = 0U; break; /* AudoMax */
+    case VX1000_JTAGID_PN_TC1767:       existDescr = 0x0000FFFFUL; masterMask = 0x00000001UL; sfrModel = 0U; break; /* AudoFuture */
+    case VX1000_JTAGID_PN_TC1797:       existDescr = 0x0000FFFFUL; masterMask = 0x00000001UL; sfrModel = 0U; break; /* AudoFuture */
+    case VX1000_JTAGID_PN_TC1798:       existDescr = 0x0000FFFFUL; masterMask = 0x00000001UL; sfrModel = 1U; break; /* AudoMax */
+    case VX1000_JTAGID_PN_TC21x:        existDescr = 0x000000FFUL; masterMask = 0x00000001UL; sfrModel = 2U; break; /* just a guess: "Aurix single core with 8 descriptors" */
+    case VX1000_JTAGID_PN_TC22x:        existDescr = 0x000000FFUL; masterMask = 0x00000001UL; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC23x:        existDescr = 0x000000FFUL; masterMask = 0x00000001UL; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC24x:        existDescr = 0xFFFFFFFFUL; masterMask = 0x00000001UL; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC26x:        existDescr = 0xFFFFFFFFUL; masterMask = 0x00000003UL; sfrModel = 3U; break; /* Aurix dual core */
+    case VX1000_JTAGID_PN_TC27xTC2Dx:   existDescr = 0xFFFFFFFFUL; masterMask = 0x00000007UL; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC29x:        existDescr = 0xFFFFFFFFUL; masterMask = 0x00000007UL; sfrModel = 4U; break; /* Aurix triple core */
+    /*
+    TODOKNM: case VX1000_JTAGID_PN_TC32x:        existDescr = 0xFFFFFFFFUL; masterMask = ?UL; sfrModel = ?U; break; How many cores have we got?
+    */
+    case VX1000_JTAGID_PN_TC33x:        existDescr = 0xFFFFFFFFUL; masterMask = 0x00000001UL; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC33xED:      existDescr = 0xFFFFFFFFUL; masterMask = 0x00000003UL; sfrModel = 3U; break; /* Aurix dual core */
+    case VX1000_JTAGID_PN_TC35x:        existDescr = 0xFFFFFFFFUL; masterMask = 0x00000007UL; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC36x:        existDescr = 0xFFFFFFFFUL; masterMask = 0x00000003UL; sfrModel = 3U; break; /* Aurix dual core */
+    case VX1000_JTAGID_PN_TC37x:        existDescr = 0xFFFFFFFFUL; masterMask = 0x00000007UL; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC37xED:      existDescr = 0xFFFFFFFFUL; masterMask = 0x00000007UL; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC38x:        existDescr = 0xFFFFFFFFUL; masterMask = 0x0000000FUL; sfrModel = 5U; break; /* Aurix quad core */
+    case VX1000_JTAGID_PN_TC39x:        existDescr = 0xFFFFFFFFUL; masterMask = 0x0000003FUL; sfrModel = 7U; break; /* Aurix hexa core */
+    default: break;
+  }
+#if defined(VX1000_OVERLAY_VX_CONFIGURABLE)
+  if (mask != existDescr) /* Ensure that the application did not allocate descriptors for its own purposes. (todo: mask is fetched from gVX1000.Ovl.syncCalData.overlayMask which is initialised to zero once but not updated by FW nor driver) */
+  {
+    VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_NONEXCLUSIVE)  /* we cannot mess with the global overlay settings if we\'re not the exclusive owner of all existing descriptors */
+    retVal = 4;
+  }
+  else if ( (master & calMaster) != master )
+  {
+    retVal = 3;
+  }
+  else
+#else  /* !VX1000_OVERLAY_VX_CONFIGURABLE) */
+  VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,value, mask,existDescr,calMaster,retVal)) /* dummy usage of unused operands */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  value = 1UL << (VX1000_OVERLAY_DESCR_IDX);
+#endif /* !VX1000_OVERLAY_VX_CONFIGURABLE) */
+  {
+    /* OK, turn the preconfigured overlays on or off */
+    if (sfrModel != 0U)
+    {
+      VX1000_MCREG_CBS_OCNTRL = 0x000000C0UL; /* unlock the ENDINIT protected registers */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+    if ((sfrModel == 0U) || (sfrModel == 1U))
+    {
+        VX1000_MCREG_OVC_OENABLE = 0x00000001UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        /* Overlay Configuration and Range Select Register (clear before loading the new configuration): */
+        VX1000_MCREG_OVC_OCON = 0x00000000UL | value; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        {
+          volatile VX1000_UINT32 dummy;
+          for (dummy = 0; dummy < 1000; ++dummy) { VX1000_DUMMYREAD(dummy) } /* writes to OVC_OCON trigger asynchronous actions by the HW and the SW shall not write again while actions are in progress. So wait a bit */
+        }
+        if (page == 0) { VX1000_MCREG_OVC_OCON = 0x00060000UL | value; } /* DCINVAL|OVSTP  --> display flash */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        else           { VX1000_MCREG_OVC_OCON = 0x00050000UL | value; } /* DCINVAL|OVSTRT --> display RAM in the selected windows */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+    else
+    {
+      master &= masterMask;
+      /* Overlay Window Select Registers and Overlay Configuration Register (note: this implicitly DISABLES ALL OTHER descriptors and en/disables the user-configured descriptor as requested by SET_CAL_PAGE from the tool --> no other overlay users possible in parallel): */
+      if ((master & 0x01UL) != 0) { VX1000_MCREG_OVC0_OSEL = value; } /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      if ((master & 0x02UL) != 0) { VX1000_MCREG_OVC1_OSEL = value; } /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      if ((master & 0x04UL) != 0) { VX1000_MCREG_OVC2_OSEL = value; } /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      if ((master & 0x08UL) != 0) { VX1000_MCREG_OVC3_OSEL = value; } /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      if ((master & 0x10UL) != 0) { VX1000_MCREG_OVC4_OSEL = value; } /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      if ((master & 0x20UL) != 0) { VX1000_MCREG_OVC5_OSEL = value; } /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      if (page == 0)              { VX1000_MCREG_SCU_OVCCON = (master & 0xFFFFUL) | 0x00060000UL; } /* DCINVAL|OVSTP|master  --> display flash */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      else                        { VX1000_MCREG_SCU_OVCCON = (master & 0xFFFFUL) | 0x00050000UL; } /* DCINVAL|OVSTRT|master --> display RAM on the selected masters */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+    if (sfrModel != 0U)
+    {
+      VX1000_MCREG_CBS_OCNTRL = 0x00000040UL; /* restore the ENDINIT protection state */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+  }
+  return retVal;
+}
+#endif /* VX1000_TARGET_TRICORE */
+
+#if defined(VX1000_TARGET_XC2000)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlaySetConfig                                                                                     */
+/* API name:      VX1000_OVL_SET_CONFIG (expression) / VX1000_OVL_SET_CONFIG_VOID (statement) - may be overloaded by user     */
+/* Wrapper API:   VX1000If_OvlSetConfigVoid                                                                                   */
+/* Return value:  status:                                                                                                     */
+/*                0: Page switch done                                                                                         */
+/*                1: Nothing done                                                                                             */
+/*                2: Value not written correctly                                                                              */
+/*                3: No single-master page-switch possible                                                                    */
+/*                4: Generic error                                                                                            */
+/* Parameter1:    Overlay windows to be activated/deactivated                                                                 */
+/* Parameter2:    Resource Mask                                                                                               */
+/* Parameter3:    not used                                                                                                    */
+/* Parameter4:    not used                                                                                                    */
+/* Parameter5:    Overlay Page                                                                                                */
+/* Parameter6:    Masters to be activated                                                                                     */
+/* Parameter7:    Masters resource Mask                                                                                       */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Derivative-specific method for enabling/disabling overlays.                                                 */
+/* Devel state:   Specified                                                                                                   */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlaySetConfig)( VX1000_UINT32 value, VX1000_UINT32 mask, VX1000_UINT32 valueB,
+                                                     VX1000_UINT32 maskB, VX1000_UINT8 page, VX1000_UINT32 master,
+                                                     VX1000_UINT32 calMaster )
+{
+  VX1000_DUMMYREAD(valueB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_DUMMYREAD(maskB) /* dummy access to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+
+  VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT32,value, mask,page,master,calMaster)) /* dummy usage of unused operands */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+
+  return 1; /* "not implemented, yet" */
+}
+#endif /* VX1000_TARGET_XC2000 */
+
+#endif /* VX1000_OVL_SET_CONFIG_INTERNAL */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_overlayIsPageSwitchReq                                                                               */
+/* API name:      VX1000_OVL_IS_PAGESW_REQUESTED                                                                              */
+/* Wrapper API:   VX1000If_OvlIsPageSwRequested                                                                               */
+/* Return value:  status:                                                                                                     */
+/*                0: None of the interesting bus masters has a pending request to switch his page                             */
+/*                1: At least one of the interesting masters shall switch his page                                            */
+/* Parameter1:    A bit mask for up to 32 bus masters whose status the caller is interested in                                */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Returns whether there\'s a page switch request pending on any of the bus masters selected by the bit mask.   */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_overlayIsPageSwitchReq)(VX1000_UINT32 master)
+{
+  VX1000_UINT8 i, retVal = 0;
+  if (gVX1000.Ovl.syncCalData.pageSwitchRequested != 0)
+  {
+    for (i = 0; (0==retVal) && (i < 32); i++)
+    {
+      if ((master & (1UL<<i)) != 0)
+      {
+        if (gVX1000.Ovl.syncCalData.coreDone[i] == 0)
+        {
+          retVal = 1;
+        }
+      }
+    }
+  }
+  return retVal;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlayChkPageSwitchCore                                                                             */
+/* API name:      VX1000_OVL_CHK_PAGESW_CORE (expression) / VX1000_OVL_CHK_PAGESW_CORE_VOID (statement)                       */
+/* Wrapper API:   VX1000If_OvlChkPageSwCore (expression) / VX1000If_OvlChkPageSwCoreVoid (statement)                          */
+/* Return value:  status:                                                                                                     */
+/*                0: All interesting bus masters finished the page switch                                                     */
+/*                1: At least one of the interesting masters is still using the wrong page                                    */
+/* Parameter1:    A bit mask for up to 32 bus masters whose status the caller is interested in                                */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Checks and remembers the switching status of the bus masters that are selected by the given bit mask.       */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlayChkPageSwitchCore)( VX1000_UINT32 master )
+{
+  VX1000_UINT32 i;
+  VX1000_UINT8 someNotReady = 0;
+  VX1000_UINT8 result;
+  if (gVX1000.Ovl.syncCalData.pageSwitchRequested != 0)
+  {
+    for (i = 0; i < 32; i++)
+    {
+      if ((master & (1UL<<i)) != 0)
+      {
+        if (gVX1000.Ovl.syncCalData.coreDone[i] == 0)
+        {
+          someNotReady = 1;
+          /*
+          Note: core-synchronous page switching not supported on RH850 (only target with > 32 bits overlay configuration bitmaps)
+          */
+          result = VX1000_OVL_SET_CONFIG(gVX1000.Ovl.syncCalData.overlayValue, gVX1000.Ovl.syncCalData.overlayMask,
+                                         gVX1000.Ovl.syncCalData.overlayValueB, gVX1000.Ovl.syncCalData.overlayMaskB,
+                                         gVX1000.Ovl.syncCalData.targetPage, master, gVX1000.Ovl.ovlBusMasterMask);
+          if (result == 0)
+          {
+            /* 0 means no error. returning 1 to signal done*/
+            gVX1000.Ovl.syncCalData.coreDone[i] = 1;
+          }
+          else if (result == 1)
+          {
+            /* 1 is not a valid return value. Use Generic error instead */
+            gVX1000.Ovl.syncCalData.coreDone[i] = 2;
+          }
+          else
+          {
+            gVX1000.Ovl.syncCalData.coreDone[i] = result;
+          }
+        }
+      }
+    }
+  }
+  return someNotReady;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OverlayChkPageSwitchDone                                                                             */
+/* API name:      VX1000_OVL_CHK_PAGESW_DONE (expression) / VX1000_OVL_CHK_PAGESW_DONE_VOID (statement)                       */
+/* Wrapper API:   VX1000If_OvlChkPageSwDone (expression) / VX1000If_OvlChkPageSwDoneVoid (statement)                          */
+/* Return value:  0: no page switch in progress                                                                               */
+/*                1: switch in progress by some cores                                                                         */
+/*                2: some cores reported a page switch error                                                                  */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Checks and remembers the switching status of all bus masters for which a page switch had been requested.    */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT8 VX1000_SUFFUN(vx1000_OverlayChkPageSwitchDone)( void )
+{
+  VX1000_UINT8 i;
+  VX1000_UINT8 retVal = 0;
+  VX1000_UINT8 someNotReady = 0;
+  VX1000_UINT8 someHasErrors = 0;
+  VX1000_UINT8 firstError = 0;
+  if (gVX1000.Ovl.syncCalData.pageSwitchRequested != 0)
+  {
+    for (i = 0; i < 32; i++)
+    {
+      if ((gVX1000.Ovl.syncCalData.busMasterRequested & (1UL<<i)) != 0)
+      {
+        if (gVX1000.Ovl.syncCalData.coreDone[i] == 0)
+        {
+          someNotReady = 1;
+        }
+        else if (gVX1000.Ovl.syncCalData.coreDone[i] == 1)
+        {
+          /* Switch was executed correctly */
+        }
+        else
+        {
+          firstError = gVX1000.Ovl.syncCalData.coreDone[i];
+          someHasErrors = 1;
+        }
+      }
+    }
+    if (someNotReady == 0)
+    {
+      retVal = 1;
+      gVX1000.Ovl.syncCalData.pageSwitchRequested = 0;
+      VX1000_OVL_SET_CONFIG_DONE(firstError, gVX1000.Ovl.syncCalData.targetPage)
+    }
+    if (someHasErrors != 0)
+    {
+      retVal = 2;
+    }
+  }
+  return retVal;
+}
+
+#endif /* VX1000_OVLENBL_SYNC_PAGESWITCH */
+
+#endif /* VX1000_OVERLAY & VX1000_MAILBOX_OVERLAY_CONTROL */
+
+#if defined(VX1000_OVERLAY) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+
+#if defined(VX1000_MAILBOX_OVERLAY_CONTROL)
+
+#if defined(VX1000_GET_CAL_PAGE_INTERNAL)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_GetCalPage                                                                                           */
+/* API name:      VX1000_GET_CAL_PAGE (internal) - may be overloaded by user                                                  */
+/* Return value:  0: reference page / 1: working page                                                                         */
+/* Parameter1:    overlay segment number E {0}                                                                                */
+/* Parameter2:    Select between VX1000_CAL_ECU and VX1000_CAL_XCP                                                            */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Finds out whether the ECU or the XCP driver is currently using the working page or the reference page.      */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_GetCalPage)( VX1000_UINT8 segment, VX1000_UINT8 mode )
+{
+  VX1000_UINT8 retVal = gVX1000_ECU_CalPage;
+
+  if ((mode & ((VX1000_CAL_ECU) | (VX1000_CAL_XCP))) == (VX1000_CAL_ECU))
+  {
+    retVal = gVX1000_ECU_CalPage;
+  }
+  else if ((mode & ((VX1000_CAL_ECU) | (VX1000_CAL_XCP))) == (VX1000_CAL_XCP))
+  {
+    retVal = gVX1000_XCP_CalPage;
+  }
+  else /* just here for MISRA */
+  {
+    VX1000_DUMMYREAD(segment) /* just to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  }
+  return retVal;
+}
+#endif /* VX1000_GET_CAL_PAGE_INTERNAL */
+
+
+
+#if defined(VX1000_SET_CAL_PAGE_EXTERNAL)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_SetCalPage                                                                                           */
+/* API name:      VX1000_WRP_SET_CAL_PAGE, VX1000_WRP_SET_CAL_PAGE_VOID (internal wrapper for user\'s VX1000_SET_CAL_PAGE)     */
+/* Return value:  0: OK; !0: ERROR                                                                                            */
+/* Parameter1:    overlay segment number E {0}                                                                                */
+/* Parameter2:    Select between reference page and working page                                                              */
+/* Parameter3:    Select between VX1000_CAL_ECU and VX1000_CAL_XCP                                                            */
+/* Parameter4:    0: called by user action; 1: called internally by vx1000_DetectVxAsyncEnd()                                 */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Call the user\'s implementation to physically switch the page, then update the driver\'s status accordingly.  */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_SetCalPage)( VX1000_UINT8 segment, VX1000_UINT8 page, VX1000_UINT8 mode, VX1000_UINT8 onStartup )
+{
+  VX1000_UINT8 retVal = VX1000_SET_CAL_PAGE(segment, page, mode, onStartup);
+
+  if (retVal != 0)
+  {
+    /* the user callback returned an error, so assume that the page state was not changed at all. */
+    VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_USER_FAILED)
+  }
+  else if ((mode & ((VX1000_CAL_ECU) | (VX1000_CAL_XCP))) == ((VX1000_CAL_ECU) | (VX1000_CAL_XCP)))
+  {
+    if (page != gVX1000_ECU_CalPage)
+    {
+      if (page == VX1000_CALPAGE_RAM)
+      {
+        gVX1000.ToolDetectState |= VX1000_TDS_WORKING_PAGE;
+      }
+      else
+      {
+        gVX1000.ToolDetectState &= (~VX1000_TDS_WORKING_PAGE);
+      }
+      gVX1000_XCP_CalPage = page;
+      gVX1000_ECU_CalPage = page;
+    }
+  }
+  else if ((mode & (VX1000_CAL_ECU)) != 0)
+  {
+    if (page != gVX1000_ECU_CalPage)
+    {
+      if (page == VX1000_CALPAGE_RAM)
+      {
+        gVX1000.ToolDetectState |= VX1000_TDS_WORKING_PAGE;
+      }
+      else
+      {
+        gVX1000.ToolDetectState &= (~VX1000_TDS_WORKING_PAGE);
+      }
+      gVX1000_ECU_CalPage = page;
+    }
+  }
+  else if ((mode & (VX1000_CAL_XCP)) != 0)
+  {
+    gVX1000_XCP_CalPage = page;
+  }
+  else /* the empty else case is here only for MISRA */
+  {
+    VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,onStartup, segment,0,0,0)) /* just to avoid compiler warnings (VX1000_SET_CAL_PAGE() is a user macro that typically does not use the onStartup parameter) */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  }
+
+  return retVal;
+}
+#endif /* VX1000_SET_CAL_PAGE_EXTERNAL */
+
+#if defined(VX1000_SET_CAL_PAGE_INTERNAL)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_SetCalPage                                                                                           */
+/* API name:      VX1000_WRP_SET_CAL_PAGE, VX1000_WRP_SET_CAL_PAGE_VOID (complete internal version, may be overloaded by user)*/
+/* Return value:  0: OK; !0: ERROR                                                                                            */
+/* Parameter1:    overlay segment number E {0}                                                                                */
+/* Parameter2:    Select between reference page and working page                                                              */
+/* Parameter3:    Select between VX1000_CAL_ECU and VX1000_CAL_XCP                                                            */
+/* Parameter4:    0: called by user action; 1: called internally by vx1000_DetectVxAsyncEnd()                                 */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   perform a page switch to the desired page                                                                   */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_SetCalPage)( VX1000_UINT8 segment, VX1000_UINT8 page, VX1000_UINT8 mode, VX1000_UINT8 onStartup )
+{
+  VX1000_UINT8 retVal = 0;
+#if defined(VX1000_OVLENBL_CORE_SYNC_PAGESW)
+  VX1000_UINT8 i;
+#endif /* VX1000_OVLENBL_CORE_SYNC_PAGESW */
+  if (segment != 0)
+  {
+    VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_TOO_MANY)
+    retVal = VX1000_CRC_OUT_OF_RANGE; /* Only one segment supported */
+  }
+  else if (page > 1)
+  {
+    VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_INVALID_PAGE)
+    retVal = VX1000_CRC_PAGE_NOT_VALID;
+  }
+#if defined(VX1000_OVERLAY_VX_CONFIGURABLE)
+  else if ((mode & (VX1000_CAL_ECU)) != 0)
+  {
+    /* Hint: switching the VX1000_CAL_XCP is not relevant in this mode (it is handled by the VX). */
+
+#if defined(VX1000_OVLENBL_VALIDATE_PAGESW)
+    if (page != 0)
+    {
+#if defined(VX1000_OVLENBL_USE_VX_EPK_TRANS)
+      retVal = (VX1000_UINT8)(VX1000_SYNCAL_VALIDATE_WP_CB(gVX1000.Ovl.ovlWorkingPageDataEPKAddress));
+#else /* !VX1000_OVLENBL_USE_VX_EPK_TRANS */
+      retVal = (VX1000_UINT8)(VX1000_SYNCAL_USRVALIDATE_WP_CB(gVX1000.Ovl.ovlConfigValue, gVX1000.Ovl.ovlConfigMask, gVX1000.Ovl.ovlBusMasterMask));
+#endif /* !VX1000_OVLENBL_USE_VX_EPK_TRANS */
+    }
+    if (retVal != 0)
+    {
+      ; /* do nothing any more */
+    }
+    else
+#endif /* VX1000_OVLENBL_VALIDATE_PAGESW */
+
+#if defined(VX1000_OVLENBL_CORE_SYNC_PAGESW)
+    if (0==onStartup)
+    {
+      gVX1000.Ovl.syncCalData.pageSwitchRequested = 0;
+      gVX1000.Ovl.syncCalData.overlayValue = gVX1000.Ovl.ovlConfigValue;
+      gVX1000.Ovl.syncCalData.overlayValueB = gVX1000.Ovl.ovlConfigValueB;
+      gVX1000.Ovl.syncCalData.overlayMask = gVX1000.Ovl.ovlConfigMask;
+      gVX1000.Ovl.syncCalData.overlayMaskB = gVX1000.Ovl.ovlConfigMaskB;
+      gVX1000.Ovl.syncCalData.targetPage = page;
+      gVX1000.Ovl.syncCalData.busMasterRequested = gVX1000.Ovl.ovlBusMasterMask;
+      for (i = 0; i < 32; i++)
+      {
+        gVX1000.Ovl.syncCalData.coreDone[i] = 0;
+      }
+      VX1000_DUMMYREAD(gVX1000.Ovl.syncCalData.pageSwitchRequested) /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+      gVX1000.Ovl.syncCalData.pageSwitchRequested = 1;
+      /* The actual switch is done asynchronously */
+      retVal = VX1000_CRC_CMD_BUSY;
+    }
+    else
+    {
+      retVal = VX1000_OVL_SET_CONFIG(gVX1000.Ovl.ovlConfigValue, gVX1000.Ovl.ovlConfigMask, gVX1000.Ovl.ovlConfigValueB, gVX1000.Ovl.ovlConfigMaskB, page, gVX1000.Ovl.ovlBusMasterMask,  gVX1000.Ovl.ovlBusMasterMask);
+      VX1000_OVL_SET_CONFIG_DONE_STUP(retVal, page) /* the STUP version suppresses generation of a MX response */
+    }
+#else /* !VX1000_OVLENBL_CORE_SYNC_PAGESW */
+    {
+#if defined(VX1000_OVLENBL_SYNC_PAGESWITCH)
+      retVal = VX1000_OVL_SET_CONFIG(gVX1000.Ovl.ovlConfigValue, gVX1000.Ovl.ovlConfigMask, gVX1000.Ovl.ovlConfigValueB, gVX1000.Ovl.ovlConfigMaskB, page, gVX1000.Ovl.ovlBusMasterMask, gVX1000.Ovl.ovlBusMasterMask);
+      VX1000_OVL_SET_CONFIG_DONE_STUP(retVal, page) /* the STUP version suppresses generation of a MX response */
+#else /* !VX1000_OVLENBL_SYNC_PAGESWITCH */
+      retVal = 1;
+#endif /* !VX1000_OVLENBL_SYNC_PAGESWITCH */
+    }
+#endif /* !VX1000_OVLENBL_CORE_SYNC_PAGESW */
+  }
+#else /* !VX1000_OVERLAY_VX_CONFIGURABLE */
+#if (defined(VX1000_OVERLAY_TLB) || defined(VX1000_OVERLAY_DESCR_IDX)) || (defined(VX1000_MPC56xCRAM_BASE_ADDR) || defined(VX1000_SH2_FCU_BASE_ADDR))
+  else if ((mode & ((VX1000_CAL_ECU) | (VX1000_CAL_XCP))) == ((VX1000_CAL_ECU) | (VX1000_CAL_XCP)))
+  { /* switch both the XCP and the ECU view */
+#if defined(VX1000_OVLENBL_CORE_SYNC_PAGESW)
+    if (0==onStartup)
+    {
+      gVX1000.Ovl.syncCalData.pageSwitchRequested = 0;
+      gVX1000.Ovl.syncCalData.overlayValue = gVX1000.Ovl.ovlConfigValue;
+      gVX1000.Ovl.syncCalData.overlayValueB = gVX1000.Ovl.ovlConfigValueB;
+      gVX1000.Ovl.syncCalData.overlayMask = gVX1000.Ovl.ovlConfigMask;
+      gVX1000.Ovl.syncCalData.overlayMaskB = gVX1000.Ovl.ovlConfigMaskB;
+      gVX1000.Ovl.syncCalData.targetPage = page;
+      gVX1000.Ovl.syncCalData.busMasterRequested = gVX1000.Ovl.ovlBusMasterMask;
+      for (i = 0; i < 32; i++)
+      {
+        gVX1000.Ovl.syncCalData.coreDone[i] = 0;
+      }
+      VX1000_DUMMYREAD(gVX1000.Ovl.syncCalData.pageSwitchRequested) /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+      gVX1000.Ovl.syncCalData.pageSwitchRequested = 1;
+      /* The actual switch is done asynchronously */
+      retVal = VX1000_CRC_CMD_BUSY;
+    }
+    else
+    {
+#if defined(VX1000_OVERLAY_DESCR_IDX)
+      /* Pre-initialise the PFLASH controller overlay windows but do not activate them for any bus-master, yet. */
+      /* The particular bus masters may just (de-)activate them later on demand. (We have to assume that no one */
+      /* uses this feature on a McKinleyCut1 chip because this one lacks the ability do deactivate masters!)    */
+      /* Therefore neither the page status variables nor the ToolDetectState bits are to be updated here.       */
+      (void)VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_OVERLAY_SIZE, VX1000_OVERLAY_ADDR, VX1000_CALRAM_ADDR, VX1000_CALRAM_PHYSADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#endif /* VX1000_OVERLAY_DESCR_IDX */
+      retVal = VX1000_OVL_SET_CONFIG(gVX1000.Ovl.ovlConfigValue, gVX1000.Ovl.ovlConfigMask, gVX1000.Ovl.ovlConfigValueB, gVX1000.Ovl.ovlConfigMaskB, page, gVX1000.Ovl.ovlBusMasterMask,  gVX1000.Ovl.ovlBusMasterMask);
+      VX1000_OVL_SET_CONFIG_DONE_STUP(retVal, page) /* the STUP version suppresses generation of a MX response */
+    }
+#elif defined(VX1000_OVLENBL_SYNC_PAGESWITCH)
+    retVal = VX1000_OVL_SET_CONFIG(gVX1000.Ovl.ovlConfigValue, gVX1000.Ovl.ovlConfigMask, gVX1000.Ovl.ovlConfigValueB, gVX1000.Ovl.ovlConfigMaskB, page, gVX1000.Ovl.ovlBusMasterMask,  gVX1000.Ovl.ovlBusMasterMask);
+    VX1000_OVL_SET_CONFIG_DONE_STUP(retVal, page)  /* the STUP version suppresses generation of a MX response */
+#else  /* !VX1000_OVLENBL_CORE_SYNC_PAGESW && !VX1000_OVLENBL_SYNC_PAGESWITCH */
+    if (page != gVX1000_ECU_CalPage)
+    { /* configuration changed */
+      if (page == VX1000_CALPAGE_RAM)
+      { /* RAM */
+        (void)VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_OVERLAY_SIZE, VX1000_OVERLAY_ADDR, VX1000_CALRAM_ADDR, VX1000_CALRAM_PHYSADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        gVX1000.ToolDetectState |= VX1000_TDS_WORKING_PAGE;
+      }
+      else
+      { /* Flash */
+        (void)VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_OVERLAY_SIZE, VX1000_OVERLAY_ADDR, VX1000_OVERLAY_ADDR, VX1000_OVERLAY_PHYSADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        gVX1000.ToolDetectState &= (~VX1000_TDS_WORKING_PAGE);
+      }
+      gVX1000_ECU_CalPage = page;
+    }
+    gVX1000_XCP_CalPage = page;
+#endif /* !VX1000_OVLENBL_CORE_SYNC_PAGESW && !VX1000_OVLENBL_SYNC_PAGESWITCH */
+  }
+  else if ((mode & (VX1000_CAL_ECU)) != 0)
+  { /* switch only ECU view */
+#if defined(VX1000_OVLENBL_CORE_SYNC_PAGESW)
+    if (0==onStartup)
+    {
+      gVX1000.Ovl.syncCalData.pageSwitchRequested = 0;
+      gVX1000.Ovl.syncCalData.overlayValue = gVX1000.Ovl.ovlConfigValue;
+      gVX1000.Ovl.syncCalData.overlayValueB = gVX1000.Ovl.ovlConfigValueB;
+      gVX1000.Ovl.syncCalData.overlayMask = gVX1000.Ovl.ovlConfigMask;
+      gVX1000.Ovl.syncCalData.overlayMaskB = gVX1000.Ovl.ovlConfigMaskB;
+      gVX1000.Ovl.syncCalData.targetPage = page;
+      gVX1000.Ovl.syncCalData.busMasterRequested = gVX1000.Ovl.ovlBusMasterMask;
+      for (i = 0; i < 32; i++)
+      {
+        gVX1000.Ovl.syncCalData.coreDone[i] = 0;
+      }
+      VX1000_DUMMYREAD(gVX1000.Ovl.syncCalData.pageSwitchRequested) /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+      gVX1000.Ovl.syncCalData.pageSwitchRequested = 1;
+      /* The actual switch is done asynchronously */
+      retVal = VX1000_CRC_CMD_BUSY;
+    }
+    else
+    {
+#if defined(VX1000_OVERLAY_DESCR_IDX)
+      /* Pre-initialise the PFLASH controller overlay windows but do not activate them for any bus-master, yet. */
+      /* The particular bus masters may just (de-)activate them later on demand. (We have to assume that no one */
+      /* uses this feature on a McKinleyCut1 chip because this one lacks the ability do deactivate masters!)    */
+      /* Therefore neither the page status variables nor the ToolDetectState bits are to be updated here.       */
+/*
+      (void)VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_OVERLAY_SIZE, VX1000_OVERLAY_ADDR, VX1000_CALRAM_ADDR, VX1000_CALRAM_PHYSADDR);
+*/
+#endif /* VX1000_OVERLAY_DESCR_IDX */
+      retVal = VX1000_OVL_SET_CONFIG(gVX1000.Ovl.ovlConfigValue, gVX1000.Ovl.ovlConfigMask, gVX1000.Ovl.ovlConfigValueB, gVX1000.Ovl.ovlConfigMaskB, page, gVX1000.Ovl.ovlBusMasterMask,  gVX1000.Ovl.ovlBusMasterMask);
+      VX1000_OVL_SET_CONFIG_DONE_STUP(retVal, page) /* the STUP version suppresses generation of a MX response */
+    }
+#elif defined(VX1000_OVLENBL_SYNC_PAGESWITCH)
+    retVal = VX1000_OVL_SET_CONFIG(gVX1000.Ovl.ovlConfigValue, gVX1000.Ovl.ovlConfigMask, gVX1000.Ovl.ovlConfigValueB, gVX1000.Ovl.ovlConfigMaskB, page, gVX1000.Ovl.ovlBusMasterMask,  gVX1000.Ovl.ovlBusMasterMask);
+    VX1000_OVL_SET_CONFIG_DONE_STUP(retVal, page)  /* the STUP version suppresses generation of a MX response */
+#else  /* !VX1000_OVLENBL_CORE_SYNC_PAGESW && !VX1000_OVLENBL_SYNC_PAGESWITCH */
+    if (page != gVX1000_ECU_CalPage)
+    { /* configuration changed */
+      if (page == VX1000_CALPAGE_RAM)
+      { /* RAM */
+        (void)VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_OVERLAY_SIZE, VX1000_OVERLAY_ADDR, VX1000_CALRAM_ADDR, VX1000_CALRAM_PHYSADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        gVX1000.ToolDetectState |= VX1000_TDS_WORKING_PAGE;
+      }
+      else
+      { /* Flash */
+        (void)VX1000_SUFFUN(vx1000_MapCalRam)(VX1000_OVERLAY_SIZE, VX1000_OVERLAY_ADDR, VX1000_OVERLAY_ADDR, VX1000_OVERLAY_PHYSADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        gVX1000.ToolDetectState &= (~VX1000_TDS_WORKING_PAGE);
+      }
+      gVX1000_ECU_CalPage = page;
+    }
+#endif /* !VX1000_OVLENBL_CORE_SYNC_PAGESW && !VX1000_OVLENBL_SYNC_PAGESWITCH */
+  }
+  else if ((mode & (VX1000_CAL_XCP)) != 0)
+  { /* switch only XCP view */
+    gVX1000_XCP_CalPage = page;
+  }
+#endif /* VX1000_OVERLAY_TLB | VX1000_OVERLAY_DESCR_IDX | VX1000_MPC56xCRAM_BASE_ADDR | VX1000_SH2_FCU_BASE_ADDR */
+#endif /* !VX1000_OVERLAY_VX_CONFIGURABLE */
+  else /* the empty else case is here only for MISRA */
+  {
+    VX1000_DUMMYREAD(onStartup) /* just to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  }
+
+  return retVal;
+}
+#endif /* VX1000_SET_CAL_PAGE_INTERNAL */
+
+
+#if defined(VX1000_COPY_CAL_PAGE_INTERNAL)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_CopyCalPage                                                                                          */
+/* API name:      VX1000_COPY_CAL_PAGE (internal) - may be overloaded by user                                                 */
+/* Return value:                                                                                                              */
+/* Parameter1:                                                                                                                */
+/* Parameter2:                                                                                                                */
+/* Parameter3:                                                                                                                */
+/* Parameter4:                                                                                                                */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   Copy the content of the reference page to the working page.                                                 */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_CopyCalPage)( VX1000_UINT8 srcSeg, VX1000_UINT8 srcPage, VX1000_UINT8 dstSeg, VX1000_UINT8 dstPage )
+{
+#if (defined(VX1000_OVERLAY_TLB) || defined(VX1000_OVERLAY_DESCR_IDX)) || (defined(VX1000_MPC56xCRAM_BASE_ADDR) || defined(VX1000_SH2_FCU_BASE_ADDR))
+  const VX1000_UINT32 overlaySize = (VX1000_UINT32)(VX1000_OVERLAY_SIZE); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  const VX1000_UINT32 overlayAddr = (VX1000_UINT32)(VX1000_OVERLAY_ADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  const VX1000_UINT32 calRamAddr  = (VX1000_UINT32)(VX1000_CALRAM_ADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  VX1000_UINT8 retVal = 0;
+  /* Check parameters */
+  /* Only copy from RAM to FLASH makes sense */
+  if ((srcSeg | dstSeg) != 0) { retVal = VX1000_CRC_SEGMENT_NOT_VALID; /* Segments are not supported */ }
+  else if (dstPage == srcPage) { retVal = VX1000_CRC_PAGE_NOT_VALID; /* Can not copy on itself */ }
+  else if (0==dstPage) { retVal = VX1000_CRC_ACCESS_DENIED; /* Can not copy to FLASH page  */ }
+  /* Initialise CALRAM */
+  /* Initialise CALRAM, copy from FLASH to RAM */
+  else
+  {
+    if (gVX1000_ECU_CalPage == (VX1000_CALPAGE_RAM))
+    {
+      /* To keep code generic, turn mapping temporarily off (even if not needed with e.g. VX1000_OVERLAY_DESCR_IDX which could use the shadow address range) */
+      VX1000_WRP_SET_CAL_PAGE_VOID(0, VX1000_CALPAGE_FLASH, VX1000_CAL_ECU, /* VX1000_COPY_CAL_PAGE is called by the mailbox, not at start-up: */0)
+    }
+    if ((((overlaySize | overlayAddr) | calRamAddr) & 0x3UL) != 0UL)
+    {
+      VX1000_UINT32 cnt;
+      volatile const VX1000_CHAR *pSrc = VX1000_ADDR_TO_PTR2VCC(overlayAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      volatile VX1000_CHAR *pDst = VX1000_ADDR_TO_PTR2VC(calRamAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      for (cnt = 0; cnt < overlaySize; cnt++)
+      {
+        pDst[cnt] = pSrc[cnt];
+      }
+    }
+    else
+    {
+      VX1000_UINT32 cnt;
+      volatile const VX1000_UINT32 *pSrc = VX1000_ADDR_TO_PTR2VCU32(overlayAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      volatile VX1000_UINT32 *pDst = VX1000_ADDR_TO_PTR2VU32(calRamAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      for (cnt = 0; cnt < (overlaySize >> 2U); cnt++)
+      {
+        pDst[cnt] = pSrc[cnt];
+      }
+    }
+    if (gVX1000_ECU_CalPage == (VX1000_CALPAGE_RAM))
+    {
+      VX1000_WRP_SET_CAL_PAGE_VOID(0, VX1000_CALPAGE_RAM, VX1000_CAL_ECU, /* VX1000_COPY_CAL_PAGE is called by the mailbox, not at start-up: */0)
+    }
+  }
+#else /* !VX1000_OVERLAY_TLB & !VX1000_OVERLAY_DESCR_IDX & !VX1000_MPC56xCRAM_BASE_ADDR & !VX1000_SH2_FCU_BASE_ADDR */
+  /* CopyCalPage has to be done by the VX in this mode (note: on TMS570 from a synchronised DPRAM because active reading is not supported, yet!) */
+  VX1000_UINT8 retVal = 1 /* TODO: use an appropriate error code define! */;
+  VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,srcSeg, dstSeg,srcPage,dstPage,0)) /* dummy accesses to prevent compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+#if defined(VX1000_TARGET_XC2000)
+  VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+#endif /* VX1000_TARGET_XC2000 */
+#endif /* !VX1000_OVERLAY_TLB & !VX1000_OVERLAY_DESCR_IDX & !VX1000_MPC56xCRAM_BASE_ADDR & !VX1000_SH2_FCU_BASE_ADDR */
+  return retVal;
+}
+#endif /* VX1000_COPY_CAL_PAGE_INTERNAL */
+
+
+#endif /* VX1000_MAILBOX_OVERLAY_CONTROL */
+
+
+#endif /* VX1000_OVERLAY && !VX1000_COMPILED_FOR_SLAVECORES */
+
+
+/*---------------------------------------------------------------------------- */
+/* Mailbox */
+#if defined(VX1000_MAILBOX) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+
+#define VX1000_MAILBOX_FLG_CLR                0
+#define VX1000_MAILBOX_FLG_SET                1
+
+#if defined(VX1000_MAILBOX_PROVIDE_SPLITREAD)
+static VX1000_UINT32 sFlgRdSplitPend;
+#endif /* VX1000_MAILBOX_PROVIDE_SPLITREAD */
+#if defined(VX1000_MAILBOX_PROVIDE_SPLITWRITE)
+static VX1000_UINT32 sFlgWrSplitPend;
+#endif /* VX1000_MAILBOX_PROVIDE_SPLITWRITE */
+
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MailboxInit                                                                                          */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:    This function must not be interrupted by any vx1000 mailbox function.                                       */
+/*                This function must not interrupt any vx1000 mailbox function.                                               */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_InitAsyncStart must have been called.                                                                */
+/* Description:   Initialise the Master->Slave and Slave->Master mailboxes.                                                   */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static void VX1000_SUFFUN(vx1000_MailboxInit)(void)
+{
+#if defined(VX1000_MAILBOX_PROVIDE_SPLITREAD)
+  sFlgRdSplitPend = VX1000_MAILBOX_FLG_CLR;
+#endif /* VX1000_MAILBOX_PROVIDE_SPLITREAD */
+#if defined(VX1000_MAILBOX_PROVIDE_SPLITWRITE)
+  sFlgWrSplitPend = VX1000_MAILBOX_FLG_CLR;
+#endif /* VX1000_MAILBOX_PROVIDE_SPLITWRITE */
+
+  gVX1000.Mailbox.Version = 0;
+  gVX1000.Mailbox.SlotSize = (VX1000_MAILBOX_SLOT_DWORDS) << 2;
+  gVX1000.Mailbox.MS_ReadIdx = 0;
+  gVX1000.Mailbox.MS_WriteIdx = 0;
+  gVX1000.Mailbox.SM_ReadIdx = 0;
+  gVX1000.Mailbox.SM_WriteIdx = 0;
+  gVX1000.Mailbox.RstReq = 0;
+  gVX1000.Mailbox.RstAck = 0;
+  gVX1000.Mailbox.MS_Slots = VX1000_MAILBOX_SLOTS;
+  gVX1000.Mailbox.SM_Slots = VX1000_MAILBOX_SLOTS;
+  gVX1000.Mailbox.MS_Ptr = VX1000_PTR2VU32_TO_ADDRESS(gVX1000.Mailbox.MSData); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  gVX1000.Mailbox.SM_Ptr = VX1000_PTR2VU32_TO_ADDRESS(gVX1000.Mailbox.SMData); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  if ( (VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.Mailbox.MS_Ptr)) != (0xCUL + VX1000_PTR2VM_TO_ADDRESS(&gVX1000.Mailbox)) ) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  {
+    gVX1000.ToolDetectState |= VX1000_TDS_ERROR;
+    VX1000_ERRLOGGER(VX1000_ERRLOG_STRUCTS_PADDED)
+  }
+  gVX1000.Mailbox.MagicId = (VX1000_UINT32)VX1000_MAILBOX_MAGIC;
+}
+
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MailboxWrite                                                                                         */
+/* API name:      VX1000_MAILBOX_WRITE (expression) / VX1000_MAILBOX_WRITE_VOID (statement)                                   */
+/* Wrapper API:   VX1000If_MailboxWrite (expression) / VX1000If_MailboxWriteVoid (statement)                                  */
+/* Return value:  Error code (0==OK)                                                                                          */
+/* Parameter1:    len: message size in bytes.                                                                                 */
+/* Parameter2:    pBuf: pointer to message data input.                                                                        */
+/*                The caller is responsible that the pointer is valid and that the source memory is accessible.               */
+/* Preemption:    This function must not be interrupted by any vx1000 mailbox write function.                                 */
+/*                This function must not interrupt any vx1000 mailbox write function.                                         */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_MailboxInit() must have been called.                                                                 */
+/* Description:   Write len bytes from pBuf to the Slave->Master mailbox and notify the master.                               */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT32 VX1000_SUFFUN(vx1000_MailboxWrite)(VX1000_UINT32 len, const VX1000_CHAR *pBuf)
+{
+  VX1000_UINT32 retVal = VX1000_MAILBOX_OK;
+
+  if (0U==(VX1000_MAILBOX_FREE_WR_SLOTS))
+  {
+    retVal = VX1000_MAILBOX_ERR_FULL;
+  }
+  else if (0==pBuf)
+  {
+    retVal = VX1000_MAILBOX_ERR_NULL;
+  }
+  else if ((len + 4) > ((VX1000_MAILBOX_SLOT_DWORDS) << 2))
+  {
+    retVal = VX1000_MAILBOX_ERR_SIZE;
+  }
+  else
+  {
+    VX1000_UINT32 cnt;
+    volatile VX1000_CHAR *pDst = VX1000_ADDR_TO_PTR2VC(VX1000_PTR2VU8_TO_ADDRESS(&gVX1000.Mailbox.SMData[gVX1000.Mailbox.SM_WriteIdx][1])); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    for (cnt = 0; cnt < len; cnt++)
+    {
+      pDst[cnt] = pBuf[cnt];
+    }
+    gVX1000.Mailbox.SMData[gVX1000.Mailbox.SM_WriteIdx][0] = len;
+    gVX1000.Mailbox.SM_WriteIdx = (VX1000_UINT8)VX1000_MAILBOX_NEXT(gVX1000.Mailbox.SM_WriteIdx);
+    VX1000_SPECIAL_EVENT(VX1000_EVENT_MAILBOX_UPDATE) /* note: EM00034754 did not mention to remove THIS one */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  }
+  return retVal;
+}
+
+
+#if defined(VX1000_MAILBOX_PROVIDE_SPLITWRITE)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MailboxWriteSplit                                                                                    */
+/* API name:      VX1000_MAILBOX_WRITESPLIT (expression) / VX1000_MAILBOX_WRITESPLIT_VOID (statement)                         */
+/* Wrapper API:   VX1000If_MailboxWriteSplit (expression) / VX1000If_MailboxWriteSplitVoid (statement)                        */
+/* Return value:  Error code (0==OK)                                                                                          */
+/*                Additional data returned via pointer                                                                        */
+/* Parameter1:    ppBuf (IN): pointer to a pointer variable.                                                                  */
+/*                ppBuf (*OUT): pointer to the data field of the next free Slave->Master mailbox.                             */
+/* Preemption:    This function must not be interrupted by any vx1000 mailbox write function.                                 */
+/*                This function must not interrupt any vx1000 mailbox write function.                                         */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_MailboxInit() must have been called.                                                                 */
+/* Description:   Just find out the location of the next unused message buffer and return the info to the caller.             */
+/*                Note: the mailbox state is not changed nor is the master notified (vx1000_MailboxWriteDone will do this).   */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT32 VX1000_SUFFUN(vx1000_MailboxWriteSplit)(VX1000_UINT32 * * ppBuf)
+{
+  VX1000_UINT32 retVal = VX1000_MAILBOX_OK;
+
+  if (0U==(VX1000_MAILBOX_FREE_WR_SLOTS))
+  {
+    retVal = VX1000_MAILBOX_ERR_FULL;
+  }
+  else if (0==ppBuf)
+  {
+    retVal = VX1000_MAILBOX_ERR_NULL;
+  }
+  else if (sFlgWrSplitPend != 0)
+  {
+    retVal = VX1000_MAILBOX_ERR_SPLIT_PEND;
+  }
+  else
+  {
+    sFlgWrSplitPend = VX1000_MAILBOX_FLG_SET;
+    ppBuf[0] = VX1000_ADDR_TO_PTR2U32(VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.Mailbox.SMData[gVX1000.Mailbox.SM_WriteIdx][1])); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  }
+  return retVal;
+}
+
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MailboxWriteDone                                                                                     */
+/* API name:      VX1000_MAILBOX_WRITEDONE (expression) / VX1000_MAILBOX_WRITEDONE_VOID (statement)                           */
+/* Wrapper API:   VX1000If_MailboxWriteDone (expression) / VX1000If_MailboxWriteDoneVoid (statement)                          */
+/* Return value:  error code (0==OK)                                                                                          */
+/* Parameter1:    len: the size of the entire message in bytes.                                                               */
+/* Preemption:    This function must not be interrupted by any vx1000 mailbox write function.                                 */
+/*                This function must not interrupt any vx1000 mailbox write function.                                         */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_MailboxWriteSplit() must have been called successfully.                                              */
+/* Description:   Finish a Slave->Master mailbox transfer that has been started with vx1000_MailboxWriteSplit().              */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT32 VX1000_SUFFUN(vx1000_MailboxWriteDone)(VX1000_UINT32 len)
+{
+  VX1000_UINT32 retVal = VX1000_MAILBOX_OK;
+
+  if (len > ((VX1000_MAILBOX_SLOT_DWORDS) << 2))
+  {
+    retVal = VX1000_MAILBOX_ERR_SIZE;
+  }
+  else if (0==sFlgWrSplitPend)
+  {
+    retVal = VX1000_MAILBOX_ERR_SPLIT_PEND;
+  }
+  else
+  {
+    sFlgWrSplitPend = VX1000_MAILBOX_FLG_CLR;
+    gVX1000.Mailbox.SMData[gVX1000.Mailbox.SM_WriteIdx][0] = len;
+    gVX1000.Mailbox.SM_WriteIdx = (VX1000_UINT8)VX1000_MAILBOX_NEXT(gVX1000.Mailbox.SM_WriteIdx);
+    VX1000_SPECIAL_EVENT(VX1000_EVENT_MAILBOX_UPDATE) /* note: EM00034754 did not mention to remove THIS one */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* macro expansion contains VX1000_ADDR_TO_PTR2XXX: cannot avoid violating MISRA rule 11.3 because in a few configurations a peripheral register at a fix HW address must be accessed via pointer to update the HW value */
+  }
+  return retVal;
+}
+#endif /* VX1000_MAILBOX_PROVIDE_SPLITWRITE */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MailboxRead                                                                                          */
+/* API name:      VX1000_MAILBOX_READ (expression) / VX1000_MAILBOX_READ_VOID (statement)                                     */
+/* Wrapper API:   VX1000If_MailboxRead (expression) / VX1000If_MailboxReadVoid (statement)                                    */
+/* Return value:  Error code (0==OK)                                                                                          */
+/*                Additional data returned via pointers                                                                       */
+/* Parameter1:    pLen (*IN): maximum allowed message size                                                                    */
+/*                pLen (*OUT): actual message size if successful                                                              */
+/* Parameter2:    pBuf (IN): destination for the next message                                                                 */
+/*                The caller is responsible that the destination contains at least *pLen writeable bytes.                     */
+/*                The function aborts with an error if the buffer is too small for the current message (no bytes copied).     */
+/*                pBuf (*OUT): a copy of the entire message if successful.                                                    */
+/* Preemption:    This function must not be interrupted by any vx1000 mailbox read function.                                  */
+/*                This function must not interrupt any vx1000 mailbox read function.                                          */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_MailboxInit() must have been called.                                                                 */
+/* Description:   Read the data from next filled Master->Slave mailbox slot into pBuf and return the number of bytes in pLen. */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT32 VX1000_SUFFUN(vx1000_MailboxRead)(VX1000_UINT32 * pLen, VX1000_CHAR * pBuf)
+{
+  VX1000_UINT32 len;
+  VX1000_UINT32 retVal = VX1000_MAILBOX_OK;
+
+  if (0==(VX1000_MAILBOX_USED_RD_SLOTS))
+  {
+    retVal = VX1000_MAILBOX_ERR_EMPTY;
+  }
+  else if ((0==pLen) || (0==pBuf))
+  {
+    retVal = VX1000_MAILBOX_ERR_NULL;
+  }
+  else
+  {
+    len = gVX1000.Mailbox.MSData[gVX1000.Mailbox.MS_ReadIdx][0];
+    if (len > *pLen)
+    {
+      retVal = VX1000_MAILBOX_ERR_SIZE;
+    }
+#if defined(VX1000_MAILBOX_PROVIDE_SPLITREAD)
+    else if (sFlgRdSplitPend != 0)
+    {
+      retVal = VX1000_MAILBOX_ERR_SPLIT_PEND;
+    }
+#endif /* VX1000_MAILBOX_PROVIDE_SPLITREAD */
+    else
+    {
+      VX1000_UINT32 cnt;
+      volatile const VX1000_CHAR *pSrc = VX1000_ADDR_TO_PTR2VCC(VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.Mailbox.MSData[gVX1000.Mailbox.MS_ReadIdx][1])); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      for (cnt = 0; cnt < len; cnt++)
+      {
+        pBuf[cnt] = pSrc[cnt];
+      }
+      *pLen = len;
+      gVX1000.Mailbox.MS_ReadIdx = (VX1000_UINT8)VX1000_MAILBOX_NEXT(gVX1000.Mailbox.MS_ReadIdx);
+      /* VX1000_SPECIAL_EVENT(VX1000_EVENT_MAILBOX_UPDATE) -- removed due to EM00034754 */
+    }
+  }
+  return retVal;
+}
+
+
+#if defined(VX1000_MAILBOX_PROVIDE_SPLITREAD)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MailboxReadSplit                                                                                     */
+/* API name:      VX1000_MAILBOX_READSPLIT (expression) / VX1000_MAILBOX_READSPLIT_VOID (statement)                           */
+/* Wrapper API:   VX1000If_MailboxReadSplit (expression) / VX1000If_MailboxReadSplitVoid (statement)                          */
+/* Return value:  Error code (0==OK)                                                                                          */
+/*                Additional data returned via pointers                                                                       */
+/* Parameter1:    pLen (IN): a pointer to a 32bit variable.                                                                   */
+/*                pLen (*OUT): the byte count of the next message.                                                            */
+/*                The caller is responsible that the pointer is valid and that the destination is writeable.                  */
+/* Parameter1:    ppBuf (IN): a pointer to a pointer variable.                                                                */
+/*                ppBuf (*OUT): pointer to the data field of the next unread message.                                         */
+/*                The caller is responsible that the pointer is valid and that the destination is writeable.                  */
+/* Preemption:    This function must not be interrupted by any vx1000 mailbox read function.                                  */
+/*                This function must not interrupt any vx1000 mailbox read function.                                          */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_MailboxInit() must have been called.                                                                 */
+/* Description:   Just find out location and length of the next unread message and return the info to the caller.             */
+/*                Note: the mailbox state is not changed nor is the master notified (vx1000_MailboxReadDone will do this).    */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT32 VX1000_SUFFUN(vx1000_MailboxReadSplit)(VX1000_UINT32 * pLen, VX1000_UINT32 * * ppBuf)
+{
+  VX1000_UINT32 retVal = VX1000_MAILBOX_OK;
+
+  if (0==(VX1000_MAILBOX_USED_RD_SLOTS))
+  {
+    retVal = VX1000_MAILBOX_ERR_EMPTY;
+  }
+  else if ((0==pLen) || (0==ppBuf))
+  {
+    retVal = VX1000_MAILBOX_ERR_NULL;
+  }
+  else if (sFlgRdSplitPend != 0)
+  {
+    retVal = VX1000_MAILBOX_ERR_SPLIT_PEND;
+  }
+  else
+  {
+    sFlgRdSplitPend = VX1000_MAILBOX_FLG_SET;
+    *pLen = gVX1000.Mailbox.MSData[gVX1000.Mailbox.MS_ReadIdx][0];
+    ppBuf[0] = VX1000_ADDR_TO_PTR2U32(VX1000_PTR2VU32_TO_ADDRESS(&gVX1000.Mailbox.MSData[gVX1000.Mailbox.MS_ReadIdx][1])); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  }
+  return retVal;
+}
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MailboxReadDone                                                                                      */
+/* API name:      VX1000_MAILBOX_READDONE (expression) / VX1000_MAILBOX_READDONE_VOID (statement)                             */
+/* Wrapper API:   VX1000If_MailboxReadDone (expression) / VX1000If_MailboxReadDoneVoid (statement)                            */
+/* Return value:  error code (0==OK)                                                                                          */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:    This function must not be interrupted by any vx1000 mailbox read function.                                  */
+/*                This function must not interrupt any vx1000 mailbox read function.                                          */
+/* Termination:                                                                                                               */
+/* Precondition1: mailboxReadSplit() must have been called successfully.                                                      */
+/* Description:   Mark the filled Master->Slave mailbox slot as empty and notify the master afterwards.                       */
+/* Devel state:   Tested                                                                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+VX1000_UINT32 VX1000_SUFFUN(vx1000_MailboxReadDone)(void)
+{
+  VX1000_UINT32 retVal = VX1000_MAILBOX_OK;
+
+  if (0==sFlgRdSplitPend)
+  {
+    retVal = VX1000_MAILBOX_ERR_SPLIT_PEND;
+  }
+  else
+  {
+    sFlgRdSplitPend = VX1000_MAILBOX_FLG_CLR;
+    gVX1000.Mailbox.MS_ReadIdx = (VX1000_UINT8)VX1000_MAILBOX_NEXT(gVX1000.Mailbox.MS_ReadIdx);
+    /* VX1000_SPECIAL_EVENT(VX1000_EVENT_MAILBOX_UPDATE) -- removed due to EM00034754 */
+  }
+  return retVal;
+}
+#endif /* VX1000_MAILBOX_PROVIDE_SPLITREAD */
+
+#define VX1000_CRM_CMD txBuf[0]
+#define VX1000_CRM_ERR txBuf[1]
+#define VX1000_CC_SET_MTA                      0xF6
+#define VX1000_CC_BUILD_CHECKSUM               0xF3
+
+/* XCP calibration memory handling */
+#if defined(VX1000_MAILBOX_CAL_READ_WRITE)
+
+/* XCP compliant protocol handler - though these defines are only visible inside this module, they still /
+/  may conflict with stuff coming in via VX1000_cfg.h sub-includes, so better add VX1000_-prefixes      */
+#define VX1000_CC_SHORT_DOWNLOAD               0xED
+#define VX1000_CC_SHORT_UPLOAD                 0xF4
+
+/* SHORT_DOWNLOAD */
+#define VX1000_CRO_SHORT_DOWNLOAD_LEN          8 /* + CRO_SHORT_DOWNLOAD_SIZE */
+#define VX1000_CRO_SHORT_DOWNLOAD_SIZE         rxBuf[(1)]
+#define VX1000_CRO_SHORT_DOWNLOAD_EXT          rxBuf[(3)]
+#define VX1000_CRO_SHORT_DOWNLOAD_ADDR         (*VX1000_ADDR_TO_PTR2U32(VX1000_PTR2C_TO_ADDRESS(&rxBuf[(4)])))
+#define VX1000_CRO_SHORT_DOWNLOAD_DATA         (&rxBuf[(8)])
+#define VX1000_CRM_SHORT_DOWNLOAD_LEN          1
+
+/* SHORT_UPLOAD */
+#define VX1000_CRO_SHORT_UPLOAD_LEN            8
+#define VX1000_CRO_SHORT_UPLOAD_SIZE           rxBuf[(1)]
+#define VX1000_CRO_SHORT_UPLOAD_EXT            rxBuf[(3)]
+#define VX1000_CRO_SHORT_UPLOAD_ADDR           (*VX1000_ADDR_TO_PTR2U32(VX1000_PTR2C_TO_ADDRESS(&rxBuf[(4)])))
+#define VX1000_CRM_SHORT_UPLOAD_DATA           (&txBuf[(1)])
+#define VX1000_CRM_SHORT_UPLOAD_LEN            1 /* + CRO_SHORT_UPLOAD_SIZE */
+
+#endif /* VX1000_MAILBOX_CAL_READ_WRITE */
+
+/* XCP calibration page handling */
+#if defined(VX1000_MAILBOX_OVERLAY_CONTROL)
+#if (defined(VX1000_OVERLAY)) && (defined(VX1000_OVERLAY_VX_CONFIGURABLE)) && (defined(VX1000_OVLENBL_REGWRITE_VIA_MX))
+#define VX1000_CC_USRCMD                       0xF1
+#define VX1000_CC_USC_WOVLCFG                  0x91
+#define VX1000_CC_USC_WOVLCFG_DESCR            0x0
+#define VX1000_CC_USC_WOVLCFG_OSELOVCCON       0x1
+#define VX1000_CC_USC_WOVLCFG_OVCCON           0x2
+#define VX1000_CC_USC_WOVLCFG_MAX              0x2
+
+#define VX1000_CRO_SUB_CMD                     rxBuf[1]
+#define VX1000_CRO_USC_WOVLCFG_MODE            rxBuf[2]
+#define VX1000_CRO_USC_WOVLCFG_DESCRIDX        rxBuf[3]
+#define VX1000_CRO_USC_WOVLCFG_OVCCON          rxBuf[4]
+
+#define VX1000_CRM_USRCMD_LEN                  1
+#endif /* VX1000_OVERLAY & VX1000_OVERLAY_VX_CONFIGURABLE & VX1000_OVLENBL_REGWRITE_VIA_MX */
+
+#define VX1000_CC_SET_CAL_PAGE                 0xEB
+#define VX1000_CC_GET_CAL_PAGE                 0xEA
+#define VX1000_CC_COPY_CAL_PAGE                0xE4
+
+/* SET_CAL_PAGE */
+#define VX1000_CRO_SET_CALPAGE_LEN             4
+#define VX1000_CRO_SET_CALPAGE_MODE            rxBuf[(1)]
+#define VX1000_CRO_SET_CALPAGE_SEG             rxBuf[(2)]
+#define VX1000_CRO_SET_CALPAGE_PAGE            rxBuf[(3)]
+#define VX1000_CRM_SET_CALPAGE_LEN             1
+
+/* GET_CAL_PAGE */
+#define VX1000_CRO_GET_CALPAGE_LEN             3
+#define VX1000_CRO_GET_CALPAGE_MODE            rxBuf[(1)]
+#define VX1000_CRO_GET_CALPAGE_SEG             rxBuf[(2)]
+#define VX1000_CRM_GET_CALPAGE_LEN             4
+#define VX1000_CRM_GET_CALPAGE_PAGE            txBuf[(3)]
+
+/* COPY_CAL_PAGE */
+#define VX1000_CRO_CPY_CALPAGE_LEN             5
+#define VX1000_CRO_CPY_CALPAGE_SRCSEG          rxBuf[(1)]
+#define VX1000_CRO_CPY_CALPAGE_SRCPAGE         rxBuf[(2)]
+#define VX1000_CRO_CPY_CALPAGE_DSTSEG          rxBuf[(3)]
+#define VX1000_CRO_CPY_CALPAGE_DSTPAGE         rxBuf[(4)]
+#define VX1000_CRM_COPY_CAL_PAGE_LEN           1
+#endif /* VX1000_MAILBOX_OVERLAY_CONTROL */
+
+/* flash programming via mailbox */
+#if defined(VX1000_MAILBOX_FLASH)
+
+/* Commands: */
+#define VX1000_CC_PROGRAM_START                0xD2
+#define VX1000_CC_PROGRAM_CLEAR                0xD1
+#define VX1000_CC_PROGRAM                      0xD0
+#define VX1000_CC_PROGRAM_RESET                0xCF
+#define VX1000_CC_GET_PGM_PROCESSORINFO        0xCE
+#define VX1000_CC_GET_SECTOR_INFO              0xCD
+#define VX1000_CC_PROGRAM_PREPARE              0xCC
+#define VX1000_CC_PROGRAM_NEXT                 0xCA
+#define VX1000_CC_PROGRAM_MAX                  0xC9
+#define VX1000_CC_PROGRAM_VERIFY               0xC8
+
+/* Data for: */
+/* - PROGRAM_PREPARE */
+#define VX1000_CRO_PGM_PREPARE_LEN             4
+#define VX1000_CRO_PGM_PREPARE_SIZE            (*VX1000_ADDR_TO_PTR2U16(VX1000_PTR2C_TO_ADDRESS(&rxBuf[(2)])))
+#define VX1000_CRM_PGM_PREPARE_LEN             1
+
+/* - PROGRAM_START */
+#define VX1000_CRO_PGM_START_LEN               1
+#define VX1000_CRM_PROGRAM_START_LEN           7
+#define VX1000_CRM_PGM_COMM_MODE_PGM           txBuf[(2)]
+#define VX1000_CRM_PGM_MAX_CTO_PGM             txBuf[(3)]
+#define VX1000_CRM_PGM_MAX_BS_PGM              txBuf[(4)]
+#define VX1000_CRM_PGM_MIN_ST_PGM              txBuf[(5)]
+#define VX1000_CRM_PGM_QUEUE_SIZE_PGM          txBuf[(6)]
+
+/* - PROGRAM_CLEAR */
+#define VX1000_CRO_PGM_CLEAR_LEN               8
+#define VX1000_CRO_PGM_CLEAR_MODE              rxBuf[(1)]
+#define VX1000_CRO_PGM_CLEAR_SIZE              (*VX1000_ADDR_TO_PTR2U32(VX1000_PTR2C_TO_ADDRESS(&rxBuf[(4)])))
+#define VX1000_CRM_PGM_CLEAR_LEN               1
+
+/* - PROGRAM */
+#define VX1000_CRO_PGM_MAX_SIZE                ((VX1000_UINT8)((VX1000_MAILBOX_SLOT_DWORDS) << 2) - ...)
+#define VX1000_CRO_PGM_LEN                     2 /* + CRO_PROGRAM_SIZE */
+#define VX1000_CRO_PGM_SIZE                    rxBuf[(1)]
+#define VX1000_CRO_PGM_DATA                    (&rxBuf[(2)])
+#define VX1000_CRM_PGM_LEN                     1
+
+#endif /* VX1000_MAILBOX_FLASH */
+
+#if ((defined(VX1000_OVERLAY)) && (defined(VX1000_OVERLAY_VX_CONFIGURABLE))) && ((defined(VX1000_OVLENBL_REGWRITE_VIA_MX)) && (defined(VX1000_MAILBOX_OVERLAY_CONTROL)))
+
+#if defined(VX1000_TARGET_TRICORE)
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OvlWritEcuDescrMxHandler                                                                             */
+/* API name:      None                                                                                                        */
+/* Return value:  status:                                                                                                     */
+/*                0: cmd are handled correctly                                                                                */
+/*                1: nothing is done                                                                                          */
+/* Parameter1:    subCmdCode E [0, VX1000_CC_USC_WOVLCFG_MAX]                                                                 */
+/* Parameter2:    overlay descriptor index E [0, OVERLAY_DESCRIPTORS)                                                         */
+/* Parameter3:    additional data of cmdMode                                                                                  */
+/* Parameter4:                                                                                                                */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   This function writes ECU overlay registers according to values written by VX.                               */
+/*                This function is called by vx1000_MailboxHandler() when subCmd of usrCmd is VX1000_CC_USC_WOVLCFG.          */
+/* Devel state:   Specified (only support TC27x, TC29x currently)                                                             */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_OvlWritEcuDescrMxHandler)(VX1000_UINT8 cmdMode, VX1000_UINT8 ovlIdx, VX1000_UINT32 ovccon)
+{
+  VX1000_UINT8 retVal = 0, sfrModel = 0U, overlayDescriptors = 0;
+
+  switch ((VX1000_MCREG_CBS_JTAGID) & (VX1000_JTAGID_PN_MASK)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  {
+    case VX1000_JTAGID_PN_TC172x:       overlayDescriptors = 16U; sfrModel = 0U; break; /* FutureMax : not sure about the sfrModel */
+    case VX1000_JTAGID_PN_TC1387:       overlayDescriptors = 16U; sfrModel = 0U; break; /* AudoS */
+    case VX1000_JTAGID_PN_TC178x:       overlayDescriptors = 16U; sfrModel = 0U; break; /* AudoMax */
+    case VX1000_JTAGID_PN_TC1767:       overlayDescriptors = 16U; sfrModel = 0U; break; /* AudoFuture */
+    case VX1000_JTAGID_PN_TC1797:       overlayDescriptors = 16U; sfrModel = 0U; break; /* AudoFuture */
+    case VX1000_JTAGID_PN_TC1798:       overlayDescriptors = 16U; sfrModel = 1U; break; /* AudoMax */
+    case VX1000_JTAGID_PN_TC21x:        overlayDescriptors =  8U; sfrModel = 2U; break; /* just a guess: "Aurix single core with 8 descriptors" */
+    case VX1000_JTAGID_PN_TC22x:        overlayDescriptors =  8U; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC23x:        overlayDescriptors =  8U; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC24x:        overlayDescriptors = 32U; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC26x:        overlayDescriptors = 32U; sfrModel = 3U; break; /* Aurix dual core */
+    case VX1000_JTAGID_PN_TC27xTC2Dx:   overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC29x:        overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    /*
+    TODOKNM: case VX1000_JTAGID_PN_TC32x:        overlayDescriptors = 32U; sfrModel = ?U; break;
+    */
+    case VX1000_JTAGID_PN_TC33x:        overlayDescriptors = 32U; sfrModel = 2U; break; /* Aurix single core */
+    case VX1000_JTAGID_PN_TC33xED:      overlayDescriptors = 32U; sfrModel = 3U; break; /* Aurix dual core */
+    case VX1000_JTAGID_PN_TC35x:        overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC36x:        overlayDescriptors = 32U; sfrModel = 3U; break; /* Aurix dual core */
+    case VX1000_JTAGID_PN_TC37x:        overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC37xED:      overlayDescriptors = 32U; sfrModel = 4U; break; /* Aurix triple core */
+    case VX1000_JTAGID_PN_TC38x:        overlayDescriptors = 32U; sfrModel = 5U; break; /* Aurix quad core */
+    case VX1000_JTAGID_PN_TC39x:        overlayDescriptors = 32U; sfrModel = 7U; break; /* Aurix hexa core */
+    default: break;
+  }
+  if ((ovlIdx >= (overlayDescriptors)) || (cmdMode > (VX1000_CC_USC_WOVLCFG_MAX)))
+  {
+    retVal = 1;
+  }
+  else
+  {
+    if ((sfrModel == 4U)  /* three cores of type Aurix */
+    ||  (sfrModel == 7U)) /* six cores of type AurixPlus */
+    {
+      VX1000_UINT8 i = ovlIdx;
+      switch ((VX1000_UINT8)cmdMode)
+      {
+        case VX1000_CC_USC_WOVLCFG_DESCR:
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( i, 0UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].RABR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( i, 0UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].OTAR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(i, 0UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].OMASK); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( i, 1UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].RABR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( i, 1UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].OTAR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(i, 1UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].OMASK); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( i, 2UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].RABR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( i, 2UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].OTAR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(i, 2UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].OMASK); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          if (sfrModel == 7U)
+          {
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( i, 3UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].RABR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( i, 3UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].OTAR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(i, 3UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].OMASK); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( i, 4UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].RABR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( i, 4UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].OTAR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(i, 4UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].OMASK); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            /* Note that there is one gap in the OVC core indices (CPU5 continues with index 6) */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_RABR_AURIX( i, 6UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].RABR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OTAR_AURIX( i, 6UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].OTAR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            (VX1000_ADDR_TO_PTR2VU32(VX1000_MCREGADDR_OMASK_AURIX(i, 6UL)))[0] = ((VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->DESCR)[i].OMASK); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          break;
+        case VX1000_CC_USC_WOVLCFG_OSELOVCCON:
+          VX1000_MCREG_OVC0_OSEL = (VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->OSEL); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          VX1000_MCREG_OVC1_OSEL = (VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->OSEL); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          VX1000_MCREG_OVC2_OSEL = (VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->OSEL); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          if (sfrModel == 7U)
+          {
+            VX1000_MCREG_OVC3_OSEL = (VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->OSEL); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            VX1000_MCREG_OVC4_OSEL = (VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->OSEL); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+            VX1000_MCREG_OVC5_OSEL = (VX1000_ADDR_TO_PTR2OCR(gVX1000.Ovl.ovlConfigRegsPtr)->OSEL); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          }
+          VX1000_MCREG_SCU_OVCCON = ovccon; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          break;
+        case VX1000_CC_USC_WOVLCFG_OVCCON:
+          VX1000_MCREG_SCU_OVCCON = ovccon; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+          break;
+        default:
+          retVal = 1;
+          break;
+      }
+    }
+    else
+    {
+      VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+      retVal = 1;
+    }
+  }
+  return retVal;
+}
+
+#else  /* !VX1000_TARGET_TRICORE */
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_OvlWritEcuDescrMxHandler                                                                             */
+/* API name:      None                                                                                                        */
+/* Return value:  status:                                                                                                     */
+/*                0: cmd are handled correctly                                                                                */
+/*                1: nothing is done                                                                                          */
+/* Parameter1:    subCmdCode E [0, VX1000_CC_USC_WOVLCFG_MAX]                                                                 */
+/* Parameter2:    overlay descriptor index E [0, OVERLAY_DESCRIPTORS)                                                         */
+/* Parameter3:    additional data of cmdMode                                                                                  */
+/* Parameter4:                                                                                                                */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1:                                                                                                             */
+/* Description:   This function writes ECU overlay registers according to values written by VX.                               */
+/*                This function is called by vx1000_MailboxHandler() when subCmd of usrCmd is VX1000_CC_USC_WOVLCFG.          */
+/* Devel state:   Idea                                                                                                        */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static VX1000_UINT8 VX1000_SUFFUN(vx1000_OvlWritEcuDescrMxHandler)(VX1000_UINT8 cmdMode, VX1000_UINT8 ovlIdx, VX1000_UINT32 xxx)
+{
+  VX1000_UINT8 retVal = 1;
+  VX1000_ERRLOGGER(VX1000_ERRLOG_OVL_UNIMPL)
+  VX1000_DUMMYREAD(VX1000_DISCARD4DUMMYARGS(VX1000_UINT8,cmdMode, ovlIdx,xxx,0,0)) /* interims dummy access */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+  return retVal;
+}
+
+#endif /* !VX1000_TARGET_TRICORE */
+
+#endif /* VX1000_OVERLAY && VX1000_OVERLAY_VX_CONFIGURABLE && VX1000_OVLENBL_REGWRITE_VIA_MX && VX1000_MAILBOX_OVERLAY_CONTROL */
+
+#if (defined(VX1000_MAILBOX_OVERLAY_CONTROL) || defined(VX1000_MAILBOX_FLASH)) || defined(VX1000_MAILBOX_CAL_READ_WRITE)
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MailboxHandler                                                                                       */
+/* API name:      VX1000_MAILBOX_CONTROL                                                                                      */
+/* Wrapper API:   VX1000If_MailboxControl                                                                                     */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:    This function must not be interrupted by any vx1000 mailbox function.                                       */
+/*                This function must not interrupt any vx1000 mailbox function.                                               */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_MailboxInit() must have been called.                                                                 */
+/* Description:   check the vx1000 mailbox system for pending requests and trigger the necessary reactions.                   */
+/* Devel state:   Implemented (todo: use byte-wise little-endian import)                                                      */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+void VX1000_SUFFUN(vx1000_MailboxHandler)(void)
+{
+#if defined(VX1000_MAILBOX_CAL_READ_WRITE)
+  /* note: this unused feature is not fully implemented because it needs buffer sizes of 256 and rxLen of 252 */
+#endif /* !VX1000_MAILBOX_CAL_READ_WRITE */
+  VX1000_UINT32 txLen, rxLen = 8;
+  VX1000_CHAR rxBuf[12], txBuf[12];
+  VX1000_UINT8 postponeAnswer = 0;
+  static volatile VX1000_UINT32 gVX1000_MX_mta; /* in this version made it local to this function because only accessed from here. g-prefix not removed though to keep changes minimal. */
+
+  if ((VX1000_MAILBOX_OK) == vx1000_MailboxRead(&rxLen, &rxBuf[0]))
+  {
+    txLen = 2;
+    VX1000_CRM_CMD = (VX1000_CHAR)-1;
+    VX1000_CRM_ERR = 0x00;
+    switch ((VX1000_UINT8)rxBuf[0]) /* check CRO_CMD */
+    {
+    case (VX1000_UINT8)(VX1000_CC_SET_MTA):
+      /* VX1000_CRM_ERR is already initialised */
+      gVX1000_MX_mta = ((((VX1000_UINT32)rxBuf[(4 + 0)]) | ((VX1000_UINT32)rxBuf[(4 + 1)] << 8)) | (((VX1000_UINT32)rxBuf[(4 + 2)] << 16) | ((VX1000_UINT32)rxBuf[(4 + 3)] << 24)));
+      VX1000_DUMMYREAD(gVX1000_MX_mta) /* just to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+      txLen = 1;
+      break;
+#if defined(VX1000_MAILBOX_CAL_READ_WRITE)
+    case (VX1000_UINT8)(VX1000_CC_SHORT_UPLOAD):
+#if defined(VX1000_SHORT_UPLOAD)
+      VX1000_CRM_ERR = (VX1000_CHAR)(VX1000_SHORT_UPLOAD((VX1000_CRM_SHORT_UPLOAD_DATA), (VX1000_CRO_SHORT_UPLOAD_ADDR), (VX1000_CRO_SHORT_UPLOAD_SIZE))); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else /* !VX1000_SHORT_UPLOAD */
+      {
+        VX1000_UINT32 j;
+        volatile VX1000_UINT8 *dst = VX1000_ADDR_TO_PTR2VU8(VX1000_PTR2C_TO_ADDRESS(VX1000_CRM_SHORT_UPLOAD_DATA)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        volatile VX1000_UINT8 *src = VX1000_ADDR_TO_PTR2VU8(VX1000_CRO_SHORT_UPLOAD_ADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        for (j = 0; j < (VX1000_UINT32)(VX1000_CRO_SHORT_UPLOAD_SIZE); ++j) { dst[j] = src[j]; }
+      }
+#endif /* !VX1000_SHORT_UPLOAD */
+      txLen = (VX1000_UINT32)(VX1000_CRM_SHORT_UPLOAD_LEN)+(VX1000_UINT32)(VX1000_CRO_SHORT_UPLOAD_SIZE);
+      break;
+    case (VX1000_UINT8)(VX1000_CC_SHORT_DOWNLOAD):
+#if defined(VX1000_SHORT_DOWNLOAD)
+      VX1000_CRM_ERR = (VX1000_CHAR)(VX1000_SHORT_DOWNLOAD((VX1000_CRO_SHORT_DOWNLOAD_ADDR), (VX1000_CRO_SHORT_DOWNLOAD_DATA), (VX1000_CRO_SHORT_DOWNLOAD_SIZE))); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+#else /* !VX1000_SHORT_DOWNLOAD */
+      {
+        VX1000_UINT32 j;
+        volatile VX1000_UINT8 *dst = VX1000_ADDR_TO_PTR2VU8(VX1000_CRO_SHORT_DOWNLOAD_ADDR); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        volatile VX1000_UINT8 *src = VX1000_ADDR_TO_PTR2VU8(VX1000_PTR2C_TO_ADDRESS(VX1000_CRO_SHORT_DOWNLOAD_DATA)); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        for (j = 0; j < (VX1000_UINT32)(VX1000_CRO_SHORT_DOWNLOAD_SIZE); ++j) { dst[j] = src[j]; }
+      }
+#endif /* !VX1000_SHORT_DOWNLOAD */
+      txLen = VX1000_CRM_SHORT_DOWNLOAD_LEN;
+      break;
+#endif /* VX1000_MAILBOX_CAL_READ_WRITE */
+#if defined(VX1000_MAILBOX_OVERLAY_CONTROL)
+    case (VX1000_UINT8)(VX1000_CC_GET_CAL_PAGE):
+      VX1000_CRM_GET_CALPAGE_PAGE = (VX1000_CHAR)(VX1000_GET_CAL_PAGE((VX1000_CRO_GET_CALPAGE_SEG), (VX1000_CRO_GET_CALPAGE_MODE)));
+      txLen = VX1000_CRM_GET_CALPAGE_LEN;
+      break;
+    case (VX1000_UINT8)(VX1000_CC_SET_CAL_PAGE):
+      VX1000_CRM_ERR = (VX1000_CHAR)(VX1000_WRP_SET_CAL_PAGE((VX1000_CRO_SET_CALPAGE_SEG), (VX1000_CRO_SET_CALPAGE_PAGE), (VX1000_CRO_SET_CALPAGE_MODE),0));
+      if (VX1000_CRM_ERR == (VX1000_CHAR)(VX1000_CRC_CMD_BUSY))
+      {
+        postponeAnswer = 1; /* Asynchronous call. Mailbox answer will be sent in the callback done macro.*/
+      }
+      txLen = VX1000_CRM_SET_CALPAGE_LEN;
+      break;
+#if !defined(VX1000_OVERLAY_VX_CONFIGURABLE)
+    case (VX1000_UINT8)(VX1000_CC_COPY_CAL_PAGE):
+      VX1000_CRM_ERR = (VX1000_CHAR)(VX1000_COPY_CAL_PAGE((VX1000_CRO_CPY_CALPAGE_SRCSEG), (VX1000_CRO_CPY_CALPAGE_SRCPAGE),
+                                                     (VX1000_CRO_CPY_CALPAGE_DSTSEG), (VX1000_CRO_CPY_CALPAGE_DSTPAGE)));
+      txLen = VX1000_CRM_COPY_CAL_PAGE_LEN;
+      break;
+#endif /* !VX1000_OVERLAY_VX_CONFIGURABLE */
+#if (defined(VX1000_OVERLAY)) && (defined(VX1000_OVERLAY_VX_CONFIGURABLE)) && (defined(VX1000_OVLENBL_REGWRITE_VIA_MX))
+    case (VX1000_UINT8)(VX1000_CC_USRCMD):
+      if( (VX1000_UINT8)(rxBuf[1]) == VX1000_CC_USC_WOVLCFG)
+      {
+        VX1000_CRM_ERR = (VX1000_CHAR)(VX1000_SUFFUN(vx1000_OvlWritEcuDescrMxHandler)((VX1000_CRO_USC_WOVLCFG_MODE), (VX1000_CRO_USC_WOVLCFG_DESCRIDX), *(VX1000_ADDR_TO_PTR2U32(VX1000_PTR2C_TO_ADDRESS(&(VX1000_CRO_USC_WOVLCFG_OVCCON)))))); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        txLen = VX1000_CRM_USRCMD_LEN;
+      }
+      else
+      {
+        VX1000_CRM_ERR = VX1000_CRC_CMD_UNKNOWN;
+      }
+      break;
+#endif /* VX1000_OVERLAY & VX1000_OVERLAY_VX_CONFIGURABLE & VX1000_OVLENBL_REGWRITE_VIA_MX & VX1000_MAILBOX */
+#endif /* VX1000_MAILBOX_OVERLAY_CONTROL */
+#if defined(VX1000_MAILBOX_FLASH)
+    case (VX1000_UINT8)(VX1000_CC_PROGRAM_PREPARE):
+      /* The user callback has to cease normal ECU operation and return OK if this succeeded  */
+      /* AND the FKL memory (from param1 to param2) does not interfere with current RAM usage */
+      VX1000_CRM_ERR = (VX1000_CHAR)(VX1000_PROGRAM_PREPARE( gVX1000_MX_mta, (VX1000_UINT32)(VX1000_CRO_PGM_PREPARE_SIZE) )); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      txLen = VX1000_CRM_PGM_PREPARE_LEN;
+      break;
+#if 0 /* disabled the code, while the illegal "#if 0" reminds us in every release that we have to fully specify and implemnt this */
+//    case (VX1000_UINT8)(VX1000_CC_PROGRAM_START):
+//      VX1000_CRM_PGM_COMM_MODE_PGM = 0;
+//      VX1000_CRM_PGM_MAX_CTO_PGM = 8;
+//      VX1000_CRM_PGM_MAX_BS_PGM = 1;
+//      VX1000_CRM_PGM_MIN_ST_PGM = 0;
+//      VX1000_CRM_PGM_QUEUE_SIZE_PGM = 1;
+//      txLen = VX1000_CRM_PGM_START_LEN;
+//      /* @@@@ Problem: how to actually program flash? */
+//      break;
+#endif /* 0 */
+#endif /* VX1000_MAILBOX_FLASH */
+    default:
+      VX1000_CRM_ERR = VX1000_CRC_CMD_UNKNOWN;
+      break;
+    }
+    if (0==postponeAnswer)
+    {
+      if ((VX1000_CRM_ERR) != 0)
+      {
+        VX1000_CRM_CMD = (VX1000_CHAR)-2;
+        txLen = 2;
+      }
+      (void)VX1000_SUFFUN(vx1000_MailboxWrite)(txLen, txBuf);
+    }
+  }
+}
+#endif /* VX1000_MAILBOX_OVERLAY_CONTROL || VX1000_MAILBOX_FLASH || VX1000_MAILBOX_CAL_READ_WRITE */
+
+#if defined(VX1000_MAILBOX_PRINTF)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MailboxPutchar                                                                                       */
+/* API name:      None                                                                                                        */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    a character to be transmitted                                                                               */
+/*                No invalid input possible.                                                                                  */
+/* Preemption:    This function must not be interrupted by any vx1000 mailbox write function.                                 */
+/*                This function must not interrupt any vx1000 mailbox write function.                                         */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_MailboxInit() must have been called.                                                                 */
+/* Description:   Output a single character to vx1000 mailbox system.                                                         */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+static void VX1000_SUFFUN(vx1000_MailboxPutchar)( VX1000_CHAR character )
+{
+  static VX1000_CHAR vx1000EvBuf[(VX1000_MAILBOX_SLOT_DWORDS) << 2]; /* note: instead of this local buffer, we _could_ use the writeSplit feature, but _then_ the user would have to disable context switches during prints! */
+  static VX1000_UINT32 vx1000EvLen;
+
+  if ((vx1000EvBuf[0] != (VX1000_CHAR)-4) || (vx1000EvBuf[1] != (VX1000_CHAR)1) || (vx1000EvLen >= ((VX1000_MAILBOX_SLOT_DWORDS) << 2)))
+  {
+    /* Initialise the protocol header once */
+    vx1000EvBuf[0] = (VX1000_CHAR)-4; /* SERV */
+    vx1000EvBuf[1] = (VX1000_CHAR)1;  /* SERV_TEXT */
+    vx1000EvLen = 2;
+  }
+  vx1000EvBuf[vx1000EvLen] = character;
+  vx1000EvLen++;
+  if ( ((vx1000EvLen + 4) >= ((VX1000_MAILBOX_SLOT_DWORDS) << 2)) || (0==character) )
+  {
+    (void)VX1000_SUFFUN(vx1000_MailboxWrite)(vx1000EvLen, vx1000EvBuf);
+    vx1000EvLen = 2;
+  }
+}
+
+#if !defined(VX1000_PRINTF_MINIMAL)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MailboxPrintf                                                                                        */
+/* API name:      VX1000_PRINTF                                                                                               */
+/* Wrapper API:   VX1000If_PrintF                                                                                             */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    pointer to ASCIIZ string in stdio-printf format (token support according to linked compiler library)        */
+/*                Validity has to be ensured by the caller; bad input may lead to crash!                                      */
+/* Parameter2+:   variadic list of additional printf input.                                                                   */
+/*                Validity has to be ensured by the caller; bad input may lead to crash!                                      */
+/* Preemption:    This function must not be interrupted by any vx1000 mailbox write function.                                 */
+/*                This function must not interrupt any vx1000 mailbox write function.                                         */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_MailboxInit() must have been called.                                                                 */
+/* Description:   Full version of classic printf() with output redirected to vx1000 mailbox system.                           */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* The full printf library function not only occupies two dozens of Kbytes TEXT but also allocates */
+/* a rather huge amount of stack upon calls so it is not well suited for multitasking environments */
+void VX1000_SUFFUN(vx1000_MailboxPrintf)( const VX1000_CHAR *format, ... ) /* PRQA S 5069 */ /* Cannot avoid violating MISRA rule 16.1 because a C++-based workaround would only violate other rules */
+{
+  va_list argptr;
+  VX1000_CHAR buf[256];
+
+  va_start(argptr, format);
+  (void)vsprintf((VX1000_CHAR *)buf, format, argptr);
+  va_end(argptr); /* PRQA S 3199 */ /* it depends on the used compiler whether this statement has useful side effects or not */
+
+  /* Transmit the text message */
+  {
+    VX1000_CHAR *p = buf;
+    while (p[0] != 0)
+    {
+      VX1000_SUFFUN(vx1000_MailboxPutchar)(p[0]);
+      p = &p[1];
+    }
+  }
+
+  /* Transmit the terminating 0x00. */
+  VX1000_SUFFUN(vx1000_MailboxPutchar)( 0x00 );
+}
+#else /* VX1000_PRINTF_MINIMAL */
+/* This reduced printf implementation does not support features like float support or argument */
+/* repetition, but it usually uses less TEXT and RAM usage is only a few bytes at runtime.     */
+
+#define VX1000_PFM_NONE                0U
+#define VX1000_PFM_IN_TOKEN            1U
+#define VX1000_PFM_IN_WIDTH            2U
+#define VX1000_PFM_AFTER_WIDTH         4U
+#define VX1000_PFM_IN_PREC             8U
+#define VX1000_PFM_AFTER_PREC          16U
+#define VX1000_PFM_IN_SIZE             32U
+#define VX1000_PFM_AFTER_SIZE          64U
+#define VX1000_PFM_INVALID             128U
+
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_MailboxPrintf                                                                                        */
+/* API name:      VX1000_PRINTF                                                                                               */
+/* Wrapper API:   VX1000If_PrintF                                                                                             */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    pointer to ASCIIZ string in stdio-printf format (not all tokens supported!)                                 */
+/*                Validity has to be ensured by the caller; bad input may lead to crash!                                      */
+/* Parameter2+:   variadic list of additional printf input.                                                                   */
+/*                Validity has to be ensured by the caller; bad input may lead to crash!                                      */
+/* Preemption:    This function must not be interrupted by any vx1000 mailbox write function.                                 */
+/*                This function must not interrupt any vx1000 mailbox write function.                                         */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_MailboxInit() must have been called.                                                                 */
+/* Description:   Minimal version of classic printf() with output redirected to vx1000 mailbox system.                        */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+void VX1000_SUFFUN(vx1000_MailboxPrintf)( const VX1000_CHAR *format, ... ) /* PRQA S 5069 */ /* Cannot avoid violating MISRA rule 16.1 because a C++-based workaround would only violate other rules */
+{
+  va_list arglist;
+  VX1000_LONG number;
+  VX1000_LDOUBL fdummy = 0.0;          /* some compilers require a suffix here to avoid warnings but others would not understand the suffix, so no suffix here */
+  VX1000_CHAR *p, *p2, numbuf[24], frmchr, digif=0, filler=0, alignleft=0, showpos=0, showbase=0, signedtype=0, floattype=0;
+  VX1000_INT   i, width=0, prec=0, bsize=0, basesize=0;
+  VX1000_UINT8 state, continuer = 1;
+
+  va_start(arglist, format);
+  state = (VX1000_PFM_NONE);
+  for (; (format[0] != 0) && (continuer != 0); format = &format[1])
+  {
+    continuer = 0;
+    frmchr = format[0];
+    if (state == (VX1000_PFM_NONE))
+    {
+      if (frmchr == \'%\')
+      {
+        state = (VX1000_PFM_IN_TOKEN);
+        width = prec = bsize = basesize = 0;
+        floattype = signedtype = 0;
+        filler = showpos = \' \';
+      }
+      else
+      {
+        VX1000_SUFFUN(vx1000_MailboxPutchar)(frmchr);
+      }
+      continuer = 1;
+    }
+    if ((0==continuer) && (frmchr == \'%\'))
+    {
+      if (state == (VX1000_PFM_IN_TOKEN)) /* no real token, just an escaped "%" */
+      {
+        state = (VX1000_PFM_NONE);
+        VX1000_SUFFUN(vx1000_MailboxPutchar)(frmchr);
+      }
+      else
+      {
+        state |= (VX1000_PFM_INVALID);
+      }
+      continuer = 1;
+    }
+    if ((0==continuer) && ((frmchr >= \'0\') && (frmchr <= \'9\')))
+    {
+      frmchr -= \'0\';
+      switch (state & ((VX1000_PFM_IN_WIDTH) | (VX1000_PFM_IN_PREC) | (VX1000_PFM_IN_SIZE))) /* continue in a number */
+      {
+        case (VX1000_PFM_IN_WIDTH): width = (10 * width) + (VX1000_INT)frmchr; continuer = 1; break;
+        case (VX1000_PFM_IN_PREC):  prec  = (10 * prec ) + (VX1000_INT)frmchr; VX1000_DUMMYREAD(prec)/* just to avoid compiler warnings */ continuer = 1; break; /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+        case (VX1000_PFM_IN_SIZE):  bsize = (10 * bsize) + (VX1000_INT)frmchr; continuer = 1; break;
+        default:  /* only here for MISRA */
+          break; /* only here for MISRA */
+      }
+      if ((0==continuer) && (0==(state & (VX1000_PFM_AFTER_WIDTH)))) /* start reading width number */
+      {
+        state |= (VX1000_PFM_IN_WIDTH);
+        width = (VX1000_INT)frmchr;
+        if (frmchr==0) { filler = \'0\'; }
+        continuer = 1;
+      }
+      if ((0==continuer) && (0==(state & (VX1000_PFM_AFTER_PREC)))) /* start reading precision number */
+      {
+        state |= (VX1000_PFM_IN_PREC);
+        prec = (VX1000_INT)frmchr;
+        VX1000_DUMMYREAD(prec) /* just to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+        continuer = 1;
+      }
+      if (0==continuer)
+      {
+        state |= (VX1000_PFM_INVALID);
+      }
+      continuer = 1;
+    }
+    if (0==continuer)
+    {
+      switch (state & ((VX1000_PFM_IN_WIDTH) | (VX1000_PFM_IN_PREC) | (VX1000_PFM_IN_SIZE))) /* stop any number */
+      {
+        case (VX1000_PFM_IN_WIDTH): state ^= (VX1000_PFM_IN_WIDTH) | (VX1000_PFM_AFTER_WIDTH); break;
+        case (VX1000_PFM_IN_PREC):  state ^= (VX1000_PFM_IN_PREC)  | (VX1000_PFM_AFTER_PREC);  break;
+        case (VX1000_PFM_IN_SIZE):  state ^= (VX1000_PFM_IN_SIZE)  | (VX1000_PFM_AFTER_SIZE);  break;
+        default:  /* only here for MISRA */
+          break; /* only here for MISRA */
+      }
+    }
+    if ((0==continuer) && (frmchr == \'l\'))
+    {
+      state |= (VX1000_PFM_IN_SIZE);
+      bsize += (VX1000_INT)(8 * (sizeof(VX1000_LONG) - sizeof(VX1000_INT)));
+      if (bsize > 64) { state |= (VX1000_PFM_INVALID); }
+      continuer = 1;
+    }
+    if (0==continuer)
+    {
+      switch (frmchr) /* get the format specifier */
+      {
+        case \'#\':
+          showbase = 1;
+          continuer = 1;
+          break;
+        case \'+\':
+          showpos = \'+\';
+          continuer = 1;
+          break;
+        case \'-\':
+          alignleft = 1;
+          continuer = 1;
+          break;
+        case \'L\':
+          state |= (VX1000_PFM_AFTER_SIZE);
+          bsize = 256;
+          continuer = 1;
+          break;
+        case \'I\': /* Microsoft specific size: start reading the number */
+          state |= (VX1000_PFM_IN_SIZE);
+          continuer = 1;
+          break;
+        case \'c\':
+          VX1000_SUFFUN(vx1000_MailboxPutchar)((VX1000_CHAR)va_arg(arglist, VX1000_INT));
+          state = (VX1000_PFM_NONE);
+          continuer = 1;
+          break;
+        case \'s\':
+          /* todo: care for alignment */
+          p = (VX1000_CHAR*)va_arg(arglist, VX1000_CHAR*);
+          while (p[0] != 0) { VX1000_SUFFUN(vx1000_MailboxPutchar)(p[0]); p = &p[1]; }
+          state = (VX1000_PFM_NONE);
+          continuer = 1;
+          break;
+        case \'o\':
+          digif = \'7\';
+          basesize = 8 * sizeof(VX1000_INT);
+          break;
+        case \'d\':
+          /* fall-through to \'i\' */
+        case \'i\':
+          /* fall-through to \'u\' */
+        case \'u\':
+          if (frmchr != \'u\') { signedtype = 1; } /* MISRA does not like if we do this in the d/i cases above so we need this additional if statement inside the u case */
+          digif = \'9\';
+          basesize = 8 * sizeof(VX1000_INT);
+          break;
+        case \'X\':
+          digif = \'F\';
+          basesize = 8 * sizeof(VX1000_INT);
+          break;
+        case \'x\':
+          digif = \'f\';
+          basesize = 8 * sizeof(VX1000_INT);
+          break;
+        case \'e\':
+        case \'E\':
+          /* scientific floats are not supported */
+          basesize = 128;
+          floattype= 1;
+          break;
+        case \'f\':
+        case \'F\':
+        case \'g\':
+        case \'G\':
+          /* fixed floats are not supported */
+          basesize = 64;
+          floattype= 1;
+          break;
+        default:
+          state |= (VX1000_PFM_INVALID);
+      }
+    }
+    if ((0==continuer) && (0==(state & (VX1000_PFM_INVALID))))
+    {
+      state = (VX1000_PFM_NONE);
+      if (bsize < basesize) { bsize = basesize; }
+      if (floattype != 0)
+      {
+        switch (bsize)
+        {
+          /* floats currently are not supported - just advance the pointer and print a hash sign as place holder */
+          case 64:  VX1000_SUFFUN(vx1000_MailboxPutchar)(\'#\'); fdummy = (VX1000_LDOUBL)va_arg(arglist, /*float*/VX1000_DOUBLE); continuer = 1; break;
+          case 128: VX1000_SUFFUN(vx1000_MailboxPutchar)(\'#\'); fdummy = (VX1000_LDOUBL)va_arg(arglist, VX1000_DOUBLE);          continuer = 1; break;
+          case 256: VX1000_SUFFUN(vx1000_MailboxPutchar)(\'#\'); fdummy = (VX1000_LDOUBL)va_arg(arglist, VX1000_LDOUBL);          continuer = 1; break;
+          default:    /* only here for MISRA */
+            VX1000_DUMMYREAD(fdummy) /* just to avoid compiler warnings */ /* PRQA S 3112 */ /* The code in this user callback may violate MISRA rule 14.2 because the dedicated goal of this code is to actually have no (side) effect at all (except avoiding possible warnings by some compilers */
+            break;    /* only here for MISRA */
+        }
+      }
+      else
+      {
+        switch (bsize)
+        {
+          case 8 * sizeof(VX1000_INT): number = (VX1000_LONG)va_arg(arglist, VX1000_INT);   break;
+          default:                     number = (VX1000_LONG)va_arg(arglist, VX1000_LONG);  break;
+          }
+          if (signedtype != 0)
+          {
+            if (number < 0)
+            {
+              number = -number;
+              showpos = \'-\';
+            }
+        }
+        if (showpos != \' \') { VX1000_SUFFUN(vx1000_MailboxPutchar)(showpos); }
+        switch (digif)
+        {
+          case \'7\':
+            i = 11;
+            numbuf[i] = 0;
+            while (i != 0)
+            {
+              i--; numbuf[i] = (VX1000_CHAR)(0x7UL & (VX1000_UINT32)number);
+              numbuf[i] += \'0\';
+              number = (VX1000_LONG)((VX1000_UINT32)number >> 3);
+            }
+            break;
+          case \'9\':
+            {
+              VX1000_UINT32 data0 = 0, data1 = 0, mask0, mask1;
+              for (i = 31; i >= 0; --i)
+              {
+                mask1 = (0x88888888UL & (data1 + 0x33333333UL)); mask0 = (0x88 & (data0 + 0x33));
+                data1 += (0x00000001UL & (((VX1000_UINT32)number) >> i)) + ((data1 + mask1) - (mask1 >> 2));
+                data0 += (data0 - (mask0 >> 2)) + (mask0 + (mask1 >> 31));
+              }
+              i = 10;
+              numbuf[i] = 0;
+              while (i != 0)
+              {
+                i--; numbuf[i] = (VX1000_CHAR)(0xFUL & data1);
+                numbuf[i] += \'0\';
+                data1 = (i != 2)? (data1 >> 4) : data0;
+              }
+            }
+            break;
+          case \'F\': /* fallthrough to \'f\' */
+          case \'f\':
+            digif -= 15;
+            i = 8;
+            numbuf[i] = 0;
+            while (i != 0)
+            {
+              frmchr = (VX1000_CHAR)(0xFUL & (VX1000_UINT32)number);
+              number = (VX1000_LONG)((VX1000_UINT32)number >> 4);
+              frmchr += (VX1000_CHAR)((frmchr > 9) ? digif : (VX1000_CHAR)\'0\');
+              i--; numbuf[i] = frmchr;
+            }
+            break;
+          default:  /* only here for MISRA */
+            break; /* only here for MISRA */
+        }
+        for (p = numbuf; (p[0] == \'0\') && (p[1] != 0); p = &p[1]) { }
+        if (alignleft == 1)
+        {
+          if ((showbase == 1) && (digif != \'9\'))
+          {
+            VX1000_SUFFUN(vx1000_MailboxPutchar)((VX1000_CHAR)\'0\');
+            if (digif != \'7\') { VX1000_SUFFUN(vx1000_MailboxPutchar)((VX1000_CHAR)\'x\'); }
+          }
+          for (; p[0] != 0; p = &p[1]) { VX1000_SUFFUN(vx1000_MailboxPutchar)(p[0]); width--; }
+          for (--width; width >= 0; width--) { VX1000_SUFFUN(vx1000_MailboxPutchar)(\' \');  }
+        }
+        else
+        {
+          for (p2 = p; p2[0] != 0; p2 = &p2[1]) { width--; }
+          for (--width; width >= 0; width--) { VX1000_SUFFUN(vx1000_MailboxPutchar)(filler); }
+          if ((showbase == 1) && (digif != \'9\'))
+          {
+            VX1000_SUFFUN(vx1000_MailboxPutchar)((VX1000_CHAR)\'0\');
+            if (digif != \'7\') { VX1000_SUFFUN(vx1000_MailboxPutchar)((VX1000_CHAR)\'x\'); }
+          }
+          for (; p[0] != 0; p = &p[1]) { VX1000_SUFFUN(vx1000_MailboxPutchar)(p[0]); }
+        }
+        continuer = 1;
+      }
+    }
+    if (0==continuer)
+    {
+      /* Reaching here means we misunderstood the format string and assumed stupid argument type.    /
+      /  To avoid invalid pointer accesses to any following arguments, we stop continuing the loop. */
+
+      /* todo: replace the following "error marker print" by a regular VX1000_ERRLOG(<new error code>) */
+      VX1000_SUFFUN(vx1000_MailboxPutchar)(\'!\');VX1000_SUFFUN(vx1000_MailboxPutchar)(64);VX1000_SUFFUN(vx1000_MailboxPutchar)(\'!\');
+    }
+  } /* for */
+  va_end(arglist); /* PRQA S 3199 */ /* it depends on the used compiler whether this statement has useful side effects or not */
+  /* Transmit the terminating 0x00. */
+  VX1000_SUFFUN(vx1000_MailboxPutchar)( (VX1000_UINT8)0x00U );
+}
+#endif /* VX1000_PRINTF_MINIMAL */
+
+
+
+#endif /* VX1000_MAILBOX_PRINTF */
+#endif /* VX1000_MAILBOX  && !VX1000_COMPILED_FOR_SLAVECORES */
+
+
+#if defined(VX1000_FKL_SUPPORT_ADDR) && (!defined(VX1000_COMPILED_FOR_SLAVECORES))
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_FlashPrepareLoop                                                                                     */
+/* API name:      VX1000_DETECT_FKL_REQUESTS                                                                                  */
+/* Wrapper API:   VX1000If_DetectFklRequests                                                                                  */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    None                                                                                                        */
+/* Preemption:                                                                                                                */
+/* Termination:   May leave entire system in an invalid state.                                                                */
+/* Precondition1: vx1000_InitAsyncEnd() must have been called.                                                                */
+/* Description:   Prevents the application from writing to RAM to enable successful flash kernel download;                    */
+/*                Busy waits for trigger command to jump to the transferred address.                                          */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+void VX1000_SUFFUN(vx1000_FlashPrepareLoop)(void)
+{
+  gVX1000.ToolDetectState |= (VX1000_UINT32)(VX1000_TDS_FKL_REQ_DETECTED);
+  VX1000_DISABLE_ALL_INTERRUPTS()                /* prevent other tasks / ISRs from overwriting RAM / reading flash */
+  VX1000_STOP_OS_TIMING_PROTECTION()             /* prevent Autosar OS in SC2 / SC4 from killing the loop/kernel */
+  VX1000_STOP_OTHER_CORES()                      /* prevent other cores (or DMA/PEC) from overwriting RAM / reading flash */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  VX1000_ENABLE_STD_RAM_MAPPING()                /* repair non-default RAM mapping (the FKL is linked to standard location) */
+
+  (VX1000_FKL_WORKSPACE)->DeprotectState     = (VX1000_UINT16)(VX1000_FKL_STATE1CODE); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  (VX1000_FKL_WORKSPACE)->DeprotectTrigger   = (VX1000_UINT16)(VX1000_FKL_TOSTATE1CODE); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  (VX1000_FKL_WORKSPACE)->TransitionTimeout  = (VX1000_UINT32)(VX1000_FKL_TRANSITION_TIMEOUT); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  (VX1000_FKL_WORKSPACE)->WdgData1           = (VX1000_UINT32)0xFFFFffffUL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  (VX1000_FKL_WORKSPACE)->WdgData2           = (VX1000_UINT32)0xFFFFffffUL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  (VX1000_FKL_WORKSPACE)->WdgData3_FklParam3 = (VX1000_UINT32)0xFFFFffffUL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+  VX1000_ADDR_TO_PTR2U32(VX1000_PTR2VFF_TO_ADDRESS(&((VX1000_FKL_WORKSPACE)->EntryPoint)))[0] = (VX1000_UINT32)0xFFFFFFFFUL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+
+#if !defined(VX1000_FKL_BOUNCEBACK)
+  /* Now normal operation of the ECU (Appl + XCP instrumentation) is stopped: tell the tool how to further communicate: */
+  gVX1000.MagicId = (VX1000_UINT32)(VX1000_FKL_SUPPORT_ADDR);
+  gVX1000.ToolDetectState |= (VX1000_UINT32)(VX1000_TDS_FKL_FORCED_IDLE);
+  /* Once the tool accepted the new communication area, no longer access gVX1000, because that location is likely to be */
+  /* reused for storing the flash kernel code, so reads would return invalid data and writes could destroy the kernel.  */
+
+  while (1) /* intentional infinite loop (can be left by pseudo call to FKL or by watchdog reset) */
+  {
+    /* The code inside this loop must not use stack (access non-register-ed local variables or call non-FKL functions) */
+    /* (if that can\'t be ensured, we\'d have to reload the SP with (VX1000_FKL_SUPPORT_ADDR-16): HW-SPECIFIC ASSEMBLY!) */
+    if ( (((VX1000_FKL_WORKSPACE)->TransitionTimeout != 0) && ((VX1000_FKL_WORKSPACE)->TransitionTimeout != 0)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    &&   (((VX1000_FKL_WORKSPACE)->TransitionTimeout != 0) && ((VX1000_FKL_WORKSPACE)->TransitionTimeout != 0)) ) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    {
+      (VX1000_FKL_WORKSPACE)->TransitionTimeout--; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      VX1000_SERVE_WATCHDOG(&((VX1000_FKL_WORKSPACE)->WdgData1)) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+    }
+    else
+    {
+      switch ((((VX1000_UINT32)((VX1000_FKL_WORKSPACE)->DeprotectState) << 8U) << 8U) | (VX1000_FKL_WORKSPACE)->DeprotectTrigger) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+      {
+      case ((VX1000_UINT32)(VX1000_FKL_STATE1CODE) << 16) | (VX1000_FKL_TOSTATE1CODE):
+        /* still in the initialisation phase */
+        break;
+      case ((VX1000_UINT32)(VX1000_FKL_STATE1CODE) << 16) | (VX1000_FKL_TOSTATE2CODE):
+        (VX1000_FKL_WORKSPACE)->TransitionTimeout = (VX1000_UINT32)(VX1000_FKL_TRANSITION_TIMEOUT); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        (VX1000_FKL_WORKSPACE)->DeprotectState = VX1000_FKL_STATE2CODE; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        break;
+      case ((VX1000_UINT32)(VX1000_FKL_STATE2CODE) << 16) | (VX1000_FKL_TOSTATE3CODE):
+        (VX1000_FKL_WORKSPACE)->TransitionTimeout = (VX1000_UINT32)(VX1000_FKL_TRANSITION_TIMEOUT); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        (VX1000_FKL_WORKSPACE)->DeprotectState = VX1000_FKL_STATE3CODE; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        break;
+      case ((VX1000_UINT32)(VX1000_FKL_STATE3CODE) << 16) | (VX1000_FKL_TOSTATE4CODE):
+        (VX1000_FKL_WORKSPACE)->TransitionTimeout = (VX1000_UINT32)(VX1000_FKL_TRANSITION_TIMEOUT); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        (VX1000_FKL_WORKSPACE)->DeprotectState = VX1000_FKL_STATE4CODE; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        break;
+      case ((VX1000_UINT32)(VX1000_FKL_STATE4CODE) << 16) | (VX1000_FKL_TOSTATE5CODE):
+        (VX1000_FKL_WORKSPACE)->TransitionTimeout = (VX1000_UINT32)(VX1000_FKL_TRANSITION_TIMEOUT); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        (VX1000_FKL_WORKSPACE)->DeprotectState = VX1000_FKL_STATE5CODE; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        break;
+      case ((VX1000_UINT32)(VX1000_FKL_STATE5CODE) << 16) | (VX1000_FKL_LAUNCHCODE):
+        (VX1000_FKL_WORKSPACE)->TransitionTimeout = 1UL; /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        if (VX1000_ADDR_TO_PTR2VU32(VX1000_PTR2VFF_TO_ADDRESS(&((VX1000_FKL_WORKSPACE)->EntryPoint)))[0] != 0xFFFFFFFFUL) /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        {
+          ((VX1000_FKL_WORKSPACE)->EntryPoint)((VX1000_FKL_WORKSPACE)->FklParam1, (VX1000_FKL_WORKSPACE)->FklParam2, (VX1000_FKL_WORKSPACE)->WdgData3_FklParam3);  /* call the FKL: will not return here */ /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+        }
+        break;
+      default:
+        /* bad trigger sequence detected */
+        while (1) /* intentional infinite loop without watchdog serving, will lead to watchdog reset */
+        {
+          /* intentionally left empty */
+        }
+        /*break; /-* unreachable code, intentionally here to please MISRA checkers */
+      }
+    }
+  }
+#else /* VX1000_FKL_BOUNCEBACK */
+  /* The user wants that the request is reflected back to the tool. */
+  gVX1000.ToolDetectState |= (VX1000_UINT32)(VX1000_TDS_FKL_REQ_IGNORED);
+  /* While the API now returns to the application, the VX device will start trying to force the ECU into debug/freeze mode */
+#endif /* VX1000_FKL_BOUNCEBACK */
+}
+#endif /* VX1000_FKL_SUPPORT_ADDR  && !VX1000_COMPILED_FOR_SLAVECORES */
+
+#if (VX1000_ERRLOG_SIZE != 0)
+/*----------------------------------------------------------------------------------------------------------------------------*/
+/* Internal name: vx1000_ErrLogger                                                                                            */
+/* API name:      VX1000_ERRLOGGER (internal)                                                                                 */
+/* Return value:  None                                                                                                        */
+/* Parameter1:    An error code.                                                                                              */
+/* Preemption:                                                                                                                */
+/* Termination:                                                                                                               */
+/* Precondition1: vx1000_InitAsyncStart() must have been called.                                                              */
+/* Description:   Log the error code to a ring buffer for later debug/support purposes                                        */
+/* Devel state:   Implemented                                                                                                 */
+/*----------------------------------------------------------------------------------------------------------------------------*/
+void VX1000_SUFFUN(vx1000_ErrLogger)( VX1000_UINT16 errorcode )
+{
+  VX1000_UINT8 currentI, nextI;
+  VX1000_UINT16 *logbuf = VX1000_ADDR_TO_PTR2U16(gVX1000.ErrLogAddr); /* PRQA S 0303 */ /* PRQA S 0306 */ /* cannot avoid violating MISRA rule 11.3 because addresses to be dereferenced are either exported as integer types to user/external tool or provided as such by user/external tool/hardware description, therefore VX1000_ADDR_TO_PTR2XXX/VX1000_PTR2XXX_TO_ADDRESS (either called directly or by macro expansion) requires a typecast */
+
+  VX1000_ENTER_SPINLOCK()
+  currentI = gVX1000.ErrLogIndex;
+  nextI = currentI + 1;
+  if (nextI >= gVX1000.ErrLogSize) { nextI = 0; }
+  gVX1000.ErrLogIndex = nextI;
+  VX1000_LEAVE_SPINLOCK()
+  logbuf[currentI] = errorcode;
+}
+#endif /* VX1000_ERRLOG_SIZE */
+
+#if !defined(VX1000_COMPILED_FOR_SLAVECORES) /* global data have to exist only once (in shared memory) */
+
+/* The following is VX1000_DATA, but split to allow separate linkage of gVX1000 at a user-defined address */
+#if defined(VX1000_STIM_BENCHMARK_DATA)
+VX1000_STIM_BENCHMARK_DATA;
+#endif /* VX1000_STIM_BENCHMARK_DATA */
+#if defined(VX1000_ECUID_DATA)
+VX1000_ECUID_DATA;
+#endif /* VX1000_ECUID_DATA */
+#if defined(VX1000_OLDA_BENCHMARK_DATA)
+VX1000_OLDA_BENCHMARK_DATA;
+#endif /* VX1000_OLDA_BENCHMARK_DATA */
+#if defined(VX1000_COLDSTART_BENCHMARK_DATA)
+VX1000_COLDSTART_BENCHMARK_DATA;
+#endif /* VX1000_COLDSTART_BENCHMARK_DATA */
+
+/* include user-defined lines with optional section pragmas to force individual linkage of VX1000 structure data. */
+#define VX1000_BEGSECT_VXSTRUCT_C
+#include "VX1000_cfg.h" /* PRQA S 5087 */ /* willingly violating MISRA rule 19.1 because the section pragmas are needed exactly here (and not at the start of the file) */
+#define VX1000_BEGSECT_VXSTRUCT_C_UNDO
+
+#if !defined(VX1000_USE_EXTERNAL_STRUCT_DATA)
+#if defined(VX1000_STRUCT_DATA)
+VX1000_STRUCT_DATA;
+#endif /* VX1000_STRUCT_DATA */
+#endif /* !VX1000_USE_EXTERNAL_STRUCT_DATA */
+
+/* include user-defined lines with optional section pragmas to restore previous linkage of data: */
+#define VX1000_ENDSECT_VXSTRUCT_C
+#include "VX1000_cfg.h" /* PRQA S 5087 */ /* willingly violating MISRA rule 19.1 because the section pragmas are needed exactly here (and not at the start of the file) */
+#define VX1000_ENDSECT_VXSTRUCT_C_UNDO
+
+#endif /* !VX1000_COMPILED_FOR_SLAVECORES */
+
+/* Note that we were using nested section switches here (which might be unsupported by some compilers but has the    */
+/* advantage of not requiring #undefs (those would violate the MISRA coding guidelines) nor VX1000_xxxSECT_2         */
+/* defines (those would spoil the yyy_cfg.h file). This means that we SHOULDN\'T PLACE ANY FURTHER CODE OR DATA       */
+/* below (with the exception of external user code/data that explicitly shall NOT go into VX sections).              */
+
+/* include user-defined lines with optional section pragmas to restore standard linkage of code and/or data: */
+#define VX1000_ENDSECT_VXMODULE_C
+#include "VX1000_cfg.h" /* PRQA S 5087 */ /* willingly violating MISRA rule 19.1 because the section pragmas are needed exactly here (and not at the start of the file) */
+#define VX1000_ENDSECT_VXMODULE_C_UNDO
+
+#if !defined(VX1000_COMPILED_FOR_SLAVECORES) /* global data have to exist only once (in shared memory) */
+
+/* include user-defined lines with optional section pragmas to force individual linkage of EMEM header data. */
+#define VX1000_BEGSECT_EMEM_HDR_C
+#include "VX1000_cfg.h" /* PRQA S 5087 */ /* willingly violating MISRA rule 19.1 because the section pragmas are needed exactly here (and not at the start of the file) */
+#define VX1000_BEGSECT_EMEM_HDR_C_UNDO
+
+#if defined(VX1000_EMEM_HDR_DATA)
+VX1000_EMEM_HDR_DATA;
+#endif /* VX1000_EMEM_HDR_DATA */
+
+/* include user-defined lines with optional section pragmas to restore standard linkage of code and/or data: */
+#define VX1000_ENDSECT_EMEM_HDR_C
+#include "VX1000_cfg.h" /* PRQA S 5087 */ /* willingly violating MISRA rule 19.1 because the section pragmas are needed exactly here (and not at the start of the file) */
+#define VX1000_ENDSECT_EMEM_HDR_C_UNDO
+
+#endif /* !VX1000_COMPILED_FOR_SLAVECORES */
+
+#endif /* !VX1000_DISABLE_INSTRUMENTATION */
+
diff --git a/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/src/VX1000If.c b/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/src/VX1000If.c
new file mode 100644
index 000000000..5daee491f
--- /dev/null
+++ b/src/fw_cu/Components/Cmn/MeasAndCal/VX1060/src/VX1000If.c
@@ -0,0 +1,122 @@
+/**********************************************************************************************************************
+ *  COPYRIGHT
+ *  -------------------------------------------------------------------------------------------------------------------
+ *  \\verbatim
+ *  Copyright (c) 2017 by Vector Informatik GmbH.                                                  All rights reserved.
+ *
+ *                This software is copyright protected and proprietary to Vector Informatik GmbH.
+ *                Vector Informatik GmbH grants to you only those rights as set out in the license conditions.
+ *                All other rights remain with Vector Informatik GmbH.
+ *  \\endverbatim
+ *  -------------------------------------------------------------------------------------------------------------------
+ *  FILE DESCRIPTION
+ *  -----------------------------------------------------------------------------------------------------------------*/
+/**        \\file  VX1000If.c
+ *        \\brief  VX1000 Interface source file
+ *
+ *      \\details  Implementation of an API wrapper between ASAM names and proprietary VX1000 driver names.
+ *
+ *********************************************************************************************************************/
+ 
+/**********************************************************************************************************************
+ *  REVISION HISTORY
+ *  -------------------------------------------------------------------------------------------------------------------
+ *  Refer to the module\'s header file.
+ * 
+ *  FILE VERSION
+ *  -------------------------------------------------------------------------------------------------------------------
+ *  Refer to the VERSION CHECK below.
+ *********************************************************************************************************************/
+
+#define VX1000IF_SOURCE
+
+/**********************************************************************************************************************
+ *  INCLUDES
+ *********************************************************************************************************************/
+#include "VX1000If.h"
+
+/**********************************************************************************************************************
+ *  VERSION CHECK
+ *********************************************************************************************************************/
+/* Check the version of VX1000If header file */
+#if (  (VX1000IF_SW_MAJOR_VERSION != (1u)) \\
+    || (VX1000IF_SW_MINOR_VERSION != (2u)) \\
+    || (VX1000IF_SW_PATCH_VERSION != (0u)) )
+# error "Vendor specific version numbers of VX1000If.c and VX1000If.h are inconsistent"
+#endif
+
+/**********************************************************************************************************************
+ *  GLOBAL DATA
+ *********************************************************************************************************************/
+
+#define VX1000IF_START_SEC_VAR_ZERO_INIT_8BIT
+#include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_19.1 */
+
+/*! Initialization state of the module */
+VAR(uint8, VX1000IF_VAR_ZERO_INIT) VX1000If_State = VX1000IF_UNINIT; /*memmap cleared*/
+
+/*! Counter for errors that are caused by API calls when :
+ *     - VX1000 Interface is in incorrect state (e.g. not initialized) 
+ *     - or if VX1000If_IsVX1000DriverAccessEnabled returned FALSE 
+ */
+VAR(uint8, VX1000IF_VAR_ZERO_INIT) VX1000If_ErrorCount = 0; /*memmap cleared*/
+
+#define VX1000IF_STOP_SEC_VAR_ZERO_INIT_8BIT
+#include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_19.1 */
+
+/**********************************************************************************************************************
+ *  GLOBAL FUNCTIONS
+ *********************************************************************************************************************/
+#define VX1000IF_START_SEC_CODE
+#include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_19.1 */
+
+/**********************************************************************************************************************
+ *  VX1000If_InitMemory()
+ *********************************************************************************************************************/
+/*!
+ * Internal comment removed.
+ *
+ *
+ *
+ *
+ */
+FUNC(void, VX1000IF_CODE) VX1000If_InitMemory(void)
+{
+  /* ----- Implementation ----------------------------------------------- */
+  VX1000If_State = VX1000IF_UNINIT;
+
+  VX1000If_ErrorCount = 0;
+}  /* VX1000If_InitMemory() */
+
+/**********************************************************************************************************************
+ *  VX1000If_Init()
+ *********************************************************************************************************************/
+/*!
+ * Internal comment removed.
+ *
+ *
+ */
+FUNC(void, VX1000IF_CODE) VX1000If_Init(void)
+{
+  /* ----- Implementation ----------------------------------------------- */
+  /* #-- Set component to initialized */
+  if (VX1000If_State == VX1000IF_UNINIT)
+  {
+    VX1000If_State = VX1000IF_PRE_INIT;
+
+    VX1000If_ErrorCount = 0;
+  }
+} /* VX1000If_Init() */
+
+#define VX1000IF_STOP_SEC_CODE
+#include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_19.1 */
+
+/* MD_VX1000IF_0342: Rule: 19.13: K&R compilers do not support the ISO glue operator ##.
+     Reason:      Identifier has to be a combination of both IDs
+     Risk:        Compile error.
+     Prevention:  Not required.
+*/
+
+/**********************************************************************************************************************
+ *  END OF FILE: VX1000If.c
+ *********************************************************************************************************************/
diff --git a/src/fw_cu/Components/Cmn/Shared/MemMap/include/BasicNextGen_MemMap.h b/src/fw_cu/Components/Cmn/Shared/MemMap/include/BasicNextGen_MemMap.h
index 2d9e1e0a4..0b5c1204d 100644
--- a/src/fw_cu/Components/Cmn/Shared/MemMap/include/BasicNextGen_MemMap.h
+++ b/src/fw_cu/Components/Cmn/Shared/MemMap/include/BasicNextGen_MemMap.h
@@ -1932,6 +1932,38 @@
    #pragma section farbss  default
 #endif /* USE_A0_SECTION */
    #pragma section all default
+
+/* ************************************************************************* */
+#elif (defined DSPR2_VX1000_START_SEC_VAR_CLEARED)
+   #undef DSPR2_VX1000_START_SEC_VAR_CLEARED
+   #undef MEMMAP_ERROR
+   //~~~~~~~~~~~~~~~~~~~
+   #if START_SEC_OPEN != 0
+   #error Wrong MemMap.h usage: previous opened section was not closed!
+   #else
+   #undef START_SEC_OPEN
+   #define START_SEC_OPEN 55
+   #endif
+   //~~~~~~~~~~~~~~~~~~~
+//   #pragma data_core_association share
+   #pragma section all    "illegal_dspr2_bss_vx1000"
+   #pragma section farbss  "_dspr2_vx1000"
+   #pragma for_uninitialized_data_use_memory far
+
+#elif (defined DSPR2_VX1000_STOP_SEC_VAR_CLEARED)
+   #undef DSPR2_VX1000_STOP_SEC_VAR_CLEARED
+   #undef MEMMAP_ERROR
+   //~~~~~~~~~~~~~~~~~~~
+   #if START_SEC_OPEN != 55
+   #error Wrong MemMap.h usage: trying to close the previous opened section with a wrong stop-selector!
+   #else
+   #undef START_SEC_OPEN
+   #endif
+   //~~~~~~~~~~~~~~~~~~~
+   #pragma for_uninitialized_data_use_memory default
+   #pragma section farbss  default
+   #pragma section all default
+
 //   #pragma data_core_association restore
 /* ************************************************************************* */
 #elif (defined DSPR2_START_SEC_VAR_INIT)
diff --git a/src/fw_cu/Components/Cmn/Shared/MemMap/include/NextGen_MemMap.h b/src/fw_cu/Components/Cmn/Shared/MemMap/include/NextGen_MemMap.h
index 49ae213f1..92882c6c6 100644
--- a/src/fw_cu/Components/Cmn/Shared/MemMap/include/NextGen_MemMap.h
+++ b/src/fw_cu/Components/Cmn/Shared/MemMap/include/NextGen_MemMap.h
@@ -7931,24 +7931,44 @@
    #define SHARE_STOP_SEC_CODE_SLOW
    #include "BasicNextGen_MemMap.h"
 /* VX1000 Debugger ********************************************************* */
+#elif (defined VX1000IF_START_SEC_VAR_ZERO_INIT_8BIT)
+   #undef VX1000IF_START_SEC_VAR_ZERO_INIT_8BIT
+    //#define BSW_START_SEC_VAR_SLOW_INIT
+    #define DSPR2_START_SEC_VAR_INIT
+   #include "BasicNextGen_MemMap.h"
+#elif (defined VX1000IF_STOP_SEC_VAR_ZERO_INIT_8BIT)
+   #undef VX1000IF_STOP_SEC_VAR_ZERO_INIT_8BIT
+     //#define BSW_STOP_SEC_VAR_SLOW_INIT
+     #define DSPR2_STOP_SEC_VAR_INIT
+   #include "BasicNextGen_MemMap.h"
+
+#elif (defined VX1000IF_START_SEC_CODE)
+   #undef VX1000IF_START_SEC_CODE
+   #define BSW_START_SEC_CODE
+   #include "BasicNextGen_MemMap.h"
+#elif (defined VX1000IF_STOP_SEC_CODE)
+   #undef VX1000IF_STOP_SEC_CODE
+   #define BSW_STOP_SEC_CODE
+   #include "BasicNextGen_MemMap.h"
+   
 #elif (defined VX1000_START_SEC_VAR_CLEARED)
    #undef VX1000_START_SEC_VAR_CLEARED
 /* Use IVX1000_CORE1_START_SEC_VAR_CLEARED or VX1000_CORE2_START_SEC_VAR_CLEARED */
-   #define VX1000_CORE2_START_SEC_VAR_CLEARED
+   #define DSPR2_VX1000_START_SEC_VAR_CLEARED
    #include "BasicNextGen_MemMap.h"
 #elif (defined VX1000_STOP_SEC_VAR_CLEARED)
    #undef VX1000_STOP_SEC_VAR_CLEARED
 /* Use appropriately IVX1000_CORE1_STOP_SEC_VAR_CLEARED or VX1000_CORE2_STOP_SEC_VAR_CLEARED */
-   #define VX1000_CORE2_STOP_SEC_VAR_CLEARED
+   #define DSPR2_VX1000_STOP_SEC_VAR_CLEARED
    #include "BasicNextGen_MemMap.h"
 
 #elif (defined VX1000_START_SEC_CODE_SLOW)
    #undef VX1000_START_SEC_CODE_SLOW
-   #define SHARE_START_SEC_CODE_SLOW
+   #define BSW_START_SEC_CODE
    #include "BasicNextGen_MemMap.h"
 #elif (defined VX1000_STOP_SEC_CODE_SLOW)
    #undef VX1000_STOP_SEC_CODE_SLOW
-   #define SHARE_STOP_SEC_CODE_SLOW
+   #define BSW_STOP_SEC_CODE
    #include "BasicNextGen_MemMap.h"
 /* StartUp Sync ************************************************************ */
 #elif (defined STARTUP_CORE_SYNC_START_SEC_VAR_NOINIT)
diff --git a/src/fw_cu/Components/Cmn/VersInfo/VersInfo/include/swid.h b/src/fw_cu/Components/Cmn/VersInfo/VersInfo/include/swid.h
index dcade4491..5c7602a34 100644
--- a/src/fw_cu/Components/Cmn/VersInfo/VersInfo/include/swid.h
+++ b/src/fw_cu/Components/Cmn/VersInfo/VersInfo/include/swid.h
@@ -31,6 +31,7 @@
 /*================== [includes] =============================================*/
 #include "Std_Types.h"
 #include "version.h"
+#include "AdminTable_version.h"
 
 /*================== [defines] ==============================================*/
 #define VERSION_SIZE             (32U)
@@ -39,6 +40,7 @@
 #define PROD_DATA_OEM_ARRAY_SIZE (16U)
 #define PATTERN_ACTIVE           (0xA5U)
 #define CRETA_REVISION_SIZE\t\t (64U)
+#define A2L_FILENAME_SIZE        (38U)
 
 /*================== [type definitions] =====================================*/
 
@@ -248,6 +250,15 @@ extern const SWIDStampType SWIDStamp;
 #define START_SEC_CALIB_SLOW
 #include "MemMap.h"
 
+/*
+@@ SYMBOL = SWID_a2lfilename
+@@ A2L_TYPE = STRING 38
+@@ DESCRIPTION = "a2l file name used for XCP get id feature"
+@@ GROUP = SWID
+@@ END
+*/
+extern const uint8 SWID_a2lfilename[A2L_FILENAME_SIZE];
+
 /*
 @@ SYMBOL = F182_VWApplicationDataIdentification
 @@ A2L_TYPE = STRING 4
diff --git a/src/fw_cu/Components/Cmn/VersInfo/VersInfo/src/swid.c b/src/fw_cu/Components/Cmn/VersInfo/VersInfo/src/swid.c
index 829765559..144b3cb6e 100644
--- a/src/fw_cu/Components/Cmn/VersInfo/VersInfo/src/swid.c
+++ b/src/fw_cu/Components/Cmn/VersInfo/VersInfo/src/swid.c
@@ -142,6 +142,8 @@ const uint8 SWID_CretaRevisionName[CRETA_REVISION_SIZE] =
     0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u,
     0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u, 0x30u};
 
+const uint8 SWID_a2lfilename[A2L_FILENAME_SIZE] = CODE_IMAGE_BASE_NAME; /*Will be dynamically updated during build time*/
+
 #define STOP_SEC_CALIB_SLOW
 #include "MemMap.h"
 
diff --git a/src/fw_cu/Components/Inv/RtEnv/DrvCtrlSdl/src/DrvCtrlSdl.c b/src/fw_cu/Components/Inv/RtEnv/DrvCtrlSdl/src/DrvCtrlSdl.c
index 6db33dc4f..432d94f09 100644
--- a/src/fw_cu/Components/Inv/RtEnv/DrvCtrlSdl/src/DrvCtrlSdl.c
+++ b/src/fw_cu/Components/Inv/RtEnv/DrvCtrlSdl/src/DrvCtrlSdl.c
@@ -62,9 +62,7 @@
 #include "RotorAgSpdCalcn.h"
 #include "HvDcUMeas_Wrpr.h"
 #include "LlswGtm.h"
-#ifdef VX1000_ENABLED
-#include <vx1000_tc2xx.h>
-#endif
+#include "VX1000If.h"
 #include "ETK_SER_Handshake.h"
 #include "Distab13.h"
 #include "IfxStm_reg.h"
@@ -145,6 +143,7 @@
 /*================== [defines] ==============================================*/
 #define TS_PWM_RESERVE_TICKS         (50u)
 #define TS_10MS_TASK_PERIOD          (5u) /* 10ms tasks are called in 2ms time slice */
+#define VX1000_ENABLED
 
 /*================== [type definitions] =====================================*/
 
@@ -1991,10 +1990,7 @@ FUNC(void, DRVCTRLSDL_CODE) DrvCtrlSdl_Init(void) /*PRQA S 1503*/
    /* *** Start Modulator and Demodulator of module Dsadc *** */
    /*   Dsadc_EnableModDemod(); */
 #endif
-
-#ifdef VX1000_ENABLED
-   VX1000_INIT()
-#endif
+  /* VX1000 Application Driver Initialisation */
 
    /* QSPI Init */
    /*! \\misra Warning  Msg(3200) This function has been declared with a "non-void" return type but the value returned from this function call is not being assigned or checked.There are 2 types of function this is not the ca se because the variable is depend on an calib */
diff --git a/src/fw_cu/linker/linker.lsl b/src/fw_cu/linker/linker.lsl
index e005d48c1..24bc83c47 100644
--- a/src/fw_cu/linker/linker.lsl
+++ b/src/fw_cu/linker/linker.lsl
@@ -1661,12 +1661,10 @@ section_layout mpe:tc2:linear
 
    section_layout mpe:vtc:linear
    {
-    /* ----- */
-    /*  "VX1000 fast core 2" [50014800 .. 50014BFF] */
-    group VX1000.Core2(contiguous, run_addr = [0x50014800 .. 0x50014C00]){
-        select ".bss.VX1000_core2";
-    }
-    /* ----- */
+      group VX_dspr2_Meas_data_gr(contiguous, run_addr = mem:dspr2/global[0x06800 .. 0x0A800])
+\t  {
+          select ".bss._dspr2_vx1000";
+      }
    }// section_layout mpe:vtc:linear
 
    section_layout mpe:tc2:linear
'
