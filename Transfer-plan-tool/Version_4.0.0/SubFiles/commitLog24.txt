b'commit e6596acbeba9d05b266d62d5838b100d65d3304a
Author: Adi GODAVARTHI (JV) <adi.godavarthi.jv@valeo.com>
Date:   Tue Mar 22 18:19:42 2022 +0100

    $100kW-55049$ - [FCT_Control_Parking_Position] - SENT [implementation]
    
    Change-Id: I53886d873d63b65b3cfe06070483a6b60950269e

diff --git a/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/src/LlswSENT.c b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/src/LlswSENT.c
index 8920146ac..780f25fd6 100644
--- a/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/src/LlswSENT.c
+++ b/src/fw_cu/Components/Cmn/ValMeasAndProc/LlswSENT/src/LlswSENT.c
@@ -35,19 +35,32 @@
 #include "IfxScuWdt.h"
 #include "LLSW_CompilerAbstraction.h"
 #include "Compiler.h"
+#include "SftyDma.h"
 
 /*================== [defines] ==============================================*/
-#define WATCH_DOG_ENABLED                    FALSE
-#define ISR_PRIORITY_SENT                    0xF3
-#define SENT_FRAMECHECKMODE_PASTSYNCPULSE    0U
-#define LLSW_N_P5V_PLC_SENS_EN_OMCR_PCL      MODULE_P11.OMCR.B.PCL9
+
+#define ISR_PRIORITY_SENT                    0xF3   /* CORE2 ISR is used only for debugging purpose to check the errors reported.
+                                                       By default the CPU2 interrupt is disabled */
 
 /*================== [declaration of public data] =================================*/
 
 #define SENT_SHARED_BUFFER_START_SEC_VAR_CLEARED
 #include "MemMap.h"
 
-static uint32 Sent_ErrorStatus;
+static uint32 LLSW_Sent_ErrorFlags;
+
+#ifdef SENT_DEBUG
+
+extern SftyDma_ParkLockSENTDataType LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx;
+extern SftyDma_DataType LLSW_SftyDmaParkLockEvlnSENTStsInfoRx;
+
+static uint32 LLSW_Fast_Timestampold, LLSW_Fast_StatusFlags, LLSW_Fast_TimeDifference, LLSW_Fast_Framecount;
+static uint32 LLSW_Slow_Timestampold, LLSW_Slow_StatusFlags, LLSW_Slow_TimeDifference, LLSW_Slow_Framecount;
+static uint32 LLSW_Watchdog_Timestampold, LLSW_Watchdog_StatusFlags, LLSW_Watchdog_Errorcount;
+static uint8 LLSW_CRC_input[6] = {0x5, 0x3, 0xD, 2, 0xC, 0xA};
+/* static uint32 LLSW_statusnibblecapture[100], LLSW_temp, LLSW_i; */
+
+#endif
 
 #define SENT_SHARED_BUFFER_STOP_SEC_VAR_CLEARED
 #include "MemMap.h"
@@ -56,13 +69,72 @@ static uint32 Sent_ErrorStatus;
 
 /*================== [local data] ===========================================*/
 
+#ifdef SENT_DEBUG
+
+uint8 LlswSENT_CRCcalc(void)
+{
+   const uint8 CrcLookup[16] = {0, 13, 7, 10, 14, 3, 9, 4, 1, 12, 6, 11, 15, 2, 8, 5};
+   uint8 i, CRC_output;
+
+   CRC_output = 5; /* initialise with the SEED 0101 */
+
+   for (i=0; i<6; i++)
+   {
+      CRC_output = LLSW_CRC_input[i] ^ CrcLookup[CRC_output];
+   }
+   CRC_output = CrcLookup[CRC_output];
+
+   return CRC_output;
+
+}
+
+void Llsw_SENT_Testing(void)  /* Call this function 1ms raster */
+{
+    if(LLSW_Fast_Timestampold != LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx.TiStampRts)
+    {
+        LLSW_Fast_TimeDifference = LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx.TiStampRts - LLSW_Fast_Timestampold;
+        LLSW_Fast_StatusFlags = SENT_CH9_INTSTAT.U;
+        SENT_CH9_INTCLR.U = 0x3;
+        LLSW_Fast_Timestampold = LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx.TiStampRts;
+        LLSW_Fast_Framecount++;
+
+    /*  LLSW_temp = LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx.CrcData;
+        LLSW_temp = LLSW_temp >> 8;
+        LLSW_statusnibblecapture[LLSW_i] = LLSW_temp;
+        LLSW_i++;
+        if(LLSW_i == 100)
+        {
+            LLSW_i = 0;
+        } */
+    }
+
+    if(LLSW_Slow_Timestampold != LLSW_SftyDmaParkLockEvlnSENTStsInfoRx.tiStamp)
+    {
+        LLSW_Slow_TimeDifference = LLSW_SftyDmaParkLockEvlnSENTStsInfoRx.tiStamp - LLSW_Slow_Timestampold;
+        LLSW_Slow_StatusFlags = SENT_CH9_INTSTAT.U;
+        SENT_CH9_INTCLR.U = 0x800;  /* Clear serial data receive interrupt flag SDI BIT-11 */
+        LLSW_Slow_Timestampold = LLSW_SftyDmaParkLockEvlnSENTStsInfoRx.tiStamp;
+        LLSW_Slow_Framecount++;
+    }
+
+    if(LLSW_Watchdog_Timestampold != LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx.TiStampDma)
+    {
+        LLSW_Watchdog_StatusFlags = SENT_CH9_INTSTAT.U;
+        SENT_CH9_INTCLR.U = 0x2000;  /* Clear watchdog interrupt - BIT13  */
+        LLSW_Watchdog_Timestampold = LLSW_SftyDmaParkLockPosnAcqnSENTSnrDataRx.TiStampDma;
+        LLSW_Watchdog_Errorcount++;
+    }
+}
+#endif
+
+
 #define SENT_START_SEC_CODE_FAST
 #include "MemMap.h"
 
 IFX_INTERRUPT(isr_sent, VTABLE_CPU2, ISR_PRIORITY_SENT)   /*PRQA S 3432, 3408*/ /* ISR */
 {
-   Sent_ErrorStatus = SENT_CH9_INTSTAT.U;
-   SENT_CH9_INTCLR.U = (Sent_ErrorStatus & 0x17FCU);  /* 0x17FC: 01 0111 1111 1100      clearing of error flags
+   LLSW_Sent_ErrorFlags = SENT_CH9_INTSTAT.U;
+   SENT_CH9_INTCLR.U = (LLSW_Sent_ErrorFlags & 0x17FCU);  /* 0x17FC: 01 0111 1111 1100      clearing of error flags
                                                         Ensure that bit13(WDI), bit11(SDI), bit1(RDI), bit0(RSI) are not cleared */
 }
 
@@ -104,39 +176,40 @@ void LlswSENT_Init(void)                             /* PRQA S 4700*/ /* Metric
     mySENT_FDR.B.DM       = 1U;                      /* Fractional divider not required, pass 1:1 */
     SENT_FDR.U            = mySENT_FDR.U;
 
-    SENT_TPD.B.TDIV       = 0U;                      /* time stamp pre-divider */
+    SENT_TPD.B.TDIV       = 0U;                      /* time stamp pre-divider. Time stamp updates with Ffracdiv. Fsys = Fsent = Ffracdiv = 100MHz */
 
     IfxScuWdt_setCpuEndinit(passwd);
 
     SENT_CH9_RCR.B.CEN    = 0U;                      /* disable channel 9. RCR.CEN must be cleared before changing CPDR.PDIV or CFDR.DIV */
 
-    SENT_CH9_CPDR.B.PDIV  = 0U;                      /* Fsys = Fsent = 100MHz. Ffracdiv = 100MHz. Fpdiv = 100MHz */
+    SENT_CH9_CPDR.B.PDIV  = 4U;                      /* Fpdiv = 20MHz. Reason: FRLEN is a 16 bit counter driven by Fpdiv. With 20MHz we can measure the fame length upto 3276 us */
+    SENT_CH9_CFDR.B.DIV   = 6406U;                   /* 20*56*5.72 = 6406.  DIV must be set in the range of [2200, 49100]
+                                                        This value is derived based on the TICK length of the KMZ sensor. Measure the calibration pulse length in CRO and identify the TICK length */
+                                                     /* The clock signal fpdiv of a channel must always be at least 20 times the nominal tick frequency of the channel.*/
+                                                     /* Ftick = Fpdiv x 56 / DIV */
 
-    SENT_CH9_CFDR.B.DIV   = 33600U;                  /* 100*56*6 = 33600.  DIV must be set in the range of [2200, 49100]
-                                                        This value is derived based on the TICK length of the KMZ sensor.
-                                                        Measure the calibration pulse length in CRO and identify the TICK length */
     mySENT_CH_RCR.U       = 0U;
-    mySENT_CH_RCR.B.IEP   = 0U;                      /* 0: End pulse (pause) not ignored.  1: End pulse (pause) ignored */
+    mySENT_CH_RCR.B.IEP   = 1U;                      /* 0: End pulse (pause) not ignored.  1: End pulse (pause) ignored.
+                                                           The FDFL mode is entered if FDFL,IEP and IDE are set.
+                                                           Serial data interrupt is raised in FDFL mode only */
     mySENT_CH_RCR.B.ACE   = 0U;                      /* 0: Serial CRC calculation as specified in J2716 JAN2010    1: Alternative 4 bit in parallel CRC */
     mySENT_CH_RCR.B.SNI   = 0U;                      /* 0: Status Nibble not included in CRC   1: Status Nibble included in CRC */
-    mySENT_CH_RCR.B.SDP   = 0U;                      /* 0: Automatic Serial Data Processing is disabled   1:Automatic Serial Data Processing is enabled */
-                                                     /* -----------TODO-------------------------*/
-    mySENT_CH_RCR.B.SCDIS = 1U;                      /* 0: CRC for serial data enabled   1: CRC for serial data disabled (CRC nibble can be read from SDSx.
-                                                           The CPU must perform the CRC on the current data by SW) */
-    mySENT_CH_RCR.B.CDIS  = 0U;                      /* 0: CRC is enabled  1: CRC is disabled (CRC nibble can be read from RSRx.
+    mySENT_CH_RCR.B.SDP   = 1U;                      /* 0: Automatic Serial Data Processing is disabled   1:Automatic Serial Data Processing is enabled */
+    mySENT_CH_RCR.B.SCDIS = 0U;                      /* 0: CRC for serial data enabled   1: CRC for serial data disabled (CRC nibble can be read from SDSx.
+                                                          The CPU must perform the CRC on the current data by SW) */
+    mySENT_CH_RCR.B.CDIS  = 0U;                      /* 0: CRC check is enabled  1: CRC is disabled (CRC nibble can be read from RSRx.
                                                            The CPU must perform the CRC on the current data by SW) */
- /* mySENT_CH_RCR.B.CFC   = SENT_FRAMECHECKMODE_PASTSYNCPULSE;     ---TODO----- */
+    mySENT_CH_RCR.B.CFC   = 0U;
 
     mySENT_CH_RCR.B.FRL   = 6U;                      /* frame length */
     mySENT_CH_RCR.B.CRZ   = 0U;                      /* 0: Augmentation is selected for both 4-bit message CRC and the 4-bit CRC of the serial messages (legacy, 16 frames) (default)
                                                         1: Augmentation is switched off for both 4-bit message CRC and the 4-bit CRC of the serial messages (legacy, 16 frames) */
-                                                     /*  ---------------TODO -----------------*/
 
     mySENT_CH_RCR.B.ESF   = 1U;                      /* serial frame
                                                         0: 16 frames (4bit ID, 8bit DATA, 4bit CRC)
                                                         1: 18 frames  (4/8bit ID, 12/16bit DATA, 6bit CRC) */
 
-    mySENT_CH_RCR.B.IDE   = 0U;                      /* 0: Drift Errors enabled    1: Drift Errors disabled
+    mySENT_CH_RCR.B.IDE   = 1U;                      /* 0: Drift Errors enabled    1: Drift Errors disabled
                                                         This bit selects if drift errors lead to frame rejection and if an interrupt(INTSTAT.FDI) is generated.
                                                         During a long pause period the accumulated drift could be more than 1.5625%  In this case drift error can be disabled */
 
@@ -147,11 +220,13 @@ void LlswSENT_Init(void)                             /* PRQA S 4700*/ /* Metric
                                                            the module is stopped while all registers of the channel stay readable.
                                                            The receiver is stopped unconditionally. A partly received frame is discarded */
 
-    mySENT_CH_RCR.B.FDFL  = 0U;                      /* Frequency Drift Check based on Frame Length.
+    mySENT_CH_RCR.B.FDFL  = 1U;                      /* Frequency Drift Check based on Frame Length.
                                                         0: FDFL mode deactivated, RCR.CFC is valid (if IDE is cleared).
                                                         1: FDFL mode is activated, IEP and IDE must be set too for proper function  */
     SENT_CH9_RCR.U        = mySENT_CH_RCR.U;
 
+    SENT_CH9_WDT.U        = 333U;                    /* for TICK = 3us, frame length is less than 1ms. Watch-dog time limit is 1ms. 1000/3 = 333. */
+
     mytempVIEW.U          = 0U;
     mytempVIEW.B.RDNP0    = 0U;
     mytempVIEW.B.RDNP1    = 1U;
@@ -179,11 +254,12 @@ void LlswSENT_Init(void)                             /* PRQA S 4700*/ /* Metric
     mytempINP.B.TDI       = 0U;                      /* Not needed. TDI not enabled */
     mytempINP.B.TBI       = 0U;                      /* Not needed. TBI not enabled */
     mytempINP.B.RSI       = 0U;                      /* Not needed. RSI not enabled */
-    mytempINP.B.RDI       = 0U;                      /* trigger0 (TRIG0) */
-    mytempINP.B.WDI       = 1U;                      /* trigger1 (TRIG1) */
-    mytempINP.B.SDI       = 2U;                      /* trigger2 (TRIG2) */
+    mytempINP.B.RDI       = 0U;                      /* trigger0 (TRIG0). Route the fast channel to trigger0 interrupt  */
+    mytempINP.B.WDI       = 1U;                      /* trigger1 (TRIG1). Route the watch-dog to trigger1 interrupt */
+    mytempINP.B.SDI       = 2U;                      /* trigger2 (TRIG2). Route the slow channel to trigger2 interrupt */
     mytempINP.B.RBI       = 3U;                      /* trigger3 (TRIG3) */
-    mytempINP.B.ERRI      = 3U;                      /* trigger3 (TRIG3). ERRI is one single node pointer for FRI + FDI + NNI + NVI + CRCI + WSI + SCRI */
+    mytempINP.B.ERRI      = 3U;                      /* trigger3 (TRIG3). ERRI is one single node pointer for FRI + FDI + NNI + NVI + CRCI + WSI + SCRI
+                                                        Route all the errors to trigger3 interrupt. trigger3 should go to CPU2 to monitor the errors. TRIG3-CPU2 is for development purpose */
     SENT_CH9_INP.U        = mytempINP.U;
 
     mySENT_INTEN.U        = 0U;
@@ -199,18 +275,16 @@ void LlswSENT_Init(void)                             /* PRQA S 4700*/ /* Metric
     mySENT_INTEN.B.NNI    = 1U;                      /* Number of Nibbles Wrong. More nibbles or too few nibbles */
     mySENT_INTEN.B.NVI    = 1U;                      /* Nibbles Value out of Range */
     mySENT_INTEN.B.CRCI   = 0U;                      /* CRC error */
-    mySENT_INTEN.B.WSI    = 0U;                      /* ------------- TODO --------------------------*/
-                                                     /* Wrong Status and Communication Nibble Error Request Flag. In Short Serial Frame Mode (RCR.ESF is cleared),
+    mySENT_INTEN.B.WSI    = 0U;                      /* Wrong Status and Communication Nibble Error Request Flag. In Short Serial Frame Mode (RCR.ESF is cleared),
                                                         this bit is set if the Status and Communication nibble shows a start bit in a frame other than frame number n x 16.
                                                         In Enhanced Serial Frame Mode this bit is without function.*/
 
-    mySENT_INTEN.B.SDI    = 0U;                      /* ------------- TODO --------------------------
-                                                        Serial Data Receive Interrupt Request Flag. This bit is set after all serial data bits have been received via the Status
+    mySENT_INTEN.B.SDI    = 1U;                      /* Serial Data Receive Interrupt Request Flag. This bit is set after all serial data bits have been received via the Status
                                                         and Communication nibble. Depending on bit RCRx.SCDIS this indicates a successful check of the CRC */
 
-    mySENT_INTEN.B.SCRI   = 0U;                      /* Serial Data CRC Error */
+    mySENT_INTEN.B.SCRI   =1U;                      /* Serial Data CRC Error */
 
-    mySENT_INTEN.B.WDI    = 0U;                      /* ------------- TODO -------------------------- */
+    mySENT_INTEN.B.WDI    = 1U;
     SENT_CH9_INTEN.U      = mySENT_INTEN.U;
 
     mySRC_SRCR.U          = 0U;
@@ -222,14 +296,14 @@ void LlswSENT_Init(void)                             /* PRQA S 4700*/ /* Metric
 
     mySRC_SRCR.U          = 0U;
     mySRC_SRCR.B.SRPN     = (uint32)SFTY_DMA_DRVR_CH_IDX_SENT_TIMEOUT_STATUS;
-    mySRC_SRCR.B.SRE      = 0U;                      /* ------------- TODO -------------------------- */
+    mySRC_SRCR.B.SRE      = 1U;
     mySRC_SRCR.B.TOS      = TOS_DMA;
     mySRC_SRCR.B.CLRR     = 1U;
     SRC_SENT1.U           = mySRC_SRCR.U;            /* TRIG1 goes to SRC1 */
 
     mySRC_SRCR.U          = 0U;
     mySRC_SRCR.B.SRPN     = (uint32)SFTY_DMA_DRVR_CH_IDX_SENT_FAULTSTATUS;
-    mySRC_SRCR.B.SRE      = 0U;                      /* ------------- TODO -------------------------- */
+    mySRC_SRCR.B.SRE      = 1U;
     mySRC_SRCR.B.TOS      = TOS_DMA;
     mySRC_SRCR.B.CLRR     = 1U;
     SRC_SENT2.U           = mySRC_SRCR.U;            /* TRIG2 goes to SRC2 */
@@ -241,7 +315,7 @@ void LlswSENT_Init(void)                             /* PRQA S 4700*/ /* Metric
     mySRC_SRCR.B.CLRR     = 1U;
     SRC_SENT3.U           = mySRC_SRCR.U;            /* TRIG3 goes to SRC3 */
 
-    SENT_CH9_RCR.B.CEN    = 1U;
+    SENT_CH9_RCR.B.CEN    = 0U;                      /* ------------- TODO -------------------------- */
 
 }
 
'
